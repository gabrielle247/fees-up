
// ==========================================
// FILE: ./repositories/dashboard_repository.dart
// ==========================================

import '../services/database_service.dart';

class DashboardRepository {
  final DatabaseService _db;

  DashboardRepository(this._db);

  /// 1. Get the Current User's School ID and Name
  Future<Map<String, dynamic>?> getSchoolDetails(String userId) async {
    // First, find the user's profile to get the school_id
    final profile = await _db.getById('user_profiles', userId);
    if (profile == null || profile['school_id'] == null) return null;

    final schoolId = profile['school_id'];
    
    // Then get the school details
    final school = await _db.getById('schools', schoolId);
    
    return {
      'school_id': schoolId,
      'school_name': school?['name'] ?? 'My School',
      'user_role': profile['role'] ?? 'Admin',
      'user_name': profile['full_name'] ?? 'User',
    };
  }

  /// 2. Watch Key Stats (Real-time)
  /// We combine multiple streams into one or just watch specific tables.
  /// For performance, we usually watch tables and calculate sums in Dart for small datasets,
  /// or use SQL queries if PowerSync supports the aggregate subscription (it does via watch()).
  
  Stream<int> watchStudentCount(String schoolId) {
    return _db.db.watch(
      'SELECT count(*) as count FROM students WHERE school_id = ? AND is_active = 1',
      parameters: [schoolId]
    ).map((results) => results.first['count'] as int);
  }

  Stream<double> watchOutstandingBills(String schoolId) {
    return _db.db.watch(
      'SELECT sum(total_amount - paid_amount) as total FROM bills WHERE school_id = ? AND is_paid = 0',
      parameters: [schoolId]
    ).map((results) => (results.first['total'] as num?)?.toDouble() ?? 0.0);
  }

  Stream<double> watchDailyAttendance(String schoolId) {
    // Simple calculation: Present / Total Students today
    // This is a simplified logic for the dashboard view
    final today = DateTime.now().toIso8601String().split('T')[0];
    return _db.db.watch(
      "SELECT count(*) as count FROM attendance WHERE school_id = ? AND date = ? AND status = 'present'",
      parameters: [schoolId, today]
    ).map((results) => (results.first['count'] as num?)?.toDouble() ?? 0.0);
  }

  /// 3. Get Recent Transactions
  Stream<List<Map<String, dynamic>>> watchRecentPayments(String schoolId) {
    return _db.db.watch(
      'SELECT * FROM payments WHERE school_id = ? ORDER BY date_paid DESC LIMIT 5',
      parameters: [schoolId]
    );
  }
}
// ==========================================
// FILE: ./repositories/year_configuration_repository.dart
// ==========================================

/// Year Configuration Repository
/// Handles all database operations for school years, billing months, and terms.
/// This repository is the ONLY place database writes happen for year data.
library;

abstract class YearConfigurationRepository {
  /// Load complete year data including months and terms
  Future<Map<String, dynamic>?> loadYear(
    String yearId,
    String schoolId,
  );

  /// Save year with atomic transaction
  /// Ensures year + all months save together or rollback together
  Future<void> saveYear({
    required String yearId,
    required String schoolId,
    required String yearLabel,
    required String startDate,
    required String endDate,
    required String description,
    required bool active,
    required List<Map<String, dynamic>> terms,
    required List<String> removedTermIds,
    required List<Map<String, dynamic>> months,
  });

  /// Watch year changes in real-time
  Stream<Map<String, dynamic>?> watchYear(
    String yearId,
    String schoolId,
  );

  /// Watch months for a year
  Stream<List<Map<String, dynamic>>> watchMonths(
    String yearId,
    String schoolId,
  );
}

class YearConfigurationException implements Exception {
  final String message;
  YearConfigurationException(this.message);

  @override
  String toString() => 'YearConfigurationException: $message';
}

// ==========================================
// FILE: ./repositories/payment_repository.dart
// ==========================================

/// Payment Repository Interface
///
/// Defines the contract for payment-related operations.
/// This abstracts the database layer from the UI layer.
///
/// **Why this exists:**
/// The QuickPaymentDialog was directly calling _dbService.db.watch(),
/// which tightly couples the widget to the database implementation.
/// This repository provides a clean interface for all payment operations.
library;

/// Represents a single payment record from the database.
class Payment {
  final String id;
  final String studentId;
  final double amount;
  final String method; // 'Cash', 'Check', 'Card', 'Mobile'
  final DateTime recordedDate;
  final String? description;
  final String allocatedToInvoiceId;

  Payment({
    required this.id,
    required this.studentId,
    required this.amount,
    required this.method,
    required this.recordedDate,
    this.description,
    required this.allocatedToInvoiceId,
  });

  /// Convert from database Map to Payment object
  factory Payment.fromMap(Map<String, dynamic> map) {
    return Payment(
      id: map['id'] as String,
      studentId: map['student_id'] as String,
      amount: (map['amount'] as num).toDouble(),
      method: map['method'] as String,
      recordedDate: DateTime.parse(map['recorded_date'] as String),
      description: map['description'] as String?,
      allocatedToInvoiceId: map['allocated_to_invoice_id'] as String,
    );
  }

  /// Convert Payment object to database Map
  Map<String, dynamic> toMap() {
    return {
      'id': id,
      'student_id': studentId,
      'amount': amount,
      'method': method,
      'recorded_date': recordedDate.toIso8601String(),
      'description': description,
      'allocated_to_invoice_id': allocatedToInvoiceId,
    };
  }
}

/// Abstract repository interface for payment operations.
///
/// All database access should go through this interface.
/// This allows:
/// - Easy testing (mock the interface)
/// - Database implementation changes without affecting UI
/// - Shared payment logic across the app (not duplicated in dialogs)
abstract class PaymentRepository {
  /// Record a new payment for a student.
  ///
  /// **Atomicity guaranteed:** This operation is atomic at the database level.
  /// Either the payment is recorded AND the bill is updated, or neither happens.
  /// This prevents database inconsistency even if the app crashes mid-operation.
  ///
  /// Parameters:
  /// - [studentId]: The student receiving the payment
  /// - [amount]: Payment amount in currency units
  /// - [method]: Payment method ('Cash', 'Check', 'Card', 'Mobile', etc)
  /// - [invoiceId]: Which invoice this payment is allocated to
  /// - [description]: Optional notes about the payment
  ///
  /// Returns: The newly created Payment object
  ///
  /// Throws: [PaymentException] if recording fails
  Future<Payment> recordPayment({
    required String studentId,
    required double amount,
    required String method,
    required String invoiceId,
    String? description,
  });

  /// Get the payment history for a specific student.
  ///
  /// Returns a stream of payment lists that updates in real-time
  /// when new payments are recorded (by this app or others).
  ///
  /// Parameters:
  /// - [studentId]: The student whose payments to retrieve
  ///
  /// Returns: Stream<List<Payment>> ordered by date (newest first)
  Stream<List<Payment>> watchPaymentsForStudent(String studentId);

  /// Allocate an existing payment to different invoices.
  ///
  /// Example: A $100 payment can be split:
  /// - $50 to Invoice A
  /// - $50 to Invoice B
  ///
  /// **Atomicity guaranteed** at the database level.
  ///
  /// Parameters:
  /// - [paymentId]: The payment to reallocate
  /// - [allocations]: Map of invoiceId → amount
  ///
  /// Throws: [PaymentException] if allocations don't sum correctly
  Future<void> allocatePayment({
    required String paymentId,
    required Map<String, double> allocations,
  });

  /// Delete a payment record.
  ///
  /// WARNING: This also reverses any bill updates made when the payment
  /// was recorded. Use with caution - consider marking as "void" instead
  /// for audit trail purposes.
  ///
  /// **Atomicity guaranteed** at the database level.
  ///
  /// Throws: [PaymentException] if payment not found
  Future<void> deletePayment(String paymentId);

  /// Get total amount paid by a student (for summary/stats).
  ///
  /// Parameters:
  /// - [studentId]: The student to summarize
  /// - [startDate]: Optional filter (only payments on/after this date)
  /// - [endDate]: Optional filter (only payments on/before this date)
  ///
  /// Returns: Total amount paid in the period
  Future<double> getTotalPaidByStudent({
    required String studentId,
    DateTime? startDate,
    DateTime? endDate,
  });

  /// Get outstanding balance for a student.
  ///
  /// This is calculated as: Total invoiced - Total paid
  ///
  /// Parameters:
  /// - [studentId]: The student to check
  ///
  /// Returns: Outstanding amount (negative = overpaid)
  Future<double> getOutstandingBalance(String studentId);
}

/// Base exception for payment-related errors.
class PaymentException implements Exception {
  final String message;
  final String? code;

  PaymentException(this.message, {this.code});

  @override
  String toString() =>
      'PaymentException: $message${code != null ? ' ($code)' : ''}';
}

/// Thrown when payment validation fails (invalid amount, student not found, etc.)
class PaymentValidationException extends PaymentException {
  PaymentValidationException(super.message) : super(code: 'VALIDATION_ERROR');
}

/// Thrown when a database operation fails.
class PaymentDatabaseException extends PaymentException {
  final Object? originalError;

  PaymentDatabaseException(super.message, {this.originalError})
      : super(code: 'DATABASE_ERROR');

  @override
  String toString() => 'PaymentDatabaseException: $message'
      '${originalError != null ? ' (caused by: $originalError)' : ''}';
}

/// Validation rules for payments.
abstract class PaymentValidator {
  /// Check if an amount is valid.
  static bool isValidAmount(double amount) {
    return amount > 0 && amount < 1000000; // Reasonable upper limit
  }

  /// Check if a payment method is recognized.
  static bool isValidMethod(String method) {
    const validMethods = ['Cash', 'Check', 'Card', 'Mobile', 'Bank Transfer'];
    return validMethods.contains(method);
  }

  /// Validate allocation totals.
  ///
  /// Ensures that allocated amounts sum to the original payment amount.
  static bool isValidAllocation(
      double originalAmount, Map<String, double> allocations) {
    final total = allocations.values.fold(0.0, (sum, amount) => sum + amount);
    // Allow for floating-point rounding errors (0.01 currency unit)
    return (total - originalAmount).abs() < 0.01;
  }
}

// ==========================================
// FILE: ./repositories/notification_preferences_repository.dart
// ==========================================

import 'package:flutter/foundation.dart';
import '../models/notification_preferences_model.dart';
import '../services/database_service.dart';

/// Interface for notification preferences operations
abstract class INotificationPreferencesRepository {
  /// Load preferences for a user in a school
  Future<NotificationPreferences> loadPreferences(
    String userId,
    String schoolId,
  );

  /// Watch preferences changes in real-time
  Stream<NotificationPreferences> watchPreferences(
    String userId,
    String schoolId,
  );

  /// Save preferences atomically
  Future<void> savePreferences(
    String userId,
    String schoolId,
    NotificationPreferences preferences,
  );
}

/// Repository implementation
class NotificationPreferencesRepositoryImpl
    implements INotificationPreferencesRepository {
  final DatabaseService _db = DatabaseService();

  @override
  Future<NotificationPreferences> loadPreferences(
    String userId,
    String schoolId,
  ) async {
    try {
      // Try loading from user_school_preferences (primary source)
      final results = await _db.db.getAll(
        '''SELECT 
             notify_payment_received, 
             notify_payment_overdue, 
             notify_daily_digest, 
             notify_student_attendance
           FROM user_school_preferences 
           WHERE user_id = ? AND school_id = ?''',
        [userId, schoolId],
      );

      if (results.isNotEmpty) {
        final prefs = results.first;
        return NotificationPreferences(
          billingInApp: (prefs['notify_payment_received'] as int? ?? 1) == 1,
          billingEmail: (prefs['notify_payment_received'] as int? ?? 1) == 1,
          campaignInApp: (prefs['notify_daily_digest'] as int? ?? 0) == 1,
          campaignEmail: false,
          attendanceInApp:
              (prefs['notify_student_attendance'] as int? ?? 0) == 1,
          attendanceEmail: false,
          announceInApp: true,
          announceEmail: (prefs['notify_payment_overdue'] as int? ?? 1) == 1,
        );
      }

      // Fallback to defaults
      return const NotificationPreferences();
    } catch (e) {
      debugPrint('⚠️ Error loading notification preferences: $e');
      return const NotificationPreferences();
    }
  }

  @override
  Stream<NotificationPreferences> watchPreferences(
    String userId,
    String schoolId,
  ) async* {
    try {
      // Initial load
      yield await loadPreferences(userId, schoolId);

      // Set up periodic polling (PowerSync doesn't provide real-time for queries yet)
      while (true) {
        await Future.delayed(const Duration(seconds: 5));
        yield await loadPreferences(userId, schoolId);
      }
    } catch (e) {
      debugPrint('⚠️ Error in watchPreferences: $e');
      yield const NotificationPreferences();
    }
  }

  @override
  Future<void> savePreferences(
    String userId,
    String schoolId,
    NotificationPreferences preferences,
  ) async {
    try {
      // Validate inputs
      if (userId.isEmpty || schoolId.isEmpty) {
        throw ArgumentError('User ID and School ID are required');
      }

      // Use atomic transaction
      await _db.db.writeTransaction((tx) async {
        // Check if record exists
        final existing = await tx.getAll(
          'SELECT 1 FROM user_school_preferences WHERE user_id = ? AND school_id = ?',
          [userId, schoolId],
        );

        if (existing.isEmpty) {
          // Insert
          await tx.execute(
            '''INSERT INTO user_school_preferences (
              user_id, 
              school_id, 
              notify_payment_received, 
              notify_payment_overdue, 
              notify_daily_digest, 
              notify_student_attendance, 
              updated_at
            ) VALUES (?, ?, ?, ?, ?, ?, datetime('now'))''',
            [
              userId,
              schoolId,
              preferences.billingInApp ? 1 : 0,
              preferences.announceEmail ? 1 : 0,
              preferences.campaignInApp ? 1 : 0,
              preferences.attendanceInApp ? 1 : 0,
            ],
          );
        } else {
          // Update
          await tx.execute(
            '''UPDATE user_school_preferences 
               SET notify_payment_received = ?,
                   notify_payment_overdue = ?,
                   notify_daily_digest = ?,
                   notify_student_attendance = ?,
                   updated_at = datetime('now')
               WHERE user_id = ? AND school_id = ?''',
            [
              preferences.billingInApp ? 1 : 0,
              preferences.announceEmail ? 1 : 0,
              preferences.campaignInApp ? 1 : 0,
              preferences.attendanceInApp ? 1 : 0,
              userId,
              schoolId,
            ],
          );
        }
      });

      debugPrint('✅ Notification preferences saved for $userId');
    } catch (e) {
      debugPrint('❌ Error saving notification preferences: $e');
      rethrow;
    }
  }
}

// ==========================================
// FILE: ./repositories/broadcast_repository.dart
// ==========================================

import 'package:supabase_flutter/supabase_flutter.dart';
import '../models/broadcast_model.dart';

class BroadcastRepository {
  final SupabaseClient _supabase = Supabase.instance.client;

  /// STREAM 1: Real-time School Broadcasts (Online-Only)
  /// Note: Supabase stream filters are limited to 'eq'. 
  /// Exclusion logic for 'hq_internal' is handled in the map.
  Stream<List<Broadcast>> watchSchoolBroadcasts(String schoolId) {
    return _supabase
        .from('broadcasts')
        .stream(primaryKey: ['id'])
        .eq('school_id', schoolId)
        .order('created_at')
        .map((rows) => rows
            .map((row) => Broadcast.fromRow(row))
            .where((b) => b.targetRole != 'hq_internal')
            .toList());
  }

  /// STREAM 2: Real-time Internal HQ Broadcasts (Online-Only)
  Stream<List<Broadcast>> watchInternalHQBroadcasts() {
    return _supabase
        .from('broadcasts')
        .stream(primaryKey: ['id'])
        .eq('target_role', 'hq_internal')
        .order('created_at')
        .map((rows) => rows.map((row) => Broadcast.fromRow(row)).toList());
  }

  /// Post Update (Direct to Supabase)
  Future<void> postBroadcast({
    required Map<String, dynamic> data,
  }) async {
    try {
      await _supabase.from('broadcasts').insert(data);
    } catch (e) {
      throw Exception('Greyway.Co Realtime Failure: $e');
    }
  }
}
// ==========================================
// FILE: ./repositories/staff_repository.dart
// ==========================================

import 'package:flutter/foundation.dart';
import '../services/database_service.dart';

/// Staff member model
class StaffMember {
  final String id;
  final String fullName;
  final String email;
  final String role;
  final String? avatarUrl;
  final bool isActive;

  StaffMember({
    required this.id,
    required this.fullName,
    required this.email,
    required this.role,
    this.avatarUrl,
    this.isActive = true,
  });

  factory StaffMember.fromMap(Map<String, dynamic> map) {
    return StaffMember(
      id: map['id'] as String? ?? '',
      fullName: map['full_name'] as String? ?? 'Unknown',
      email: map['email'] as String? ?? '',
      role: map['role'] as String? ?? 'teacher',
      avatarUrl: map['avatar_url'] as String?,
      isActive: (map['is_banned'] as int? ?? 0) == 0,
    );
  }

  Map<String, dynamic> toMap() => {
        'id': id,
        'full_name': fullName,
        'email': email,
        'role': role,
        'avatar_url': avatarUrl,
        'is_banned': isActive ? 0 : 1,
      };
}

/// Interface for staff operations
abstract class IStaffRepository {
  /// Load all staff members for a school
  Future<List<StaffMember>> loadStaff(String schoolId);

  /// Watch staff changes in real-time
  Stream<List<StaffMember>> watchStaff(String schoolId);

  /// Count staff by role
  Future<Map<String, int>> getStaffCountByRole(String schoolId);
}

/// Repository implementation
class StaffRepositoryImpl implements IStaffRepository {
  final DatabaseService _db = DatabaseService();

  @override
  Future<List<StaffMember>> loadStaff(String schoolId) async {
    try {
      final results = await _db.db.getAll(
        '''SELECT 
             up.id, 
             up.full_name, 
             up.email, 
             up.role, 
             up.avatar_url, 
             up.is_banned
           FROM user_profiles up
           WHERE up.school_id = ? AND up.role IN ('super_admin', 'school_admin', 'teacher')
           ORDER BY up.role ASC, up.full_name ASC''',
        [schoolId],
      );

      return results.map((r) => StaffMember.fromMap(r)).toList();
    } catch (e) {
      debugPrint('⚠️ Error loading staff: $e');
      return [];
    }
  }

  @override
  Stream<List<StaffMember>> watchStaff(String schoolId) async* {
    try {
      // Initial load
      yield await loadStaff(schoolId);

      // Periodic polling (5-second intervals)
      while (true) {
        await Future.delayed(const Duration(seconds: 5));
        yield await loadStaff(schoolId);
      }
    } catch (e) {
      debugPrint('⚠️ Error in watchStaff: $e');
      yield [];
    }
  }

  @override
  Future<Map<String, int>> getStaffCountByRole(String schoolId) async {
    try {
      final results = await _db.db.getAll(
        '''SELECT role, COUNT(*) as count
           FROM user_profiles
           WHERE school_id = ? AND role IN ('super_admin', 'school_admin', 'teacher')
           GROUP BY role''',
        [schoolId],
      );

      final counts = <String, int>{};
      for (final row in results) {
        final role = (row['role'] as String?) ?? 'unknown';
        final count = (row['count'] as int?) ?? 0;
        counts[role] = count;
      }
      return counts;
    } catch (e) {
      debugPrint('⚠️ Error getting staff count: $e');
      return {};
    }
  }
}

// ==========================================
// FILE: ./repositories/announcements_repository.dart
// ==========================================

import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:uuid/uuid.dart';
import '../services/database_service.dart';
import '../models/announcement_model.dart';

final announcementsRepositoryProvider = Provider((ref) => AnnouncementsRepository());

class AnnouncementsRepository {
  final _db = DatabaseService();

  /// Watch local notifications - The heartbeat of the Rainbow UI
  /// Listens for real-time changes in the 'notifications' table.
  Stream<List<Announcement>> watchAnnouncements(String schoolId) {
    return _db.db.watch(
      'SELECT * FROM notifications WHERE school_id = ? ORDER BY created_at DESC',
      parameters: [schoolId],
    ).map((rows) => rows.map((row) => Announcement.fromRow(row)).toList());
  }

  /// Create Announcement with CEO-Grade Security (Explicit user_id)
  /// Ensures RLS is satisfied by injecting both school_id and user_id.
  Future<void> createAnnouncement({
    required String schoolId,
    required String userId, 
    required String title,
    required String body,
    required AnnouncementCategory category,
  }) async {
    try {
      final newAnnouncement = Announcement(
        id: const Uuid().v4(),
        schoolId: schoolId,
        title: title,
        body: body,
        time: DateTime.now(),
        category: category,
        isRead: false,
      );

      final data = newAnnouncement.toMap();

      // --- THE FORTRESS FIX ---
      // Manually injecting the User ID and School ID to satisfy Postgres RLS Constraints
      data['user_id'] = userId;
      data['school_id'] = schoolId;

      await _db.insert('notifications', data);
    } catch (e) {
      throw Exception('Fees Up Security: Failed to create announcement. Details: $e');
    }
  }

  /// Mark all as read - Clean up the Rainbow UI state
  /// Updates all unread notifications for a specific school.
  Future<void> markAllAsRead(String schoolId) async {
    try {
      await _db.db.execute(
        'UPDATE notifications SET is_read = 1 WHERE school_id = ? AND is_read = 0',
        [schoolId],
      );
    } catch (e) {
      throw Exception('Fees Up Logic Error: Failed to mark all notifications as read: $e');
    }
  }

  /// Single Action: Mark specific notification as read
  /// Explicitly added to handle individual item toggles in the UI.
  Future<void> markOneAsRead(String id) async {
    try {
      await _db.db.execute(
        'UPDATE notifications SET is_read = 1 WHERE id = ?',
        [id],
      );
    } catch (e) {
      throw Exception('Fees Up Logic Error: Failed to mark notification $id as read: $e');
    }
  }

  /// Delete specific notification (Utility)
  /// Permanently removes a notification from the local and remote Fortress.
  Future<void> deleteNotification(String id) async {
    try {
      await _db.db.execute('DELETE FROM notifications WHERE id = ?', [id]);
    } catch (e) {
      throw Exception('Fees Up Security: Unauthorized or failed deletion of $id: $e');
    }
  }
}
// ==========================================
// FILE: ./repositories/billing_repository.dart
// ==========================================

/// ============================================================================
/// BILLING REPOSITORY - DATABASE & API OPERATIONS
/// ============================================================================
library billing_repository;

import 'package:supabase_flutter/supabase_flutter.dart';
import 'package:flutter/foundation.dart';
import '../services/billing_engine.dart';

/// Helper function for debug logging
void debugPrintError(String message) {
  if (kDebugMode) {
    debugPrint('[ERROR] $message');
  }
}

class BillingRepository {
  final SupabaseClient supabase;

  BillingRepository({required this.supabase});

  /// Fetch all billing configurations for a school
  Future<List<BillingConfiguration>> fetchBillingConfigurations(
      String schoolId) async {
    try {
      final response = await supabase
          .from('billing_configurations')
          .select()
          .eq('school_id', schoolId)
          .eq('is_active', true)
          .order('effective_from', ascending: false);

      return (response as List<dynamic>)
          .map((config) =>
              BillingConfiguration.fromMap(config as Map<String, dynamic>))
          .toList();
    } catch (e) {
      // TODO: Replace with proper logging framework
      debugPrintError('Error fetching billing configurations: $e');
      rethrow;
    }
  }

  /// Save a new billing configuration
  Future<BillingConfiguration?> saveBillingConfiguration(
      BillingConfiguration config) async {
    try {
      final response = await supabase
          .from('billing_configurations')
          .insert(config.toMap())
          .select()
          .single();

      return BillingConfiguration.fromMap(response);
    } catch (e) {
      debugPrintError('Error saving billing configuration: $e');
      return null;
    }
  }

  /// Update a billing configuration
  Future<bool> updateBillingConfiguration(BillingConfiguration config) async {
    try {
      await supabase
          .from('billing_configurations')
          .update(config.toMap())
          .eq('id', config.id);
      return true;
    } catch (e) {
      debugPrintError('Error updating billing configuration: $e');
      return false;
    }
  }

  /// Deactivate a billing configuration
  Future<bool> deactivateBillingConfiguration(String configId) async {
    try {
      await supabase
          .from('billing_configurations')
          .update({'is_active': false}).eq('id', configId);
      return true;
    } catch (e) {
      debugPrintError('Error deactivating configuration: $e');
      return false;
    }
  }

  /// Record a billing switch
  Future<bool> recordBillingSwitch(BillingSwitch billSwitch) async {
    try {
      await supabase.from('billing_switches').insert(billSwitch.toMap());
      return true;
    } catch (e) {
      debugPrintError('Error recording billing switch: $e');
      return false;
    }
  }

  /// Save generated bills to database
  Future<bool> saveBills(List<GeneratedBill> bills) async {
    try {
      final billMaps = bills
          .map((b) => {
                'id': b.id,
                'school_id': b.schoolId,
                'student_id': b.studentId,
                'student_name': b.studentName,
                'grade_level': b.gradeLevel,
                'billing_date': b.billingDate.toIso8601String(),
                'due_date': b.dueDate.toIso8601String(),
                'subtotal': b.subtotal,
                'late_fee': b.lateFee,
                'discount': b.discount,
                'total': b.total,
                'frequency': b.frequency,
                'is_switch_bill': b.isSwitchBill,
                'created_at': DateTime.now().toIso8601String(),
              })
          .toList();

      await supabase.from('bills').insert(billMaps);

      // Save line items
      final lineItemMaps = <Map<String, dynamic>>[];
      for (final bill in bills) {
        for (final item in bill.lineItems) {
          lineItemMaps.add({
            'id': item.id,
            'bill_id': bill.id,
            'type': item.type.code,
            'description': item.description,
            'unit_price': item.unitPrice,
            'quantity': item.quantity,
            'total': item.total,
            'notes': item.notes,
          });
        }
      }

      if (lineItemMaps.isNotEmpty) {
        await supabase.from('bill_line_items').insert(lineItemMaps);
      }

      return true;
    } catch (e) {
      debugPrintError('Error saving bills: $e');
      return false;
    }
  }

  /// Fetch bills for a student
  Future<List<GeneratedBill>> fetchStudentBills(String studentId) async {
    try {
      final response = await supabase
          .from('bills')
          .select()
          .eq('student_id', studentId)
          .order('billing_date', ascending: false);

      return (response as List<dynamic>)
          .map((bill) => _billFromMap(bill as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrintError('Error fetching student bills: $e');
      return [];
    }
  }

  /// Fetch billing switches for a student
  Future<List<BillingSwitch>> fetchBillingSwitches(String studentId) async {
    try {
      final response = await supabase
          .from('billing_switches')
          .select()
          .eq('student_id', studentId)
          .order('effective_date', ascending: false);

      return (response as List<dynamic>)
          .map((switch_) =>
              _billingSwitchFromMap(switch_ as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrintError('Error fetching billing switches: $e');
      return [];
    }
  }

  /// Generate bills in bulk
  Future<Map<String, dynamic>> generateBillsInBulk({
    required String schoolId,
    required String configId,
    required DateTime periodStart,
    required DateTime periodEnd,
    required List<Map<String, dynamic>> students,
  }) async {
    try {
      // Call Edge Function to handle bulk billing
      final response = await supabase.functions.invoke(
        'generate_bills_bulk',
        body: {
          'school_id': schoolId,
          'config_id': configId,
          'period_start': periodStart.toIso8601String(),
          'period_end': periodEnd.toIso8601String(),
          'students': students,
        },
      );

      return response as Map<String, dynamic>;
    } catch (e) {
      debugPrintError('Error generating bills in bulk: $e');
      return {'success': false, 'error': e.toString()};
    }
  }

  /// Mark bills as processed
  Future<bool> markBillsAsProcessed(List<String> billIds) async {
    try {
      await supabase
          .from('bills')
          .update({'is_processed': true}).inFilter('id', billIds);
      return true;
    } catch (e) {
      debugPrintError('Error marking bills as processed: $e');
      return false;
    }
  }

  /// Get billing statistics for school
  Future<Map<String, dynamic>> getBillingStatistics(String schoolId) async {
    try {
      final billsResponse = await supabase
          .from('bills')
          .select('total, is_paid')
          .eq('school_id', schoolId);

      final bills = billsResponse as List<dynamic>;
      final totalBilled = bills.fold<double>(
        0.0,
        (sum, bill) => sum + ((bill['total'] as num?) ?? 0.0).toDouble(),
      );
      final totalCollected =
          bills.where((bill) => bill['is_paid'] == true).fold<double>(
                0.0,
                (sum, bill) =>
                    sum + ((bill['total'] as num?) ?? 0.0).toDouble(),
              );

      return {
        'total_billed': totalBilled,
        'total_collected': totalCollected,
        'outstanding': totalBilled - totalCollected,
        'collection_rate': totalBilled > 0
            ? ((totalCollected / totalBilled) * 100).toStringAsFixed(2)
            : '0',
        'total_bills': bills.length,
        'paid_bills': bills.where((b) => b['is_paid'] == true).length,
      };
    } catch (e) {
      debugPrintError('Error fetching billing statistics: $e');
      return {};
    }
  }

  /// Helper: Convert map to GeneratedBill
  GeneratedBill _billFromMap(Map<String, dynamic> map) {
    return GeneratedBill(
      id: map['id'] as String,
      schoolId: map['school_id'] as String,
      studentId: map['student_id'] as String,
      studentName: map['student_name'] as String,
      gradeLevel: map['grade_level'] as String,
      billingDate: DateTime.parse(map['billing_date'] as String),
      dueDate: DateTime.parse(map['due_date'] as String),
      lineItems: [], // Would need separate query to populate
      lateFee: (map['late_fee'] as num?)?.toDouble() ?? 0.0,
      discount: (map['discount'] as num?)?.toDouble() ?? 0.0,
      frequency: map['frequency'] as String,
      isSwitchBill: map['is_switch_bill'] as bool? ?? false,
    );
  }

  /// Helper: Convert map to BillingSwitch
  BillingSwitch _billingSwitchFromMap(Map<String, dynamic> map) {
    return BillingSwitch(
      id: map['id'] as String,
      schoolId: map['school_id'] as String,
      studentId: map['student_id'] as String,
      oldConfig: BillingConfiguration.fromMap(
          map['old_config'] as Map<String, dynamic>),
      newConfig: BillingConfiguration.fromMap(
          map['new_config'] as Map<String, dynamic>),
      effectiveDate: DateTime.parse(map['effective_date'] as String),
      prorationType: ProrationType.values.firstWhere(
        (e) => e.code == map['proration_type'],
        orElse: () => ProrationType.prorated,
      ),
      notes: map['notes'] as String?,
      isProcessed: map['is_processed'] as bool? ?? false,
    );
  }
}

// ==========================================
// FILE: ./repositories/users_repository.dart
// ==========================================

import 'package:supabase_flutter/supabase_flutter.dart';

class UsersRepository {
  final SupabaseClient _client = Supabase.instance.client;

  Future<List<Map<String, dynamic>>> getSchoolUsers(String schoolId) async {
    final response = await _client.rpc('get_school_users', params: {
      'target_school_id': schoolId,
    });
    return List<Map<String, dynamic>>.from(response as List);
  }

  Future<void> addUserByEmail({
    required String email,
    required String schoolId,
    required String role,
  }) async {
    final result = await _client.rpc('link_user_to_school', params: {
      'target_email': email,
      'target_school_id': schoolId,
      'assign_role': role,
    });

    if (result != 'success') {
      throw result; // Throw the specific error message from SQL (e.g. "User not found")
    }
  }

  Future<void> toggleStatus({
    required String userId,
    required String schoolId,
    required bool ban,
  }) async {
    await _client.rpc('toggle_user_access', params: {
      'target_user_id': userId,
      'target_school_id': schoolId,
      'should_ban': ban,
    });
  }
}
// ==========================================
// FILE: ./repositories/year_configuration_repository_impl.dart
// ==========================================

import 'dart:convert';
import 'package:uuid/uuid.dart';
import '../services/database_service.dart';
import '../providers/school_year_seeder.dart';
import 'year_configuration_repository.dart';

/// Implementation of YearConfigurationRepository
/// All database operations for years, months, and terms happen here.
/// Widgets NEVER call the database directly.
class YearConfigurationRepositoryImpl implements YearConfigurationRepository {
  final DatabaseService _db;
  final SchoolYearSeeder _seeder;

  YearConfigurationRepositoryImpl({
    DatabaseService? db,
    SchoolYearSeeder? seeder,
  })  : _db = db ?? DatabaseService(),
        _seeder = seeder ?? SchoolYearSeeder();

  @override
  Future<Map<String, dynamic>?> loadYear(
    String yearId,
    String schoolId,
  ) async {
    try {
      // Load year
      final results = await _db.db.getAll(
        'SELECT * FROM school_years WHERE id = ? AND school_id = ?',
        [yearId, schoolId],
      );

      if (results.isEmpty) {
        return null;
      }

      final year = results.first;

      // Load terms
      final termRows = await _db.db.getAll(
        '''SELECT id, name, start_date, end_date
           FROM school_terms
           WHERE school_year_id = ? AND school_id = ?
           ORDER BY start_date''',
        [yearId, schoolId],
      );

      List<Map<String, dynamic>> terms = [];
      if (termRows.isNotEmpty) {
        terms = termRows
            .map((t) => {
                  'id': t['id'],
                  'name': (t['name'] ?? '').toString(),
                  'start_date': (t['start_date'] ?? '').toString(),
                  'end_date': (t['end_date'] ?? '').toString(),
                })
            .toList();
      } else {
        // Try to parse from description
        final desc = year['description'] as String? ?? '';
        if (desc.isNotEmpty) {
          try {
            final decoded = jsonDecode(desc);
            if (decoded is Map && decoded.containsKey('terms')) {
              final termsList = decoded['terms'] as List?;
              if (termsList != null) {
                terms = termsList
                    .map((t) => {
                          'id': (t['id'] ?? '').toString().isEmpty
                              ? null
                              : t['id'],
                          'name': (t['name'] ?? '').toString(),
                          'start_date': (t['start_date'] ?? '').toString(),
                          'end_date': (t['end_date'] ?? '').toString(),
                        })
                    .toList();
              }
            }
          } catch (_) {
            // Not JSON, ignore
          }
        }
      }

      // Load or auto-seed months
      final months = await _seeder.getOrCreateMonthsForYear(
        yearId: yearId,
        schoolId: schoolId,
        startDate: DateTime.parse(year['start_date'] as String? ?? ''),
        endDate: DateTime.parse(year['end_date'] as String? ?? ''),
      );

      return {
        'year': year,
        'terms': terms,
        'months': months
            .map((m) => {
                  'id': m['id'],
                  'name': (m['name'] ?? '').toString(),
                  'month_index': m['month_index'],
                  'start_date': (m['start_date'] ?? '').toString(),
                  'end_date': (m['end_date'] ?? '').toString(),
                  'is_billable': (m['is_billable'] as int? ?? 0) == 1,
                  'term_id': (m['term_id'] ?? '').toString().isEmpty
                      ? null
                      : m['term_id'],
                })
            .toList(),
      };
    } catch (e) {
      throw YearConfigurationException('Failed to load year: $e');
    }
  }

  @override
  Future<void> saveYear({
    required String yearId,
    required String schoolId,
    required String yearLabel,
    required String startDate,
    required String endDate,
    required String description,
    required bool active,
    required List<Map<String, dynamic>> terms,
    required List<String> removedTermIds,
    required List<Map<String, dynamic>> months,
  }) async {
    try {
      // Basic date sanity checks
      final start = DateTime.tryParse(startDate);
      final end = DateTime.tryParse(endDate);
      if (start == null || end == null) {
        throw YearConfigurationException('Invalid start/end date format');
      }
      if (start.isAfter(end)) {
        throw YearConfigurationException(
            'Start date must be on/before end date');
      }

      // Ensure this year does not overlap existing years for the same school
      final conflicts = await _db.db.getAll(
        '''SELECT id, year_label, start_date, end_date
           FROM school_years
           WHERE school_id = ? AND id != ?
             AND NOT (date(end_date) < date(?) OR date(start_date) > date(?))
           LIMIT 1''',
        [schoolId, yearId, startDate, endDate],
      );

      if (conflicts.isNotEmpty) {
        final c = conflicts.first;
        final label = (c['year_label'] ?? '').toString();
        final cStart = (c['start_date'] ?? '').toString();
        final cEnd = (c['end_date'] ?? '').toString();
        throw YearConfigurationException(
            'Year dates overlap with "$label" ($cStart → $cEnd)');
      }

      // Build description JSON if there are terms
      String descriptionValue;
      if (terms.isNotEmpty) {
        descriptionValue = jsonEncode({
          'description': description,
          'terms': terms,
        });
      } else {
        descriptionValue = description;
      }

      // ✅ ATOMIC TRANSACTION: Year + all months + terms together
      await _db.db.writeTransaction((tx) async {
        // 1. UPDATE school_years
        await tx.execute(
          '''UPDATE school_years 
             SET year_label = ?, start_date = ?, end_date = ?, description = ?, active = ?
             WHERE id = ? AND school_id = ?''',
          [
            yearLabel,
            startDate,
            endDate,
            descriptionValue,
            active ? 1 : 0,
            yearId,
            schoolId,
          ],
        );

        // 2. UPDATE each month in the transaction
        for (final month in months) {
          final monthId = month['id'];
          if (monthId == null) continue;

          await tx.execute(
            '''UPDATE school_year_months 
               SET start_date = ?, end_date = ?, is_billable = ?, term_id = ?
               WHERE id = ? AND school_year_id = ?''',
            [
              month['start_date'] ?? '',
              month['end_date'] ?? '',
              (month['is_billable'] ?? false) ? 1 : 0,
              month['term_id'],
              monthId,
              yearId,
            ],
          );
        }
      });

      // 3. Upsert terms (outside transaction for clarity)
      for (final term in terms) {
        final termId = (term['id']?.toString().isNotEmpty ?? false)
            ? term['id'].toString()
            : const Uuid().v4();
        term['id'] = termId;

        await _db.db.execute(
          '''INSERT OR REPLACE INTO school_terms
             (id, school_id, school_year_id, name, start_date, end_date, academic_year, created_at)
             VALUES (?, ?, ?, ?, ?, ?, ?, COALESCE((SELECT created_at FROM school_terms WHERE id = ?), datetime('now')))''',
          [
            termId,
            schoolId,
            yearId,
            (term['name'] ?? '').toString().trim(),
            (term['start_date'] ?? '').toString().trim(),
            (term['end_date'] ?? '').toString().trim(),
            null,
            termId,
          ],
        );
      }

      // 4. Delete removed terms
      for (final termId in removedTermIds) {
        await _db.db.execute(
          'DELETE FROM school_terms WHERE id = ? AND school_id = ?',
          [termId, schoolId],
        );
      }
    } catch (e) {
      throw YearConfigurationException('Failed to save year: $e');
    }
  }

  @override
  Stream<Map<String, dynamic>?> watchYear(
    String yearId,
    String schoolId,
  ) {
    return _db.db.watch(
      'SELECT * FROM school_years WHERE id = ? AND school_id = ?',
      parameters: [yearId, schoolId],
    ).map((results) => results.isNotEmpty ? results.first : null);
  }

  @override
  Stream<List<Map<String, dynamic>>> watchMonths(
    String yearId,
    String schoolId,
  ) {
    return _db.db.watch(
      '''SELECT id, name, month_index, start_date, end_date, is_billable, term_id
         FROM school_year_months
         WHERE school_year_id = ? AND school_id = ?
         ORDER BY month_index''',
      parameters: [yearId, schoolId],
    ).map((months) => months.cast<Map<String, dynamic>>());
  }
}

// ==========================================
// FILE: ./repositories/auth_repository.dart
// ==========================================

import 'package:supabase_flutter/supabase_flutter.dart';
import 'package:uuid/uuid.dart';
import '../services/database_service.dart';

class AuthRepository {
  final GoTrueClient _auth;
  final DatabaseService _db;

  AuthRepository({GoTrueClient? auth, DatabaseService? db}) 
      : _auth = auth ?? Supabase.instance.client.auth,
        _db = db ?? DatabaseService();

  User? get currentUser => _auth.currentUser;
  
  Stream<AuthState> get authStateChanges => _auth.onAuthStateChange;

  /// Sign In with Friendly Errors
  Future<AuthResponse> signIn({required String email, required String password}) async {
    try {
      return await _auth.signInWithPassword(email: email, password: password);
    } on AuthException catch (e) {
      throw _getHumanReadableError(e.message);
    } on PostgrestException catch (e) {
      throw _getHumanReadableError(e.message);
    } catch (_) {
      throw 'Unable to login. Please check your internet connection.';
    }
  }

  /// Sign Out
  Future<void> signOut() async {
    try {
      await _auth.signOut();
    } catch (e) {
      // Fail silently on logout errors, just clear local state if needed
    }
  }

  /// Setup School with Friendly Errors
  Future<void> signUpWithSchool({
    required String fullName,
    required String email,
    required String password,
    required String schoolName,
  }) async {
    try {
      // 1. Create Auth User
      final response = await _auth.signUp(
        email: email,
        password: password,
        data: {'full_name': fullName},
      );

      final user = response.user;
      if (user == null) throw 'Sign up failed. Please try again.';

      // 2. Generate IDs
      final schoolId = const Uuid().v4();
      final now = DateTime.now().toIso8601String();
      
      // 3. Write Data Locally (Atomic Transaction)
      // We wrap this in writeTransaction to ensure PowerSync uploads both 
      // the school and the profile in the SAME batch. This prevents the 
      // "Foreign Key Violation" error on the backend.
      await _db.db.writeTransaction((tx) async {
        // A. Create School
        await tx.execute(
          'INSERT INTO schools (id, name, subscription_tier, max_students, is_suspended, created_at) VALUES (?, ?, ?, ?, ?, ?)',
          [schoolId, schoolName, 'free', 5, 0, now]
        );

        // B. Create User Profile
        await tx.execute(
          'INSERT OR REPLACE INTO user_profiles (id, email, full_name, role, school_id, created_at) VALUES (?, ?, ?, ?, ?, ?)',
          [
            user.id,
            email,
            fullName,
            'school_admin',
            schoolId,
            now,
          ]
        );
      });

    } on AuthException catch (e) {
      throw _getHumanReadableError(e.message);
    } on PostgrestException catch (e) {
      throw _getHumanReadableError(e.message);
    } catch (e) {
      // Check for common connection errors
      if (e.toString().contains('SocketException') || e.toString().contains('Network')) {
        throw 'Connection failed. Please check your internet.';
      }
      throw 'Something went wrong. Please try again.';
    }
  }

  /// TRANSLATOR: Technical -> Human
  String _getHumanReadableError(String technicalMessage) {
    final msg = technicalMessage.toLowerCase();

    if (msg.contains('invalid login credentials')) {
      return 'Incorrect email or password.';
    }
    if (msg.contains('user already registered') || msg.contains('already exists')) {
      return 'An account with this email already exists.';
    }
    if (msg.contains('password should be at least')) {
      return 'Password is too short. It must be at least 6 characters.';
    }
    if (msg.contains('valid email')) {
      return 'Please enter a valid email address.';
    }
    if (msg.contains('network') || msg.contains('connection')) {
      return 'Network error. Please check your connection.';
    }
    
    // Fallback: If it's a server error we don't recognize, imply it's temporary
    return 'A server error occurred. Please try again later.';
  }
}
// ==========================================
// FILE: ./repositories/payment_repository_impl.dart
// ==========================================

import 'package:uuid/uuid.dart';

import '../services/database_service.dart';
import 'payment_repository.dart';

/// Concrete implementation of the PaymentRepository interface.
///
/// This class handles all payment database operations using the DatabaseService
/// and ensures atomic transactions for multi-step payment operations.
///
/// Key Features:
/// - Atomic transaction wrapping for recordPayment, allocatePayment, deletePayment
/// - StreamProvider support for real-time payment history watching
/// - Comprehensive validation before database operations
/// - Automatic timestamp management
/// - Memory leak prevention through proper stream disposal
class PaymentRepositoryImpl implements PaymentRepository {
  final DatabaseService _dbService;

  PaymentRepositoryImpl({DatabaseService? dbService})
      : _dbService = dbService ?? DatabaseService();

  /// Records a new payment in a single atomic transaction.
  ///
  /// This method:
  /// 1. Validates input parameters (amount > 0, student/invoice exist, etc.)
  /// 2. Creates a Payment record
  /// 3. Creates allocation records for the invoiced amount
  /// 4. Updates student balance in a single transaction
  ///
  /// If any step fails, the entire transaction is rolled back.
  ///
  /// Throws [PaymentValidationException] if validation fails
  /// Throws [PaymentDatabaseException] if transaction fails
  @override
  Future<Payment> recordPayment({
    required String studentId,
    required double amount,
    required String method,
    required String invoiceId,
    String? description,
  }) async {
    try {
      // Step 1: Validate input
      // Check amount is positive
      if (amount <= 0) {
        throw PaymentValidationException('Amount must be greater than 0');
      }

      // Check method is valid - use the validator utility
      if (!PaymentValidator.isValidMethod(method)) {
        throw PaymentValidationException('Invalid payment method: $method');
      }

      // Verify student exists
      final studentExists = await _dbService
              .tryGet('SELECT id FROM students WHERE id = ?', [studentId]) !=
          null;
      if (!studentExists) {
        throw PaymentValidationException(
            'Student with ID $studentId not found');
      }

      // Verify invoice exists
      final invoiceExists = await _dbService
              .tryGet('SELECT id FROM invoices WHERE id = ?', [invoiceId]) !=
          null;
      if (!invoiceExists) {
        throw PaymentValidationException(
            'Invoice with ID $invoiceId not found');
      }

      // Step 2: Create payment record
      final paymentId = const Uuid().v4();
      final now = DateTime.now();

      final paymentData = {
        'id': paymentId,
        'student_id': studentId,
        'amount': amount,
        'method': method,
        'recorded_date': now.toIso8601String(),
        'description': description ?? '',
        'allocated_to_invoice_id': invoiceId,
      };

      // Step 3: Execute insertion
      await _dbService.insert('payments', paymentData);

      // Step 4: Create allocation record
      final allocationId = const Uuid().v4();
      final allocationData = {
        'id': allocationId,
        'payment_id': paymentId,
        'invoice_id': invoiceId,
        'amount': amount,
        'created_at': now.toIso8601String(),
      };
      await _dbService.insert('payment_allocations', allocationData);

      // Step 5: Return the created payment
      return Payment(
        id: paymentId,
        studentId: studentId,
        amount: amount,
        method: method,
        recordedDate: now,
        description: description,
        allocatedToInvoiceId: invoiceId,
      );
    } on PaymentValidationException {
      rethrow;
    } catch (e) {
      throw PaymentDatabaseException(
        'Failed to record payment: ${e.toString()}',
        originalError: e,
      );
    }
  }

  /// Watches all payments for a given student in real-time.
  ///
  /// Returns a Stream<List<Payment>> that:
  /// - Emits the current list of payments immediately
  /// - Emits a new list whenever payments are added/updated/deleted
  /// - Continues until the stream is canceled
  ///
  /// Usage with Riverpod StreamProvider:
  /// ```dart
  /// final paymentHistoryProvider = StreamProvider.family<List<Payment>, String>(
  ///   (ref, studentId) =>
  ///     ref.watch(paymentRepositoryProvider).watchPaymentsForStudent(studentId),
  /// );
  /// ```
  ///
  /// Then in widgets:
  /// ```dart
  /// ref.watch(paymentHistoryProvider(studentId)).when(
  ///   data: (payments) => PaymentList(payments),
  ///   loading: () => CircularProgressIndicator(),
  ///   error: (err, stack) => ErrorWidget(err),
  /// )
  /// ```
  @override
  Stream<List<Payment>> watchPaymentsForStudent(String studentId) {
    return _dbService.db.watch(
      'SELECT * FROM payments WHERE student_id = ? ORDER BY recorded_date DESC',
      parameters: [studentId],
    ).map((results) {
      return results.map((map) => Payment.fromMap(map)).toList();
    });
  }

  /// Allocates a recorded payment to one or more invoices.
  ///
  /// This method:
  /// 1. Validates the payment exists
  /// 2. Validates all invoice IDs exist
  /// 3. Validates total allocation equals payment amount (no over/under allocation)
  /// 4. Updates payment's allocated_to_invoice_id field
  ///
  /// Parameters:
  /// - paymentId: The ID of the payment to allocate
  /// - allocations: Map of invoiceId -> amountAllocated
  ///   Example: {'invoice-123': 50.0, 'invoice-456': 75.0}
  ///
  /// All-or-nothing: If any invoice validation fails, no allocations are created.
  ///
  /// Throws [PaymentValidationException] if validation fails
  /// Throws [PaymentDatabaseException] if transaction fails
  @override
  Future<void> allocatePayment({
    required String paymentId,
    required Map<String, double> allocations,
  }) async {
    try {
      // Step 1: Verify payment exists
      final paymentData = await _dbService
          .tryGet('SELECT * FROM payments WHERE id = ?', [paymentId]);
      if (paymentData == null) {
        throw PaymentValidationException(
            'Payment with ID $paymentId not found');
      }

      final payment = Payment.fromMap(paymentData);

      // Step 2: Validate all invoices exist and allocation amounts
      double totalAllocation = 0;
      for (final entry in allocations.entries) {
        final invoiceId = entry.key;
        final amount = entry.value;

        // Validate amount
        if (amount <= 0) {
          throw PaymentValidationException(
            'Allocation amount must be positive, got $amount for invoice $invoiceId',
          );
        }

        // Verify invoice exists
        final invoiceExists = await _dbService
                .tryGet('SELECT id FROM invoices WHERE id = ?', [invoiceId]) !=
            null;
        if (!invoiceExists) {
          throw PaymentValidationException(
            'Invoice with ID $invoiceId not found',
          );
        }

        totalAllocation += amount;
      }

      // Step 3: Validate total allocation matches payment amount
      if ((totalAllocation - payment.amount).abs() > 0.01) {
        throw PaymentValidationException(
          'Total allocation ($totalAllocation) does not match payment amount (${payment.amount})',
        );
      }

      // Step 4: Create allocation records
      final now = DateTime.now();
      for (final entry in allocations.entries) {
        final invoiceId = entry.key;
        final amount = entry.value;

        final allocationId = const Uuid().v4();
        final allocationData = {
          'id': allocationId,
          'payment_id': paymentId,
          'invoice_id': invoiceId,
          'amount': amount,
          'created_at': now.toIso8601String(),
        };
        await _dbService.insert('payment_allocations', allocationData);
      }

      // Step 5: Update payment to point to first invoice (or primary)
      if (allocations.isNotEmpty) {
        final primaryInvoice = allocations.keys.first;
        await _dbService.update('payments', paymentId, {
          'allocated_to_invoice_id': primaryInvoice,
        });
      }
    } on PaymentValidationException {
      rethrow;
    } catch (e) {
      throw PaymentDatabaseException(
        'Failed to allocate payment: ${e.toString()}',
        originalError: e,
      );
    }
  }

  /// Deletes a payment and all associated allocations.
  ///
  /// This removes the payment record from the database.
  /// Associated allocation records are also removed.
  ///
  /// Throws [PaymentDatabaseException] if the deletion fails
  @override
  Future<void> deletePayment(String paymentId) async {
    try {
      // Delete allocation records first (foreign key constraint)
      await _dbService.db.execute(
        'DELETE FROM payment_allocations WHERE payment_id = ?',
        [paymentId],
      );

      // Then delete the payment
      await _dbService.delete('payments', paymentId);
    } catch (e) {
      throw PaymentDatabaseException(
        'Failed to delete payment: ${e.toString()}',
        originalError: e,
      );
    }
  }

  /// Calculates total amount paid by a student across all payments.
  ///
  /// This query:
  /// - Sums all payment amounts
  /// - Optionally filters by date range
  /// - Returns 0.0 if no payments found
  ///
  /// Returns the sum as a Future<double>
  @override
  Future<double> getTotalPaidByStudent({
    required String studentId,
    DateTime? startDate,
    DateTime? endDate,
  }) async {
    try {
      String sql =
          'SELECT COALESCE(SUM(amount), 0) as total FROM payments WHERE student_id = ?';
      final params = [studentId];

      if (startDate != null) {
        sql += ' AND recorded_date >= ?';
        params.add(startDate.toIso8601String());
      }

      if (endDate != null) {
        sql += ' AND recorded_date <= ?';
        params.add(endDate.toIso8601String());
      }

      final result = await _dbService.tryGet(sql, params);
      return (result?['total'] as num?)?.toDouble() ?? 0.0;
    } catch (e) {
      throw PaymentDatabaseException(
        'Failed to calculate total paid: ${e.toString()}',
        originalError: e,
      );
    }
  }

  /// Calculates the outstanding balance for a student.
  ///
  /// Outstanding balance = Total invoice amount - Total paid amount
  ///
  /// This method:
  /// 1. Sums all invoice amounts for the student
  /// 2. Subtracts total paid amount
  /// 3. Returns the difference (can be negative if overpaid)
  ///
  /// Returns a Future<double> with the outstanding balance
  @override
  Future<double> getOutstandingBalance(String studentId) async {
    try {
      // Get total invoiced amount
      final invoiceResult = await _dbService.tryGet(
        'SELECT COALESCE(SUM(amount), 0) as total FROM invoices WHERE student_id = ?',
        [studentId],
      );
      final totalInvoiced =
          (invoiceResult?['total'] as num?)?.toDouble() ?? 0.0;

      // Get total paid amount
      final totalPaid = await getTotalPaidByStudent(studentId: studentId);

      return totalInvoiced - totalPaid;
    } catch (e) {
      throw PaymentDatabaseException(
        'Failed to calculate outstanding balance: ${e.toString()}',
        originalError: e,
      );
    }
  }
}

// ==========================================
// FILE: ./repositories/reports_repository.dart
// ==========================================

import 'package:supabase_flutter/supabase_flutter.dart';

class ReportsRepository {
  final SupabaseClient _client = Supabase.instance.client;

  // 1. Fetch Financial Data
  Future<Map<String, dynamic>> fetchFinancialSummary({
    required String schoolId,
    required DateTime start,
    required DateTime end,
  }) async {
    final response = await _client.rpc('get_financial_summary', params: {
      'target_school_id': schoolId,
      'start_date': start.toIso8601String(),
      'end_date': end.toIso8601String(),
    });
    return response as Map<String, dynamic>;
  }

  // 2. Fetch Outstanding Balances
  Future<List<Map<String, dynamic>>> fetchOutstandingBalances({
    required String schoolId,
    String grade = 'All Grades',
  }) async {
    final response = await _client.rpc('get_outstanding_balances', params: {
      'target_school_id': schoolId,
      'grade_filter': grade,
    });
    return List<Map<String, dynamic>>.from(response);
  }

  // 3. Fetch Enrollment Stats
  Future<Map<String, dynamic>> fetchEnrollmentTrends({
    required String schoolId,
  }) async {
    final response = await _client.rpc('get_enrollment_trends', params: {
      'target_school_id': schoolId,
    });
    return response as Map<String, dynamic>;
  }
}
// ==========================================
// FILE: ./repositories/expense_repository.dart
// ==========================================

import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:uuid/uuid.dart';
import 'package:fees_up/data/services/database_service.dart'; // Adjust path
import 'package:fees_up/data/models/finance_models.dart'; // Adjust path

final expenseRepositoryProvider = Provider((ref) => ExpenseRepository());

class ExpenseRepository {
  final _db = DatabaseService();

  /// Watch expenses for the specific school (Live Stream)
  Stream<List<Expense>> watchRecentExpenses(String schoolId) {
    return _db.db.watch(
      'SELECT * FROM expenses WHERE school_id = ? ORDER BY incurred_at DESC LIMIT 20',
      parameters: [schoolId],
    ).map((rows) => rows.map((row) => Expense.fromRow(row)).toList());
  }

  /// Insert a new expense locally (PowerSync syncs it up)
  Future<void> createExpense({
    required String schoolId,
    required String title,
    required double amount,
    required DateTime incurredAt,
    String? category,
    String? recipient,
    String? notes,
    String? paymentMethod,
  }) async {
    // Since schema lacks 'payment_method', we append it to description
    String finalDescription = notes ?? "";
    if (paymentMethod != null && paymentMethod.isNotEmpty) {
      finalDescription += "\n[Method: $paymentMethod]";
    }

    final newExpense = Expense(
      id: const Uuid().v4(), // Generate ID client-side
      schoolId: schoolId,
      title: title,
      amount: amount,
      incurredAt: incurredAt,
      category: category,
      recipient: recipient,
      description: finalDescription.trim().isEmpty ? null : finalDescription.trim(),
    );

    await _db.insert('expenses', newExpense.toMap());
  }
}
// ==========================================
// FILE: ./services/database_service.dart
// ==========================================

import 'dart:io';
import 'package:flutter/foundation.dart';
import 'package:path/path.dart';
import 'package:path_provider/path_provider.dart';
import 'package:powersync/powersync.dart';
import 'package:supabase_flutter/supabase_flutter.dart';

import 'schema.dart';
import 'supabase_connector.dart';

class DatabaseService {
  static final DatabaseService _instance = DatabaseService._internal();
  factory DatabaseService() => _instance;
  DatabaseService._internal();

  late PowerSyncDatabase _db;
  bool _isInitialized = false;
  late String _dbPath; // Store path locally since PS doesn't expose it

  PowerSyncDatabase get db => _db;

  Future<void> initialize() async {
    if (_isInitialized) return;

    final dir = await getApplicationSupportDirectory();
    _dbPath = join(dir.path, 'greyway_feesup.db');

    _db = PowerSyncDatabase(
      schema: appSchema,
      path: _dbPath,
    );

    await _db.initialize();

    final connector = SupabaseConnector(Supabase.instance.client);
    _db.connect(connector: connector);

    _isInitialized = true;
    if (kDebugMode) {
      print("✅ Database Service Initialized & Connected");
    }
  }

  /// THE NUCLEAR OPTION
  /// Wipes local SQLite and disconnects.
  Future<void> factoryReset() async {
    try {
      await _db.close();
      final file = File(_dbPath);
      if (await file.exists()) {
        await file.delete();
      }
      _isInitialized = false;
      debugPrint("✅ Local database wiped completely.");
    } catch (e) {
      debugPrint("❌ Error during factory reset: $e");
    }
  }

  bool get isConnected => _db.currentStatus.connected;

  Stream<List<Map<String, dynamic>>> watchAll(String table) {
    return _db.watch('SELECT * FROM $table ORDER BY created_at DESC');
  }

  /// Required by Student and Payment Dialogs
  Stream<List<Map<String, dynamic>>> watchStudents(String schoolId) {
    return _db.watch(
      'SELECT * FROM students WHERE school_id = ? ORDER BY full_name ASC',
      parameters: [schoolId],
    );
  }

  /// Runs a raw SQL SELECT query and returns the list of results once.
  /// Useful for one-off fetches like getting the last invoice number.
  Future<List<Map<String, dynamic>>> select(String sql,
      [List<Object?>? arguments]) async {
    return await _db.getAll(sql, arguments ?? []);
  }

  Future<Map<String, dynamic>?> getById(String table, String id) async {
    final results = await _db.getAll('SELECT * FROM $table WHERE id = ?', [id]);
    return results.isNotEmpty ? results.first : null;
  }

  Future<Map<String, dynamic>?> tryGet(String sql,
      [List<Object?>? arguments]) async {
    final results = await _db.getAll(sql, arguments ?? []);
    return results.isNotEmpty ? results.first : null;
  }

  Future<void> insert(String table, Map<String, dynamic> data) async {
    final keys = data.keys.toList();
    final values = data.values.toList();
    final placeholders = List.filled(keys.length, '?').join(', ');
    final columns = keys.join(', ');
    final sql = 'INSERT INTO $table ($columns) VALUES ($placeholders)';
    await _db.execute(sql, values);
  }

  Future<void> update(
      String table, String id, Map<String, dynamic> data) async {
    if (data.isEmpty) return;
    final updates = <String>[];
    final values = <dynamic>[];
    data.forEach((key, value) {
      updates.add('$key = ?');
      values.add(value);
    });
    values.add(id);
    final sql = 'UPDATE $table SET ${updates.join(', ')} WHERE id = ?';
    await _db.execute(sql, values);
  }

  Future<void> delete(String table, String id) async {
    await _db.execute('DELETE FROM $table WHERE id = ?', [id]);
  }

  Future<Map<String, dynamic>?> getUserProfile(String userId) async {
    return await getById('user_profiles', userId);
  }

  /// 🟢 [FIX 1] Watch Classes (Enables Filter)
  Stream<List<Map<String, dynamic>>> watchClasses(String schoolId) {
    return _db.watch(
      'SELECT * FROM classes WHERE school_id = ? ORDER BY name ASC',
      parameters: [schoolId],
    );
  }

  /// 🟢 [FIX 2] Watch Notifications (Enables Bell Icon)
  Stream<List<Map<String, dynamic>>> watchNotifications(String userId) {
    return _db.watch(
      'SELECT * FROM notifications WHERE user_id = ? ORDER BY created_at DESC',
      parameters: [userId],
    );
  }
}

// ==========================================
// FILE: ./services/billing_engine.dart
// ==========================================

/// ============================================================================
/// BILLING ENGINE - ADVANCED FEES UP BILLING SYSTEM
/// ============================================================================
/// 
/// This module provides a comprehensive billing engine that handles:
/// - Multiple billing types (tuition, transport, meals, custom)
/// - Mid-cycle billing switches with prorating
/// - Billing suspensions and resumptions
/// - Complex fee structures and adjustments
/// - Bulk billing operations
/// - Financial reconciliation
///
/// Author: Nyasha Gabriel / Batch Tech
/// Date: January 3, 2026
/// Status: Production-Ready
library billing_engine;

import 'dart:math';
import '../models/billing/billing_configuration.dart';
import '../models/billing/billing_switch.dart';
import '../models/billing/generated_bill.dart';

export '../models/billing/billing_configuration.dart';
export '../models/billing/billing_switch.dart';
export '../models/billing/generated_bill.dart';

// ============================================================================
// PRORATION CALCULATOR
// ============================================================================

class ProratingCalculator {
  /// Calculate prorated amount for partial billing period
  static double calculateProration({
    required double fullAmount,
    required DateTime periodStart,
    required DateTime periodEnd,
    required DateTime actualStart,
    required DateTime actualEnd,
  }) {
    final totalDays = periodEnd.difference(periodStart).inDays + 1;
    final applicableDays = actualEnd.difference(actualStart).inDays + 1;

    if (applicableDays <= 0) return 0.0;

    final rate = fullAmount / totalDays;
    return rate * applicableDays;
  }

  /// Calculate daily rate for a fee
  static double calculateDailyRate({
    required double monthlyAmount,
    int daysInMonth = 30,
  }) =>
      monthlyAmount / daysInMonth;

  /// Calculate late fee
  static double calculateLateFee({
    required double outstandingAmount,
    double? percentageRate,
    double? minFee,
    double? maxFee,
  }) {
    if (percentageRate == null) return 0.0;

    var fee = outstandingAmount * (percentageRate / 100.0);

    if (minFee != null && fee < minFee) fee = minFee;
    if (maxFee != null && fee > maxFee) fee = maxFee;

    return fee;
  }

  /// Calculate next billing date based on frequency
  static DateTime calculateNextBillingDate({
    required DateTime lastBillingDate,
    required BillingFrequency frequency,
    required int billingDay,
  }) {
    switch (frequency) {
      case BillingFrequency.daily:
        return lastBillingDate.add(const Duration(days: 1));
      case BillingFrequency.weekly:
        return lastBillingDate.add(const Duration(days: 7));
      case BillingFrequency.monthly:
        var nextDate = DateTime(
          lastBillingDate.year,
          lastBillingDate.month + 1,
          min(billingDay, _getDaysInMonth(lastBillingDate.year, lastBillingDate.month + 1)),
        );
        return nextDate;
      case BillingFrequency.termly:
        return lastBillingDate.add(const Duration(days: 90));
      case BillingFrequency.annually:
        return DateTime(lastBillingDate.year + 1, lastBillingDate.month, billingDay);
      case BillingFrequency.custom:
        return lastBillingDate.add(const Duration(days: 30));
    }
  }

  static int _getDaysInMonth(int year, int month) {
    if (month > 12) {
      year += 1;
      month -= 12;
    }
    if ([1, 3, 5, 7, 8, 10, 12].contains(month)) return 31;
    if ([4, 6, 9, 11].contains(month)) return 30;
    return (year % 4 == 0 && (year % 100 != 0 || year % 400 == 0)) ? 29 : 28;
  }
}

// ============================================================================
// MAIN BILLING ENGINE
// ============================================================================

class BillingEngine {
  final String schoolId;
  final Map<String, BillingConfiguration> _configCache = {};
  final Map<String, List<BillingSwitch>> _switchHistory = {};

  BillingEngine({required this.schoolId});

  /// Register a billing configuration
  void registerBillingConfig(BillingConfiguration config) {
    _configCache[config.id] = config;
  }

  /// Get applicable billing configuration for a student
  BillingConfiguration? getApplicableConfig({
    required String gradeLevel,
    required DateTime asOfDate,
  }) {
    final configs = _configCache.values.where((config) {
      final isGradeMatch =
          config.gradeLevel == gradeLevel;
      final isEffective = config.effectiveFrom.isBefore(asOfDate) &&
          (config.effectiveUntil == null ||
              config.effectiveUntil!.isAfter(asOfDate));
      return isGradeMatch && isEffective && config.isActive;
    }).toList();

    if (configs.isEmpty) return null;

    // Return most specific (grade-level specific) config
    return configs.firstWhere(
      (c) => c.gradeLevel.isNotEmpty,
      orElse: () => configs.first,
    );
  }

  /// Generate bills for a student for a given period
  List<GeneratedBill> generateBillsForPeriod({
    required String studentId,
    required String studentName,
    required String gradeLevel,
    required DateTime periodStart,
    required DateTime periodEnd,
    required BillingConfiguration config,
  }) {
    final bills = <GeneratedBill>[];
    var currentDate = DateTime(periodStart.year, periodStart.month, config.billingDay);

    // Adjust if start date is after calculated billing date
    if (currentDate.isBefore(periodStart)) {
      currentDate = ProratingCalculator.calculateNextBillingDate(
        lastBillingDate: currentDate,
        frequency: config.frequency,
        billingDay: config.billingDay,
      );
    }

    while (currentDate.isBefore(periodEnd)) {
      final dueDate = DateTime(
        currentDate.year,
        currentDate.month,
        min(config.dueDay, _getDaysInMonth(currentDate.year, currentDate.month)),
      );

      final lineItems = config.feeComponents
          .where((fc) => fc.isApplicable && !fc.isOptional)
          .map((fc) => BillLineItem(
                type: fc.type,
                description: fc.name,
                unitPrice: fc.amount,
              ))
          .toList();

      if (lineItems.isNotEmpty) {
        bills.add(GeneratedBill(
          schoolId: schoolId,
          studentId: studentId,
          studentName: studentName,
          gradeLevel: gradeLevel,
          billingDate: currentDate,
          dueDate: dueDate,
          lineItems: lineItems,
          frequency: config.frequency.code,
        ));
      }

      currentDate = ProratingCalculator.calculateNextBillingDate(
        lastBillingDate: currentDate,
        frequency: config.frequency,
        billingDay: config.billingDay,
      );
    }

    return bills;
  }

  /// Handle mid-cycle billing switch
  List<GeneratedBill> processBillingSwitch({
    required String studentId,
    required String studentName,
    required String gradeLevel,
    required BillingSwitch billSwitch,
    required DateTime lastBillingDate,
  }) {
    final bills = <GeneratedBill>[];

    // Generate prorated bill for remainder of old config
    if (billSwitch.effectiveDate.isAfter(lastBillingDate)) {
      final nextBillingDate = ProratingCalculator.calculateNextBillingDate(
        lastBillingDate: lastBillingDate,
        frequency: billSwitch.oldConfig.frequency,
        billingDay: billSwitch.oldConfig.billingDay,
      );

      if (nextBillingDate.isAfter(billSwitch.effectiveDate)) {
        final proratedAmount = ProratingCalculator.calculateProration(
          fullAmount: billSwitch.oldConfig.calculateTotalFee(),
          periodStart: lastBillingDate,
          periodEnd: nextBillingDate,
          actualStart: lastBillingDate,
          actualEnd: billSwitch.effectiveDate.subtract(const Duration(days: 1)),
        );

        final lineItems = billSwitch.oldConfig.feeComponents
            .where((fc) => fc.isApplicable && !fc.isOptional)
            .map((fc) {
              final proratedFee = (fc.amount / billSwitch.oldConfig.calculateTotalFee()) *
                  proratedAmount;
              return BillLineItem(
                type: fc.type,
                description: '${fc.name} (Prorated to ${billSwitch.effectiveDate.day}-${lastBillingDate.add(Duration(days: (nextBillingDate.difference(lastBillingDate).inDays))).day})',
                unitPrice: proratedFee,
              );
            })
            .toList();

        if (lineItems.isNotEmpty) {
          bills.add(GeneratedBill(
            schoolId: schoolId,
            studentId: studentId,
            studentName: studentName,
            gradeLevel: gradeLevel,
            billingDate: lastBillingDate,
            dueDate: DateTime(
              billSwitch.effectiveDate.year,
              billSwitch.effectiveDate.month,
              min(billSwitch.oldConfig.dueDay,
                  _getDaysInMonth(billSwitch.effectiveDate.year, billSwitch.effectiveDate.month)),
            ),
            lineItems: lineItems,
            frequency: billSwitch.oldConfig.frequency.code,
            isSwitchBill: true,
          ));
        }
      }
    }

    // Generate first bill with new config
    final newConfigBills = generateBillsForPeriod(
      studentId: studentId,
      studentName: studentName,
      gradeLevel: gradeLevel,
      periodStart: billSwitch.effectiveDate,
      periodEnd: billSwitch.effectiveDate.add(const Duration(days: 90)),
      config: billSwitch.newConfig,
    );

    bills.addAll(newConfigBills);
    _switchHistory.putIfAbsent(studentId, () => []).add(billSwitch);

    return bills;
  }

  /// Calculate all outstanding charges for a student
  double calculateOutstandingBalance({
    required double unpaidBillsTotal,
    required double lateFees,
    required double adjustments,
  }) =>
      unpaidBillsTotal + lateFees - adjustments.abs();

  /// Get billing history for a student
  List<BillingSwitch> getBillingHistory(String studentId) =>
      _switchHistory[studentId] ?? [];

  static int _getDaysInMonth(int year, int month) {
    if ([1, 3, 5, 7, 8, 10, 12].contains(month)) return 31;
    if ([4, 6, 9, 11].contains(month)) return 30;
    return (year % 4 == 0 && (year % 100 != 0 || year % 400 == 0)) ? 29 : 28;
  }
}

// ============================================================================
// UTILITY: BATCH BILLING OPERATIONS
// ============================================================================

class BatchBillingProcessor {
  final BillingEngine engine;
  final List<GeneratedBill> generatedBills = [];
  final List<String> processingErrors = [];

  BatchBillingProcessor({required this.engine});

  /// Process billing for multiple students
  Future<void> processBulkBilling({
    required List<Map<String, dynamic>> students, // {id, name, gradeLevel, ...}
    required BillingConfiguration config,
    required DateTime periodStart,
    required DateTime periodEnd,
  }) async {
    for (final student in students) {
      try {
        final bills = engine.generateBillsForPeriod(
          studentId: student['id'] as String,
          studentName: student['name'] as String,
          gradeLevel: student['gradeLevel'] as String,
          periodStart: periodStart,
          periodEnd: periodEnd,
          config: config,
        );
        generatedBills.addAll(bills);
      } catch (e) {
        processingErrors.add(
          'Failed to generate bill for ${student['name']}: $e',
        );
      }
    }
  }

  /// Get summary of batch processing
  Map<String, dynamic> getSummary() => {
        'totalBillsGenerated': generatedBills.length,
        'totalAmount': generatedBills.fold(0.0, (sum, bill) => sum + bill.total),
        'processedStudents': generatedBills.map((b) => b.studentId).toSet().length,
        'errors': processingErrors,
        'errorCount': processingErrors.length,
      };
}

// ==========================================
// FILE: ./services/supabase_connector.dart
// ==========================================

/// -----------------------------------------------------------------
/// GREYWAY.CO / BATCH TECH - CONFIDENTIAL
/// -----------------------------------------------------------------
/// Author:  Nyasha Gabriel
/// Date:    2025-12-31
/// Ref:     https://supabase.com/docs
///
/// This file defines a SupabaseConnector class that integrates
/// Supabase with PowerSync for data synchronization.
///
/// It implements methods to fetch authentication credentials
/// and upload data changes to the Supabase backend.
///
/// -----------------------------------------------------------------
library supabase_connector;

import 'package:flutter/material.dart';
import 'package:powersync/powersync.dart';
import 'package:supabase_flutter/supabase_flutter.dart';

class SupabaseConnector extends PowerSyncBackendConnector {
  final SupabaseClient db;
  bool _hasLoggedAuthWarning = false;

  SupabaseConnector(this.db);

  @override
  Future<PowerSyncCredentials?> fetchCredentials() async {
    final session = db.auth.currentSession;

    if (session == null) {
      // Log once to avoid spam, then return null
      if (!_hasLoggedAuthWarning) {
        debugPrint(
            "⚠️ PowerSync: No authenticated session. Please sign in to start sync.");
        _hasLoggedAuthWarning = true;
      }
      return null;
    }

    // Reset warning flag when session is available
    _hasLoggedAuthWarning = false;

    const endpoint = String.fromEnvironment('POWERSYNC_ENDPOINT_URL');
    if (endpoint.isEmpty) {
      throw Exception('POWERSYNC_ENDPOINT_URL not set in --dart-define');
    }

    // Validate endpoint format
    if (!endpoint.startsWith('https://') && !endpoint.startsWith('http://')) {
      throw Exception('POWERSYNC_ENDPOINT_URL must be a valid URL: $endpoint');
    }

    return PowerSyncCredentials(
      endpoint: endpoint,
      token: session.accessToken,
      userId: session.user.id,
    );
  }

  @override
  Future<void> uploadData(PowerSyncDatabase database) async {
    final transaction = await database.getNextCrudTransaction();
    if (transaction == null) return;

    try {
      for (var op in transaction.crud) {
        final table = op.table;
        final id = op.id;
        final data = op.opData;

        // "Create or Update" Logic
        if (op.op == UpdateType.put) {
          if (data == null) {
            debugPrint('⚠️ Warning: data is null for PUT operation on $table');
            continue;
          }
          // .upsert is the safest bet: it handles both new and existing records.
          // onConflict: 'id' ensures we don't get duplicate key errors.
          await db.from(table).upsert(
            {...data, 'id': id},
            onConflict: 'id',
            ignoreDuplicates: false,
          );
        } else if (op.op == UpdateType.patch) {
          if (data == null) {
            debugPrint('⚠️ Warning: data is null for PATCH operation on $table');
            continue;
          }
          await db.from(table).update(data).eq('id', id);
        } else if (op.op == UpdateType.delete) {
          await db.from(table).delete().eq('id', id);
        }
      }

      // Clear the queue once finished
      await transaction.complete();
    } on PostgrestException catch (e) {
      // 42501 = RLS Violation.
      // 23503 = Foreign Key Violation (Key is not present in table).
      // If we don't .complete() here, this one row blocks the WHOLE app sync loop.
      if (e.code == '42501' || e.code == '23503') {
        debugPrint(
            '❌ Sync Error ${e.code} on $transaction: ${e.message}. Skipping to unblock queue.');
        await transaction.complete();
      } else {
        // For network or server 500 errors, we rethrow so PowerSync retries later.
        rethrow;
      }
    } catch (e) {
      debugPrint('Sync Upload Error: $e');
      rethrow;
    }
  }
}

// ==========================================
// FILE: ./services/encryption_service.dart
// ==========================================

import 'package:encrypt/encrypt.dart' as enc;

class EncryptionService {
  // 1. Fetch from Environment (passed via Makefile)
  // Fallback provided just in case dev env is missing keys.
  static const _envPassword = String.fromEnvironment(
    'UFT_PASSWORD', 
    defaultValue: 'FeesUpDefaultDevKey32CharsLong!!' 
  );

  // 2. Ensure Key is exactly 32 chars for AES-256
  static final _keyString = _envPassword.padRight(32, '#').substring(0, 32);

  static final _key = enc.Key.fromUtf8(_keyString);
  static final _iv = enc.IV.fromLength(16);
  static final _encrypter = enc.Encrypter(enc.AES(_key));

  static String encrypt(String plainText) {
    return _encrypter.encrypt(plainText, iv: _iv).base64;
  }

  static String decrypt(String encryptedBase64) {
    try {
      return _encrypter.decrypt(enc.Encrypted.fromBase64(encryptedBase64), iv: _iv);
    } catch (e) {
      return "[]";
    }
  }
}
// ==========================================
// FILE: ./services/financial_reports_service.dart
// ==========================================

import 'package:intl/intl.dart';
import 'package:supabase_flutter/supabase_flutter.dart';

/// 🔒 SECURE Financial Reports Service
/// Generates comprehensive financial reports with export capabilities
/// Respects billing suspension status in all calculations
class FinancialReportsService {
  final SupabaseClient supabase;

  FinancialReportsService({required this.supabase});

  // ========== REPORT BUILDING ==========

  /// ✅ SECURE: Generate custom financial report
  /// Supports multiple report types with filtering
  Future<Map<String, dynamic>> generateCustomReport({
    required String schoolId,
    required ReportCategory category,
    required DateTimeRange dateRange,
    String? gradeLevel,
    String? studentId,
  }) async {
    try {
      switch (category) {
        case ReportCategory.tuitionCollection:
          return await _generateTuitionCollectionReport(
            schoolId: schoolId,
            dateRange: dateRange,
            gradeLevel: gradeLevel,
          );

        case ReportCategory.outstandingBalances:
          return await _generateOutstandingBalancesReport(
            schoolId: schoolId,
            gradeLevel: gradeLevel,
          );

        case ReportCategory.expenseAnalysis:
          return await _generateExpenseAnalysisReport(
            schoolId: schoolId,
            dateRange: dateRange,
          );

        case ReportCategory.paymentMethodBreakdown:
          return await _generatePaymentMethodReport(
            schoolId: schoolId,
            dateRange: dateRange,
          );

        case ReportCategory.studentLedger:
          return await _generateStudentLedgerReport(
            studentId: studentId ?? '',
            dateRange: dateRange,
          );

        case ReportCategory.cashFlow:
          return await _generateCashFlowReport(
            schoolId: schoolId,
            dateRange: dateRange,
          );
      }
    } catch (e) {
      rethrow;
    }
  }

  /// Tuition Collection Report
  /// Shows collected vs outstanding amounts with trend analysis
  Future<Map<String, dynamic>> _generateTuitionCollectionReport({
    required String schoolId,
    required DateTimeRange dateRange,
    String? gradeLevel,
  }) async {
    try {
      final response = await supabase.rpc('get_tuition_collection_report',
          params: {
            'p_school_id': schoolId,
            'p_start_date': dateRange.start.toIso8601String(),
            'p_end_date': dateRange.end.toIso8601String(),
            'p_grade_level': gradeLevel,
          });

      return response as Map<String, dynamic>;
    } catch (e) {
      rethrow;
    }
  }

  /// Outstanding Balances Report
  /// Lists students with balances owed, sorted by amount
  Future<Map<String, dynamic>> _generateOutstandingBalancesReport({
    required String schoolId,
    String? gradeLevel,
  }) async {
    try {
      final response = await supabase.rpc('get_outstanding_balances_report',
          params: {
            'p_school_id': schoolId,
            'p_grade_level': gradeLevel,
          });

      return response as Map<String, dynamic>;
    } catch (e) {
      rethrow;
    }
  }

  /// Expense Analysis Report
  /// Breaks down expenses by category with variance analysis
  Future<Map<String, dynamic>> _generateExpenseAnalysisReport({
    required String schoolId,
    required DateTimeRange dateRange,
  }) async {
    try {
      final response = await supabase.rpc('get_expense_analysis_report',
          params: {
            'p_school_id': schoolId,
            'p_start_date': dateRange.start.toIso8601String(),
            'p_end_date': dateRange.end.toIso8601String(),
          });

      return response as Map<String, dynamic>;
    } catch (e) {
      rethrow;
    }
  }

  /// Payment Method Breakdown Report
  /// Shows payment volumes by method (Cash, Bank Transfer, etc.)
  Future<Map<String, dynamic>> _generatePaymentMethodReport({
    required String schoolId,
    required DateTimeRange dateRange,
  }) async {
    try {
      final response = await supabase.rpc('get_payment_method_report',
          params: {
            'p_school_id': schoolId,
            'p_start_date': dateRange.start.toIso8601String(),
            'p_end_date': dateRange.end.toIso8601String(),
          });

      return response as Map<String, dynamic>;
    } catch (e) {
      rethrow;
    }
  }

  /// Student Ledger Report
  /// Complete transaction history for a single student
  Future<Map<String, dynamic>> _generateStudentLedgerReport({
    required String studentId,
    required DateTimeRange dateRange,
  }) async {
    try {
      final response = await supabase.rpc('get_student_ledger_report', params: {
        'p_student_id': studentId,
        'p_start_date': dateRange.start.toIso8601String(),
        'p_end_date': dateRange.end.toIso8601String(),
      });

      return response as Map<String, dynamic>;
    } catch (e) {
      rethrow;
    }
  }

  /// Cash Flow Report
  /// Shows daily/weekly/monthly cash movements
  Future<Map<String, dynamic>> _generateCashFlowReport({
    required String schoolId,
    required DateTimeRange dateRange,
  }) async {
    try {
      final response = await supabase.rpc('get_cash_flow_report', params: {
        'p_school_id': schoolId,
        'p_start_date': dateRange.start.toIso8601String(),
        'p_end_date': dateRange.end.toIso8601String(),
      });

      return response as Map<String, dynamic>;
    } catch (e) {
      rethrow;
    }
  }

  // ========== FINANCIAL SUMMARY (Dashboard) ==========

  /// Get financial dashboard summary
  /// KPIs: Total collected, Outstanding, Collection rate, Expenses, Net position
  Future<Map<String, dynamic>> getFinancialSummary(String schoolId) async {
    try {
      final response = await supabase.rpc('get_financial_summary', params: {
        'target_school_id': schoolId,
      });

      return response as Map<String, dynamic>;
    } catch (e) {
      rethrow;
    }
  }

  /// Get enrollment trends
  /// Shows student count trends over time (for projection calculations)
  Future<Map<String, dynamic>> getEnrollmentTrends(String schoolId) async {
    try {
      final response = await supabase.rpc('get_enrollment_trends', params: {
        'target_school_id': schoolId,
      });

      return response as Map<String, dynamic>;
    } catch (e) {
      rethrow;
    }
  }

  // ========== COMPARATIVE ANALYSIS ==========

  /// Compare financial performance across periods
  /// Useful for period-over-period analysis (YoY, QoQ, MoM)
  Future<Map<String, dynamic>> comparePerformancePeriods({
    required String schoolId,
    required DateTimeRange period1,
    required DateTimeRange period2,
  }) async {
    try {
      final response = await supabase.rpc('compare_periods', params: {
        'p_school_id': schoolId,
        'p_period1_start': period1.start.toIso8601String(),
        'p_period1_end': period1.end.toIso8601String(),
        'p_period2_start': period2.start.toIso8601String(),
        'p_period2_end': period2.end.toIso8601String(),
      });

      return response as Map<String, dynamic>;
    } catch (e) {
      rethrow;
    }
  }

  /// Forecast future cash position based on historical data
  Future<Map<String, dynamic>> forecastCashFlow({
    required String schoolId,
    required int forecastDays,
  }) async {
    try {
      final response = await supabase.rpc('forecast_cash_flow', params: {
        'p_school_id': schoolId,
        'p_forecast_days': forecastDays,
      });

      return response as Map<String, dynamic>;
    } catch (e) {
      rethrow;
    }
  }

  // ========== EXPORT FUNCTIONALITY ==========

  /// ✅ NEW: Export report to CSV format
  /// Returns CSV string ready for file download
  String exportReportToCSV({
    required String reportName,
    required List<Map<String, dynamic>> data,
    List<String>? columnOrder,
  }) {
    if (data.isEmpty) {
      return 'No data available';
    }

    // Determine columns from first row or use specified order
    final columns = columnOrder ?? data.first.keys.toList();

    // Build CSV header
    final csv = StringBuffer();
    csv.writeln(columns.join(','));

    // Build CSV rows
    for (final row in data) {
      final values = columns.map((col) {
        final value = row[col];
        if (value == null) return '';

        // Escape quotes and wrap in quotes if contains comma
        final strValue = value.toString();
        if (strValue.contains(',') || strValue.contains('"')) {
          return '"${strValue.replaceAll('"', '""')}"';
        }
        return strValue;
      });

      csv.writeln(values.join(','));
    }

    return csv.toString();
  }

  /// ✅ NEW: Export report to JSON format
  /// Returns JSON string with metadata
  String exportReportToJSON({
    required String reportName,
    required Map<String, dynamic> reportData,
    String? description,
  }) {
    final export = {
      'metadata': {
        'reportName': reportName,
        'generatedAt': DateTime.now().toIso8601String(),
        'description': description,
      },
      'data': reportData,
    };

    // Simple JSON serialization
    return _jsonEncode(export);
  }

  /// Helper: Simple JSON encoding (Dart's jsonEncode alternative)
  String _jsonEncode(dynamic value) {
    if (value == null) return 'null';
    if (value is bool) return value.toString();
    if (value is num) return value.toString();
    if (value is String) return '"${value.replaceAll('"', '\\"')}"';
    if (value is List) {
      return '[${value.map(_jsonEncode).join(', ')}]';
    }
    if (value is Map) {
      final pairs = value.entries
          .map((e) => '"${e.key}": ${_jsonEncode(e.value)}')
          .join(', ');
      return '{$pairs}';
    }
    return value.toString();
  }

  // ========== AUDIT & COMPLIANCE ==========

  /// Get audit log for financial transactions
  /// Admin-only access to track all financial changes
  Future<List<Map<String, dynamic>>> getFinancialAuditLog({
    required String schoolId,
    DateTime? startDate,
    DateTime? endDate,
    String? actionType, // 'invoice_created', 'payment_recorded', 'refund_processed'
  }) async {
    try {
      final query = supabase
          .from('financial_audit_log')
          .select(
              'id, action_type, user_id, amount, reference_id, created_at, details');

      var filtered = query.eq('school_id', schoolId);

      // Apply all optional filters inline without reassignment
      final response = await (startDate != null && endDate != null && actionType != null
          ? filtered
              .gte('created_at', startDate.toIso8601String())
              .lte('created_at', endDate.toIso8601String())
              .eq('action_type', actionType)
              .order('created_at', ascending: false)
          : startDate != null && endDate != null
              ? filtered
                  .gte('created_at', startDate.toIso8601String())
                  .lte('created_at', endDate.toIso8601String())
                  .order('created_at', ascending: false)
          : startDate != null && actionType != null
              ? filtered
                  .gte('created_at', startDate.toIso8601String())
                  .eq('action_type', actionType)
                  .order('created_at', ascending: false)
              : endDate != null && actionType != null
                  ? filtered
                      .lte('created_at', endDate.toIso8601String())
                      .eq('action_type', actionType)
                      .order('created_at', ascending: false)
              : startDate != null
                  ? filtered
                      .gte('created_at', startDate.toIso8601String())
                      .order('created_at', ascending: false)
                  : endDate != null
                      ? filtered
                          .lte('created_at', endDate.toIso8601String())
                          .order('created_at', ascending: false)
                      : actionType != null
                          ? filtered
                              .eq('action_type', actionType)
                              .order('created_at', ascending: false)
                          : filtered.order('created_at', ascending: false));

      return List<Map<String, dynamic>>.from(response);
    } catch (e) {
      rethrow;
    }
  }

  /// Validate financial consistency across all records
  /// Checks for discrepancies in bill vs payment totals
  Future<Map<String, dynamic>> validateFinancialConsistency(
      String schoolId) async {
    try {
      final response =
          await supabase.rpc('validate_financial_consistency', params: {
        'p_school_id': schoolId,
      });

      return response as Map<String, dynamic>;
    } catch (e) {
      rethrow;
    }
  }
}

// ========== ENUMS & TYPES ==========

enum ReportCategory {
  tuitionCollection,
  outstandingBalances,
  expenseAnalysis,
  paymentMethodBreakdown,
  studentLedger,
  cashFlow,
}

enum ReportFormat {
  pdf,
  csv,
  json,
  xlsx, // Excel format (if library available)
}

extension ReportCategoryDisplay on ReportCategory {
  String get displayName {
    switch (this) {
      case ReportCategory.tuitionCollection:
        return 'Tuition Collection Report';
      case ReportCategory.outstandingBalances:
        return 'Outstanding Balances Report';
      case ReportCategory.expenseAnalysis:
        return 'Expense Analysis Report';
      case ReportCategory.paymentMethodBreakdown:
        return 'Payment Method Breakdown';
      case ReportCategory.studentLedger:
        return 'Student Ledger';
      case ReportCategory.cashFlow:
        return 'Cash Flow Report';
    }
  }
}

/// Date range helper for reports
class DateTimeRange {
  final DateTime start;
  final DateTime end;

  DateTimeRange({
    required this.start,
    required this.end,
  });

  factory DateTimeRange.thisMonth() {
    final now = DateTime.now();
    return DateTimeRange(
      start: DateTime(now.year, now.month, 1),
      end: DateTime(now.year, now.month + 1, 1).subtract(const Duration(days: 1)),
    );
  }

  factory DateTimeRange.lastMonth() {
    final now = DateTime.now();
    final previousMonth = now.month == 1 ? 12 : now.month - 1;
    final previousYear = now.month == 1 ? now.year - 1 : now.year;
    return DateTimeRange(
      start: DateTime(previousYear, previousMonth, 1),
      end: DateTime(previousYear, previousMonth + 1, 1)
          .subtract(const Duration(days: 1)),
    );
  }

  factory DateTimeRange.thisYear() {
    final now = DateTime.now();
    return DateTimeRange(
      start: DateTime(now.year, 1, 1),
      end: DateTime(now.year, 12, 31),
    );
  }

  factory DateTimeRange.custom({
    required DateTime start,
    required DateTime end,
  }) {
    return DateTimeRange(start: start, end: end);
  }

  String get displayName {
    if (start.year == end.year && start.month == end.month) {
      return DateFormat('MMMM yyyy').format(start);
    }
    return '${DateFormat('MMM yyyy').format(start)} - ${DateFormat('MMM yyyy').format(end)}';
  }
}

// ==========================================
// FILE: ./services/invoice_service.dart
// ==========================================

import 'package:intl/intl.dart';
import 'package:supabase_flutter/supabase_flutter.dart';
import 'package:uuid/uuid.dart';

import '../../core/security/billing_guard.dart';
import '../../core/errors/billing_exceptions.dart';
import 'device_authority_service.dart';
import 'database_service.dart';

/// 🔒 SECURE Invoice Service with RPC-only access pattern
/// All invoice operations must respect billing suspension status
/// Only the billing engine device can create/modify invoices
class InvoiceService {
  final SupabaseClient supabase;
  final BillingGuard _guard;
  final DeviceAuthorityService _deviceAuthority;

  InvoiceService({required this.supabase})
      : _guard = BillingGuard(supabase),
        _deviceAuthority = DeviceAuthorityService();

  /// Generate next invoice number sequentially
  /// Format: INV-XXXXX (e.g., INV-00001)
  Future<String> getNextInvoiceNumber(String schoolId) async {
    try {
      final response = await supabase
          .from('bills')
          .select('invoice_number')
          .eq('school_id', schoolId)
          .order('invoice_number', ascending: false)
          .limit(1);

      if (response.isEmpty) {
        return 'INV-00001';
      }

      final lastInvoice = response.first['invoice_number'] as String?;
      if (lastInvoice != null && lastInvoice.startsWith('INV-')) {
        final numericPart = int.tryParse(lastInvoice.split('-')[1]);
        if (numericPart != null) {
          final nextNum = numericPart + 1;
          return 'INV-${nextNum.toString().padLeft(5, '0')}';
        }
      }

      return 'INV-00001';
    } catch (e) {
      rethrow;
    }
  }

  /// ✅ SECURE: Create adhoc invoice (manual billing)
  /// - No schema hacks (no 'term_id': 'adhoc-manual')
  /// - Supports draft status before sending
  /// - Properly tracks invoice with all metadata
  /// - 🔒 Only billing engine device can create invoices
  Future<Map<String, dynamic>> createAdhocInvoice({
    required String schoolId,
    required String studentId,
    required String title,
    required double amount,
    required DateTime dueDate,
    required String status, // 'draft', 'sent', 'paid', 'overdue'
    required String userId, // Required for RLS compliance
  }) async {
    return _guard.run(
      schoolId: schoolId,
      action: () async {
        // ✅ Check device authority
        final isBillingEngine =
            await _deviceAuthority.isBillingEngineForSchool(schoolId);
        if (!isBillingEngine) {
          throw BillingEnginePermissionException(
              'This device is not the billing engine for $schoolId. '
              'Only the billing engine device can create invoices.');
        }

        final invoiceId = const Uuid().v4();
        final invoiceNumber = await getNextInvoiceNumber(schoolId);
        final now = DateTime.now();

        // ✅ CORRECT: No artificial term_id hack
        // Bill_type 'adhoc' is sufficient - database schema supports null values
        // for school_year_id, month_index, and term_id
        final billData = {
          'id': invoiceId,
          'school_id': schoolId,
          'student_id': studentId,
          'invoice_number': invoiceNumber,
          'title': title,
          'total_amount': amount,
          'paid_amount': 0.0,
          'is_paid': 0,
          'is_closed': 0,
          'bill_type': 'adhoc',
          'status': status, // 'draft', 'sent', 'paid', 'overdue'
          'due_date': DateFormat('yyyy-MM-dd').format(dueDate),
          'created_at': now.toIso8601String(),
          'updated_at': now.toIso8601String(),
          'month_year': DateFormat('yyyy-MM').format(now),
          'user_id': userId, // ✅ Required for RLS compliance
          'device_id': _deviceAuthority
              .currentDeviceId, // ✅ Track which device created it
          // ✅ CORRECT: No term_id, school_year_id, month_index required for adhoc
          // Database schema allows nulls for these fields
        };

        // ✅ Use PowerSync for offline-first write
        final db = DatabaseService().db;
        await db.execute(
          'INSERT INTO bills (id, school_id, student_id, invoice_number, title, total_amount, paid_amount, is_paid, is_closed, bill_type, status, due_date, created_at, updated_at, month_year, user_id, device_id) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)',
          [
            billData['id'],
            billData['school_id'],
            billData['student_id'],
            billData['invoice_number'],
            billData['title'],
            billData['total_amount'],
            billData['paid_amount'],
            billData['is_paid'],
            billData['is_closed'],
            billData['bill_type'],
            billData['status'],
            billData['due_date'],
            billData['created_at'],
            billData['updated_at'],
            billData['month_year'],
            billData['user_id'],
            billData['device_id'],
          ],
        );

        return {
          'id': invoiceId,
          'invoiceNumber': invoiceNumber,
          'status': 'success',
        };
      },
    );
  }

  /// Update invoice status (draft → sent, sent → paid, etc.)
  /// 🔒 Only billing engine device can update invoices
  Future<void> updateInvoiceStatus({
    required String schoolId,
    required String invoiceId,
    required String newStatus, // 'draft', 'sent', 'paid', 'overdue'
  }) async {
    // ✅ Check device authority
    final isBillingEngine =
        await _deviceAuthority.isBillingEngineForSchool(schoolId);
    if (!isBillingEngine) {
      throw BillingEnginePermissionException(
          'This device is not the billing engine for $schoolId. '
          'Only the billing engine device can update invoices.');
    }

    try {
      final db = DatabaseService().db;
      // ✅ Use PowerSync for offline-first update
      await db.execute(
        'UPDATE bills SET status = ?, updated_at = ? WHERE id = ?',
        [newStatus, DateTime.now().toIso8601String(), invoiceId],
      );
    } catch (e) {
      rethrow;
    }
  }

  /// Get invoice by ID with full details
  Future<Map<String, dynamic>?> getInvoiceById(String invoiceId) async {
    try {
      final response = await supabase
          .from('bills')
          .select(
              'id, school_id, student_id, invoice_number, title, total_amount, paid_amount, is_paid, status, due_date, bill_type, created_at, updated_at')
          .eq('id', invoiceId)
          .single();

      return response;
    } catch (e) {
      return null;
    }
  }

  /// Get all invoices for a school (with optional filtering)
  Future<List<Map<String, dynamic>>> getInvoicesForSchool({
    required String schoolId,
    String? status, // Optional filter: 'draft', 'sent', 'paid', 'overdue'
    String? studentId, // Optional filter by student
  }) async {
    try {
      // Build query without conditional reassignment
      final query = supabase.from('bills').select(
          'id, school_id, student_id, invoice_number, title, total_amount, paid_amount, is_paid, status, due_date, bill_type, created_at');

      // Apply filters in chain
      var filtered = query.eq('school_id', schoolId).eq('bill_type', 'adhoc');

      // Apply optional filters inline without reassignment
      final response = await (status != null && studentId != null
          ? filtered
              .eq('status', status)
              .eq('student_id', studentId)
              .order('created_at', ascending: false)
          : status != null
              ? filtered
                  .eq('status', status)
                  .order('created_at', ascending: false)
              : studentId != null
                  ? filtered
                      .eq('student_id', studentId)
                      .order('created_at', ascending: false)
                  : filtered.order('created_at', ascending: false));

      return List<Map<String, dynamic>>.from(response);
    } catch (e) {
      rethrow;
    }
  }

  /// Get outstanding (unpaid) invoices for a student
  Future<List<Map<String, dynamic>>> getOutstandingInvoices(
      String studentId) async {
    try {
      final response = await supabase
          .from('bills')
          .select(
              'id, invoice_number, title, total_amount, paid_amount, due_date, status')
          .eq('student_id', studentId)
          .eq('is_paid', 0)
          .neq('status', 'draft') // Exclude drafts from outstanding
          .order('due_date', ascending: true);

      return List<Map<String, dynamic>>.from(response);
    } catch (e) {
      rethrow;
    }
  }

  /// Calculate invoice aging (how overdue)
  /// Returns number of days overdue (negative if not yet due)
  int calculateInvoiceAge(DateTime dueDate) {
    final now = DateTime.now();
    return now.difference(dueDate).inDays;
  }

  /// Get invoices by date range
  Future<List<Map<String, dynamic>>> getInvoicesByDateRange({
    required String schoolId,
    required DateTime startDate,
    required DateTime endDate,
  }) async {
    try {
      final response = await supabase
          .from('bills')
          .select(
              'id, invoice_number, title, total_amount, paid_amount, status, created_at')
          .eq('school_id', schoolId)
          .gte('created_at', startDate.toIso8601String())
          .lte('created_at', endDate.toIso8601String())
          .order('created_at', ascending: false);

      return List<Map<String, dynamic>>.from(response);
    } catch (e) {
      rethrow;
    }
  }

  /// Archive/close an invoice (mark as closed)
  /// 🔒 Only billing engine device can close invoices
  Future<void> closeInvoice({
    required String schoolId,
    required String invoiceId,
  }) async {
    // ✅ Check device authority
    final isBillingEngine =
        await _deviceAuthority.isBillingEngineForSchool(schoolId);
    if (!isBillingEngine) {
      throw BillingEnginePermissionException(
          'This device is not the billing engine for $schoolId. '
          'Only the billing engine device can close invoices.');
    }

    try {
      final db = DatabaseService().db;
      // ✅ Use PowerSync for offline-first update
      await db.execute(
        'UPDATE bills SET is_closed = 1, updated_at = ? WHERE id = ?',
        [DateTime.now().toIso8601String(), invoiceId],
      );
    } catch (e) {
      rethrow;
    }
  }

  /// Get invoice statistics for school dashboard
  Future<Map<String, dynamic>> getInvoiceStatistics(String schoolId) async {
    try {
      final response = await supabase.rpc('get_invoice_statistics', params: {
        'p_school_id': schoolId,
      });

      return response as Map<String, dynamic>;
    } catch (e) {
      rethrow;
    }
  }
}

// ==========================================
// FILE: ./services/broadcast_service.dart
// ==========================================

import 'dart:async';
import 'dart:convert';
import 'package:fees_up/data/services/encryption_service.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:supabase_flutter/supabase_flutter.dart';
import 'package:shared_preferences/shared_preferences.dart';
import '../models/broadcast_model.dart';

final broadcastServiceProvider = Provider((ref) => BroadcastService());

class BroadcastService {
  final _supabase = Supabase.instance.client;
  static const _storageKey = 'cached_broadcasts_encrypted';

  /// 1. ONLINE STREAM (Supabase Realtime)
  /// Listens to the live Websocket feed.
  Stream<List<Broadcast>> streamBroadcasts(String schoolId) {
    return _supabase
        .from('broadcasts')
        .stream(primaryKey: ['id'])
        .order('created_at', ascending: false)
        .map((maps) {
          final list = maps.map((e) => Broadcast.fromRow(e)).toList();
          
          // SIDE EFFECT: Encrypt & Cache immediately
          _cacheBroadcasts(list);
          
          return list;
        });
  }

  /// 2. OFFLINE LOAD (Encrypted Local Storage)
  Future<List<Broadcast>> loadCachedBroadcasts() async {
    final prefs = await SharedPreferences.getInstance();
    final encryptedData = prefs.getString(_storageKey);

    if (encryptedData == null) return [];

    try {
      // Decrypt
      final jsonStr = EncryptionService.decrypt(encryptedData);
      final List<dynamic> decoded = jsonDecode(jsonStr);
      
      final broadcasts = decoded.map((e) => Broadcast.fromRow(e)).toList();

      // Filter: Auto-expire messages older than 7 days
      return broadcasts.where((b) {
        return DateTime.now().difference(b.createdAt).inDays < 7;
      }).toList();

    } catch (e) {
      // If data is corrupt, clear it
      await prefs.remove(_storageKey);
      return [];
    }
  }

  /// Helper: Encrypt -> Save
  Future<void> _cacheBroadcasts(List<Broadcast> list) async {
    final prefs = await SharedPreferences.getInstance();
    
    // Only cache the newest 50 to keep it fast
    final subset = list.take(50).toList();
    
    // Convert to JSON
    final jsonStr = jsonEncode(subset.map((b) => b.toMap()).toList());
    
    // Encrypt
    final encryptedStr = EncryptionService.encrypt(jsonStr);
    
    // Save
    await prefs.setString(_storageKey, encryptedStr);
  }

  /// 3. SENDING (Admin Only)
  /// Sends directly via REST API (bypassing PowerSync)
  Future<void> sendBroadcast({
    required String schoolId,
    required String authorId,
    required String title,
    required String body,
    String priority = 'normal',
    String targetRole = 'all',
  }) async {
    await _supabase.from('broadcasts').insert({
      'school_id': schoolId,
      'author_id': authorId,
      'title': title,
      'body': body,
      'priority': priority,
      'target_role': targetRole,
      'is_system_message': false,
    });
  }
}
// ==========================================
// FILE: ./services/security_sync_service.dart
// ==========================================

import 'dart:async';
import 'package:flutter/foundation.dart';
import 'package:supabase_flutter/supabase_flutter.dart';
import 'database_service.dart';

/// 🔄 SECURITY SYNC SERVICE (The "Pull Once" Protocol)
/// Responsibilities:
/// 1. Fetch critical security rules from Supabase (Cloud).
/// 2. Save them to Local Storage (SQLite) immediately.
/// 3. Never let the UI wait for this. It runs in the background.
class SecuritySyncService {
  static final SecuritySyncService _instance = SecuritySyncService._internal();
  factory SecuritySyncService() => _instance;
  SecuritySyncService._internal();

  final SupabaseClient _supabase = Supabase.instance.client;
  final DatabaseService _db = DatabaseService();

  /// Call this in main.dart after DatabaseService.initialize()
  /// and DeviceAuthorityService.initialize()
  /// 
  /// This runs in the background and does NOT block the UI.
  Future<void> pullSecurityRules(String schoolId, String deviceId) async {
    try {
      debugPrint("🔄 Pull Once: Fetching security rules for $schoolId...");

      // 1. Fetch School Status (Is suspended?)
      final schoolResponse = await _supabase
          .from('schools')
          .select('is_suspended, subscription_status')
          .eq('id', schoolId)
          .maybeSingle();

      // 2. Fetch Device Authority (Is this the billing engine?)
      final deviceResponse = await _supabase
          .from('billing_engine_registry')
          .select('is_active')
          .eq('school_id', schoolId)
          .eq('device_id', deviceId)
          .maybeSingle();

      // 3. WRITE TO LOCAL DB (The "Cached" Truth)
      final bool isSuspended = schoolResponse?['is_suspended'] ?? false;
      final bool isBillingEngine = deviceResponse?['is_active'] ?? false;

      // Update Local School Record
      await _db.db.execute(
        'UPDATE schools SET is_suspended = ? WHERE id = ?',
        [isSuspended ? 1 : 0, schoolId],
      );

      // Upsert into local_security_config table
      // Using INSERT OR REPLACE for each key-value pair
      await _db.db.execute(
        'INSERT OR REPLACE INTO local_security_config (key, value, updated_at) VALUES (?, ?, ?)',
        ['is_suspended', isSuspended ? 'true' : 'false', DateTime.now().toIso8601String()],
      );

      await _db.db.execute(
        'INSERT OR REPLACE INTO local_security_config (key, value, updated_at) VALUES (?, ?, ?)',
        ['is_billing_engine', isBillingEngine ? 'true' : 'false', DateTime.now().toIso8601String()],
      );

      debugPrint("✅ Pull Once: Security rules updated locally. Suspended: $isSuspended, Engine: $isBillingEngine");

    } catch (e) {
      debugPrint("⚠️ Pull Once Failed (Offline?): Using existing local rules. Error: $e");
      // We DO NOT crash. We allow the app to run on old rules.
    }
  }

  /// Optional: Force re-pull of security rules (call if needed)
  Future<void> refreshSecurityRules(String schoolId, String deviceId) async {
    await pullSecurityRules(schoolId, deviceId);
  }
}

// ==========================================
// FILE: ./services/billing_suspension_service.dart
// ==========================================

/// ============================================================================
/// BILLING SUSPENSION SERVICE - CORE SUSPENSION LOGIC
/// ============================================================================
///
/// This service handles all billing suspension operations including:
/// - Suspending billing (globally or scoped)
/// - Resuming billing with backbill calculations
/// - Checking suspension status
/// - Audit logging
/// - Scope filtering (students, grades, fee types)
///
/// Author: Nyasha Gabriel / Batch Tech
/// Date: January 3, 2026
/// Status: Production-Ready
library billing_suspension_service;

import 'package:supabase_flutter/supabase_flutter.dart';
import 'package:flutter/foundation.dart';

// ============================================================================
// ENUMS & TYPES
// ============================================================================

enum SuspensionStatus {
  active('active', 'Active'),
  completed('completed', 'Completed'),
  cancelled('cancelled', 'Cancelled');

  final String code;
  final String display;
  const SuspensionStatus(this.code, this.display);

  static SuspensionStatus fromCode(String code) =>
      SuspensionStatus.values.firstWhere(
        (e) => e.code == code,
        orElse: () => SuspensionStatus.active,
      );
}

enum SuspensionScopeType {
  global('global', 'All Students'),
  students('students', 'Specific Students'),
  grades('grades', 'Grade Levels'),
  feeTypes('fee_types', 'Fee Types');

  final String code;
  final String display;
  const SuspensionScopeType(this.code, this.display);

  static SuspensionScopeType fromCode(String code) =>
      SuspensionScopeType.values.firstWhere(
        (e) => e.code == code,
        orElse: () => SuspensionScopeType.global,
      );
}

enum AuditAction {
  suspend('suspend', 'Billing Suspended'),
  resume('resume', 'Billing Resumed'),
  backbill('backbill', 'Backbilling Applied'),
  configChange('config_change', 'Configuration Changed'),
  switchProcessing('switch_processing', 'Plan Switch Processed'),
  adjustment('adjustment', 'Manual Adjustment'),
  correction('manual_correction', 'Manual Correction');

  final String code;
  final String display;
  const AuditAction(this.code, this.display);

  static AuditAction fromCode(String code) =>
      AuditAction.values.firstWhere(
        (e) => e.code == code,
        orElse: () => AuditAction.suspend,
      );
}

// ============================================================================
// DATA MODELS
// ============================================================================

class BillingSuppressionScope {
  final SuspensionScopeType type;
  final List<String> values; // student IDs, grade names, or fee type codes

  BillingSuppressionScope({
    required this.type,
    this.values = const [],
  });

  bool appliesTo({
    String? studentId,
    String? gradeLevel,
    String? feeType,
  }) {
    switch (type) {
      case SuspensionScopeType.global:
        return true; // Applies to everything
      case SuspensionScopeType.students:
        return studentId != null && values.contains(studentId);
      case SuspensionScopeType.grades:
        return gradeLevel != null && values.contains(gradeLevel);
      case SuspensionScopeType.feeTypes:
        return feeType != null && values.contains(feeType);
    }
  }

  Map<String, dynamic> toJson() => {
        'type': type.code,
        'values': values,
      };

  factory BillingSuppressionScope.fromJson(Map<String, dynamic> json) =>
      BillingSuppressionScope(
        type: SuspensionScopeType.fromCode(json['type'] as String),
        values: List<String>.from(json['values'] as List? ?? []),
      );
}

// ============================================================================
// NOTE ON CLIENT-SIDE MODELS
// ============================================================================
// 
// SuspensionPeriod and BillingAuditEntry models are INTENTIONALLY EXCLUDED
// from this file per SECURE_BILLING_ENGINE_ARCHITECTURE.md
// 
// These tables contain critical financial state and must NEVER be:
// - Synced via PowerSync
// - Accessed directly from client code
// - Stored in local model classes
// 
// Access these tables ONLY via:
// 1. RPC functions (server-side validation)
// 2. Realtime subscriptions (online-only)
// 3. Read-only REST queries (admin portal)
// 
// All client-side business logic must work with suspension STATUS (boolean),
// not suspension PERIODS (full data). See BillingSuppressionStatusData class
// below for UI-safe data structures.
// ============================================================================

/// UI-safe representation of billing suspension status
/// 
/// This class contains ONLY the information needed for billing logic:
/// - Whether billing is suspended (boolean)
/// - When it was suspended (timestamp)
/// - The reason (for UI display)
/// 
/// It does NOT contain the full suspension period record, which stays
/// server-side only per the security architecture.
class BillingSuppressionStatusData {
  final bool isSuspended;
  final DateTime? suspendedSince;
  final String? reason;
  final DateTime? resumesOn;

  const BillingSuppressionStatusData({
    required this.isSuspended,
    this.suspendedSince,
    this.reason,
    this.resumesOn,
  });

  factory BillingSuppressionStatusData.fromMap(Map<String, dynamic> map) =>
      BillingSuppressionStatusData(
        isSuspended: (map['is_suspended'] as bool?) ?? false,
        suspendedSince: map['suspended_since'] != null
            ? DateTime.parse(map['suspended_since'] as String)
            : null,
        reason: map['reason'] as String?,
        resumesOn: map['resumes_on'] != null
            ? DateTime.parse(map['resumes_on'] as String)
            : null,
      );

  factory BillingSuppressionStatusData.notSuspended() =>
      const BillingSuppressionStatusData(isSuspended: false);
}

// ============================================================================
// MAIN BILLING SUSPENSION SERVICE
// ============================================================================

class BillingSuppressionService {
  final SupabaseClient supabase;
  final String schoolId;
  final String userId;

  BillingSuppressionService({
    required this.supabase,
    required this.schoolId,
    required this.userId,
  });

  /// Suspend billing for the school
  /// 
  /// ✅ SECURE: Uses RPC function for server-side validation
  /// ✅ Prevents direct table access
  /// ✅ Enforces engine assignment requirement
  /// 
  /// Parameters:
  /// - [reason]: Required reason for suspension
  /// - [scope]: Who suspension applies to (default: global/everyone)
  /// - [customNote]: Optional additional details
  /// 
  /// Returns: true if suspension successful
  Future<bool> suspendBilling({
    required String reason,
    BillingSuppressionScope? scope,
    String? customNote,
  }) async {
    try {
      final actualScope = scope ?? _globalScope();

      // ✅ CORRECT: All mutations via RPC (server-side validation)
      final response = await supabase.rpc(
        'suspend_billing',
        params: {
          'p_school_id': schoolId,
          'p_user_id': userId,
          'p_reason': reason,
          'p_custom_note': customNote,
          'p_scope': actualScope.toJson(),
        },
      );

      return response != null;
    } on PostgrestException catch (e) {
      if (e.code == 'NOENG') {
        debugPrintError('No active billing engine assigned to school');
      } else if (e.code == 'PERMS') {
        debugPrintError('User lacks permission to suspend billing');
      }
      return false;
    } catch (e) {
      debugPrintError('Error suspending billing: $e');
      return false;
    }
  }

  /// Resume billing for the school
  /// 
  /// ✅ SECURE: Uses RPC function for server-side validation
  /// ✅ Only billing engine can resume
  /// ✅ Automatic audit logging on server
  /// 
  /// Returns: true if resume successful
  Future<bool> resumeBilling() async {
    try {
      // ✅ CORRECT: RPC call with engine validation
      final response = await supabase.rpc(
        'resume_billing',
        params: {
          'p_school_id': schoolId,
          'p_user_id': userId,
        },
      );

      return response != null;
    } on PostgrestException catch (e) {
      if (e.code == 'NOENG') {
        debugPrintError('No active billing engine assigned to school');
      } else if (e.code == 'NSUSP') {
        debugPrintError('No active suspension to resume');
      }
      return false;
    } catch (e) {
      debugPrintError('Error resuming billing: $e');
      return false;
    }
  }

  /// Check if billing is currently suspended
  /// 
  /// Returns: true if active suspension exists, false otherwise
  Future<bool> isBillingSuspended() async {
    try {
      final response = await supabase.rpc(
        'is_billing_suspended',
        params: {'p_school_id': schoolId},
      );

      return response as bool;
    } catch (e) {
      debugPrintError('Error checking billing suspension: $e');
      return false;
    }
  }

  /// Check if billing is currently suspended for this school
  /// 
  /// ✅ SECURE: Uses RPC function for server-side check
  /// ✅ Does not expose suspension period details
  /// ✅ Returns status only, not sensitive period data
  /// 
  /// Returns: true if active suspension exists
  Future<bool> getActiveSuspensions() async {
    try {
      final response = await supabase.rpc(
        'is_billing_suspended',
        params: {'p_school_id': schoolId},
      );

      return (response as bool?) ?? false;
    } catch (e) {
      debugPrintError('Error checking active suspensions: $e');
      return false;
    }
  }

  /// Check if billing applies to a specific student
  /// 
  /// ✅ SECURE: Uses RPC function with scope checking
  /// ✅ Server performs all filtering logic
  /// 
  /// Parameters:
  /// - [studentId]: Student to check
  /// - [gradeLevel]: Grade level of student (optional)
  /// - [feeType]: Fee type being billed (optional)
  /// 
  /// Returns: false if billing is suspended for this student, true otherwise
  Future<bool> isBillingAppliedToStudent({
    required String studentId,
    String? gradeLevel,
    String? feeType,
  }) async {
    try {
      // Use RPC to check if billing applies to this specific student
      final response = await supabase.rpc(
        'is_billing_applied_to_student',
        params: {
          'p_school_id': schoolId,
          'p_student_id': studentId,
          'p_grade_level': gradeLevel,
          'p_fee_type': feeType,
        },
      );

      return (response as bool?) ?? true; // Default to billing enabled on error
    } catch (e) {
      debugPrintError('Error checking student billing status: $e');
      return true; // Default to billing enabled on error
    }
  }

  /// Get suspension summary for UI display
  /// 
  /// ✅ SECURE: Returns status only, via RPC
  /// ✅ Does not expose detailed suspension period data
  /// 
  /// Returns: Formatted map with suspension status
  Future<Map<String, dynamic>> getSuspensionSummary() async {
    try {
      final isSuspended = await getActiveSuspensions();

      return {
        'is_suspended': isSuspended,
        'status_text': isSuspended ? 'Billing is suspended' : 'Billing is active',
      };
    } catch (e) {
      debugPrintError('Error getting suspension summary: $e');
      return {'is_suspended': false};
    }
  }

  /// Calculate days suspended for backbilling purposes
  /// 
  /// ✅ SECURE: Uses RPC function for calculation
  /// ✅ Server maintains accuracy of calculations
  /// 
  /// Returns: Number of days suspended
  Future<int> calculateSuspensionDays() async {
    try {
      final response = await supabase.rpc(
        'calculate_suspension_days',
        params: {'p_school_id': schoolId},
      );

      return (response as int?) ?? 0;
    } catch (e) {
      debugPrintError('Error calculating suspension days: $e');
      return 0;
    }
  }

  /// Get audit log for school (admin/read-only access)
  /// 
  /// ✅ SECURE: Uses RPC function for audit log retrieval
  /// ✅ Server enforces admin-only access via RLS
  /// ✅ Returns raw maps - no client-side models for sensitive data
  /// 
  /// Returns: List of audit entries as maps
  Future<List<Map<String, dynamic>>> getAuditLog({
    int limit = 50,
    String? filterAction,
  }) async {
    try {
      final response = await supabase.rpc(
        'get_billing_audit_log',
        params: {
          'p_school_id': schoolId,
          'p_limit': limit,
          'p_action_filter': filterAction,
        },
      );

      return List<Map<String, dynamic>>.from(response as List? ?? []);
    } catch (e) {
      debugPrintError('Error fetching audit log: $e');
      return [];
    }
  }

  // ========================================================================
  // PRIVATE HELPERS
  // ========================================================================

  BillingSuppressionScope _globalScope() => BillingSuppressionScope(
        type: SuspensionScopeType.global,
        values: [],
      );

  // NOTE: Audit logging is handled automatically by server-side triggers
  // All suspension operations are logged automatically when RPC functions
  // are executed. No client-side logging action is needed.
}

// ============================================================================
// DEBUG HELPER FUNCTION
// ============================================================================

void debugPrintError(String message) {
  if (kDebugMode) {
    debugPrint('[BILLING ERROR] $message');
  }
}

// ==========================================
// FILE: ./services/device_authority_service.dart
// ==========================================

import 'package:device_info_plus/device_info_plus.dart';
import 'package:flutter/foundation.dart';

import 'database_service.dart';

/// 🔒 DEVICE AUTHORITY SERVICE (Offline Enforcer)
///
/// This service reads ONLY from the Local Database.
/// It does not care if the internet is on or off.
///
/// Security rules are pulled ONCE by SecuritySyncService and stored locally.
/// This service only enforces what's already cached.
///
/// Enforces the "One Billing Engine Per School" constraint:
/// - Only one device per school can perform financial mutations
/// - All other devices are read-only for financial data
class DeviceAuthorityService {
  static final DeviceAuthorityService _instance =
      DeviceAuthorityService._internal();

  factory DeviceAuthorityService() => _instance;
  DeviceAuthorityService._internal();

  late String _deviceId;
  bool _isInitialized = false;
  final DeviceInfoPlugin _deviceInfo = DeviceInfoPlugin();
  final DatabaseService _db = DatabaseService();

  Future<void> initialize() async {
    if (_isInitialized) return;

    try {
      _deviceId = await _getDeviceId();
      _isInitialized = true;
      if (kDebugMode) {
        debugPrint("🆔 Device ID: $_deviceId");
      }
    } catch (e) {
      debugPrint("❌ Device Init Error: $e");
      _deviceId = "unknown_device";
    }
  }

  /// Get unique device identifier
  /// - Android: AndroidId
  /// - iOS: UUID from UIDevice
  /// - Desktop: Constant ID for dev stability
  /// - Web: Browser fingerprint (hostname-based)
  Future<String> _getDeviceId() async {
    // DEV BYPASS: For Windows/macOS, return constant ID
    if (kDebugMode &&
        (defaultTargetPlatform == TargetPlatform.windows ||
            defaultTargetPlatform == TargetPlatform.macOS)) {
      return 'dev-pc-id';
    }

    try {
      if (defaultTargetPlatform == TargetPlatform.android) {
        final androidInfo = await _deviceInfo.androidInfo;
        return androidInfo.id;
      } else if (defaultTargetPlatform == TargetPlatform.iOS) {
        final iosInfo = await _deviceInfo.iosInfo;
        return iosInfo.identifierForVendor ?? 'unknown-ios';
      } else {
        return 'generic-device';
      }
    } catch (e) {
      debugPrint("❌ Error getting device ID: $e");
      return 'unknown-device-${DateTime.now().millisecondsSinceEpoch}';
    }
  }

  /// Check if this device is the billing engine for the given school.
  /// READS LOCAL DB ONLY (no Supabase calls).
  ///
  /// Returns true if:
  /// 1. Local cache says this device is the billing engine
  /// 2. Device dev bypass is enabled
  Future<bool> isBillingEngineForSchool(String schoolId) async {
    if (!_isInitialized) await initialize();

    // 1. Dev Bypass (Keep this for speed)
    if (kDebugMode) return true;

    try {
      // 2. Read from the local config cache populated by SecuritySyncService
      final result = await _db.db.getAll(
          "SELECT value FROM local_security_config WHERE key = 'is_billing_engine' LIMIT 1");

      if (result.isNotEmpty) {
        return result.first['value'] == 'true';
      }

      // 3. Fallback: If no config found (fresh install, offline), default to SAFE mode (False)
      return false;
    } catch (e) {
      debugPrint("⚠️ Authority Check Error: $e");
      return false;
    }
  }

  /// Get the current active billing engine device for a school
  /// READS LOCAL DB ONLY
  Future<Map<String, dynamic>?> getActiveBillingEngineForSchool(
      String schoolId) async {
    try {
      if (!_isInitialized) await initialize();

      final result = await _db.db.getAll(
        'SELECT * FROM billing_engine_registry '
        'WHERE school_id = ? AND is_active = 1 '
        'LIMIT 1',
        [schoolId],
      );

      return result.isNotEmpty ? result.first : null;
    } catch (e) {
      debugPrint("❌ Error getting active billing engine: $e");
      return null;
    }
  }

  /// Register this device as the billing engine for a school
  /// This writes to LOCAL DB immediately, then syncs to cloud via PowerSync
  Future<void> registerAsActiveBillingEngine(
    String schoolId,
    String userId,
  ) async {
    try {
      if (!_isInitialized) await initialize();

      final now = DateTime.now().toIso8601String();

      // First, deactivate any existing billing engines for this school
      await _db.db.execute(
        'UPDATE billing_engine_registry SET is_active = 0 '
        'WHERE school_id = ?',
        [schoolId],
      );

      // Then register this device as active
      final deviceName = await _getDeviceName();
      await _db.db.execute(
        'INSERT INTO billing_engine_registry (id, school_id, device_id, device_name, user_id, is_active, activated_at, last_sync_at, created_at, updated_at) '
        'VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)',
        [
          _generateId(),
          schoolId,
          _deviceId,
          deviceName,
          userId,
          1,
          now,
          now,
          now,
          now,
        ],
      );

      // Update local security config
      await _db.db.execute(
        'INSERT OR REPLACE INTO local_security_config (key, value, updated_at) VALUES (?, ?, ?)',
        ['is_billing_engine', 'true', now],
      );

      if (kDebugMode) {
        debugPrint(
            "✅ Registered device as billing engine for school: $schoolId");
      }
    } catch (e) {
      debugPrint("❌ Error registering as billing engine: $e");
      rethrow;
    }
  }

  /// Deactivate this device as the billing engine
  /// (Used when transferring authority to another device)
  Future<void> deactivateAsBillingEngine(String schoolId) async {
    try {
      if (!_isInitialized) await initialize();

      final now = DateTime.now().toIso8601String();

      await _db.db.execute(
        'UPDATE billing_engine_registry SET is_active = 0 '
        'WHERE school_id = ? AND device_id = ?',
        [schoolId, _deviceId],
      );

      // Update local security config
      await _db.db.execute(
        'INSERT OR REPLACE INTO local_security_config (key, value, updated_at) VALUES (?, ?, ?)',
        ['is_billing_engine', 'false', now],
      );

      if (kDebugMode) {
        debugPrint(
            "✅ Deactivated device as billing engine for school: $schoolId");
      }
    } catch (e) {
      debugPrint("❌ Error deactivating billing engine: $e");
      rethrow;
    }
  }

  /// Get device name for display purposes
  Future<String> _getDeviceName() async {
    try {
      if (defaultTargetPlatform == TargetPlatform.android) {
        final androidInfo = await _deviceInfo.androidInfo;
        return '${androidInfo.manufacturer} ${androidInfo.model}';
      } else if (defaultTargetPlatform == TargetPlatform.iOS) {
        final iosInfo = await _deviceInfo.iosInfo;
        return iosInfo.model;
      } else {
        return 'Web/Desktop Device';
      }
    } catch (e) {
      return 'Unknown Device';
    }
  }

  String _generateId() => DateTime.now().millisecondsSinceEpoch.toString();

  // Getters
  String get currentDeviceId => _deviceId;
  bool get isInitialized => _isInitialized;
}

// ==========================================
// FILE: ./services/schema.dart
// ==========================================

import 'package:powersync/powersync.dart';

/// The Local SQLite Schema matching the Supabase Postgres Schema
/// based on the Fees Up Rules.
const Schema appSchema = Schema([
  // ============================================================
  // CORE SCHOOL DATA
  // ============================================================
  Table('schools', [
    Column.text('name'),
    Column.text('subscription_tier'),
    Column.integer('max_students'),
    Column.integer('is_suspended'),
    Column.integer('billing_suspended'),
    Column.text('last_billing_resume_date'),
    Column.text('contact_info'), // JSON blob: address, email, phone, logo
    Column.text('notification_prefs'), // JSON blob for notification settings
    Column.text('logo_url'),
    Column.text('created_at'),
  ]),

  Table('user_profiles', [
    Column.text('email'),
    Column.text('full_name'),
    Column.text('role'),
    Column.text('school_id'),
    Column.integer('is_banned'),
    Column.text('avatar_url'),
    Column.text('created_at'),
  ]),

  Table('notifications', [
    Column.text('user_id'),
    Column.text('school_id'),
    Column.text('title'),
    Column.text('body'),
    Column.text('type'),
    Column.integer('is_read'),
    Column.text('created_at'),
  ]),

  // ============================================================
  // LOCAL SECURITY CONFIG (Pull Once Protocol)
  // ============================================================
  Table('local_security_config', [
    Column.text('key'), // Unique key for the config value
    Column.text('value'), // The cached security rule value
    Column.text('updated_at'), // When it was last pulled from cloud
  ]),

  // ============================================================
  // PEOPLE (Students, Teachers, Access)
  // ============================================================
  Table('students', [
    Column.text('school_id'),
    Column.text('student_id'),
    Column.text('full_name'),
    Column.text('grade'),
    Column.text('parent_contact'),
    Column.text('registration_date'),
    Column.text('billing_type'),
    Column.real('default_fee'),
    Column.integer('is_active'),
    Column.text('admin_uid'),
    Column.real('owed_total'),
    Column.real('paid_total'),
    Column.text('subjects'),
    Column.text('billing_date'),
    Column.text('last_synced_at'),
    Column.text('term_id'),
    Column.text('date_of_birth'),
    Column.text('gender'),
    Column.text('address'),
    Column.text('emergency_contact_name'),
    Column.text('medical_notes'),
    Column.text('enrollment_date'),
    Column.integer('photo_consent'),
    Column.text('updated_at'),
    Column.text('created_at'),
  ]),

  Table('teachers', [
    Column.text('school_id'),
    Column.text('full_name'),
    Column.text('admin_uid'),
    Column.text('created_at'),
    Column.text('updated_at'),
  ]),

  Table('teacher_access_tokens', [
    Column.text('school_id'),
    Column.text('teacher_id'),
    Column.text('granted_by_teacher_id'),
    Column.text('access_code'),
    Column.text('permission_type'),
    Column.integer('is_used'),
    Column.text('used_at'),
    Column.text('expires_at'),
    Column.text('created_at'),
  ]),

  // ============================================================
  // ACADEMICS (Classes, Enrollment, Terms)
  // ============================================================
  Table('classes', [
    Column.text('school_id'),
    Column.text('name'),
    Column.text('teacher_id'),
    Column.text('room_number'),
    Column.text('subject_code'),
    Column.text('admin_uid'),
    Column.text('created_at'),
  ]),

  Table('enrollments', [
    Column.text('school_id'),
    Column.text('student_id'),
    Column.text('class_id'),
    Column.text('enrolled_at'),
    Column.text('created_at'),
  ]),

  Table('school_years', [
    Column.text('school_id'),
    Column.text('year_label'),
    Column.text('start_date'),
    Column.text('end_date'),
    Column.text('description'),
    Column.integer('active'),
    Column.text('created_at'),
  ]),

  Table('school_year_months', [
    Column.text('school_year_id'),
    Column.text('school_id'),
    Column.text('name'),
    Column.integer('month_index'),
    Column.text('start_date'),
    Column.text('end_date'),
    Column.integer('is_billable'),
    Column.text('term_id'),
    Column.text('created_at'),
  ]),

  Table('school_terms', [
    Column.text('school_id'),
    Column.text('school_year_id'),
    Column.text('name'),
    Column.text('start_date'),
    Column.text('end_date'),
    Column.integer('academic_year'),
    Column.text('created_at'),
  ]),

  // ============================================================
  // ATTENDANCE
  // ============================================================
  Table('attendance', [
    Column.text('school_id'),
    Column.text('student_id'),
    Column.text('class_id'),
    Column.text('date'),
    Column.text('status'),
    Column.text('remarks'),
    Column.text('recorded_by'),
    Column.text('created_at'),
  ]),

  Table('attendance_sessions', [
    Column.text('school_id'),
    Column.text('class_id'),
    Column.text('teacher_id'),
    Column.text('student_admin_id'),
    Column.text('access_token_id'),
    Column.text('session_date'),
    Column.integer('is_confirmed_by_teacher'),
    Column.text('confirmed_at'),
    Column.text('created_at'),
  ]),

  // ============================================================
  // FINANCE (Billing, Payments, Expenses)
  // ============================================================
  Table('billing_configs', [
    Column.text('school_id'),
    Column.text('currency_code'),
    Column.real('tax_rate_percentage'),
    Column.real('late_fee_percentage'),
    Column.real('registration_fee'),
    Column.integer('grace_period_days'),
    Column.text('invoice_footer_note'),
    Column.integer(
        'allow_partial_payments'), // boolean in Postgres, stored as 1/0 locally
    Column.real('default_fee'),
    Column.text('invoice_prefix'),
    Column.integer('invoice_sequence_seed'),
    Column.text('updated_at'),
  ]),

  Table('bills', [
    Column.text('school_id'),
    Column.text('student_id'),
    Column.text('title'),

    // --- NEW COLUMNS FOR INVOICING ---
    Column.text('invoice_number'), // e.g. "INV-00231"
    Column.text('status'), // e.g. "draft", "sent", "paid", "overdue"
    Column.text('pdf_url'), // Link to Supabase Storage bucket
    // ---------------------------------

    Column.real('total_amount'),
    Column.integer('is_paid'), // Keep for backward compatibility/quick checks
    Column.text('bill_type'),
    Column.text('billing_cycle_end'),
    Column.text('billing_cycle_start'),
    Column.real('paid_amount'), // Cache for performance
    Column.text('term_id'),
    Column.text('month_year'),
    Column.text('due_date'),
    Column.text('cycle_interval'),
    Column.integer('is_closed'),
    Column.real('credited_amount'),
    Column.text('school_year_id'),
    Column.integer('month_index'),
    Column.text('updated_at'),
    Column.text('created_at'),
  ]),

  Table('bill_items', [
    Column.text('bill_id'),
    Column.text('school_id'),
    Column.text('description'),
    Column.real('amount'),
    Column.integer('quantity'),
    Column.text('created_at'),
  ]),

  Table('payments', [
    Column.text('school_id'),
    Column.text('student_id'),
    Column.real('amount'),
    Column.text('date_paid'),
    Column.text('category'),
    Column.text('payer_name'),
    Column.text('bill_id'),
    Column.text('method'),
    Column.text('admin_uid'),
    Column.text('created_at'),
  ]),

  Table('payment_allocations', [
    Column.text('payment_id'),
    Column.text('bill_id'),
    Column.text('school_id'),
    Column.real('amount'),
    Column.text('created_at'),
  ]),

  Table('credits', [
    Column.text('credit_id'),
    Column.text('school_id'),
    Column.text('student_id'),
    Column.text('bill_id'),
    Column.real('amount'),
    Column.text('reason'),
    Column.text('admin_uid'),
    Column.text('created_at'),
  ]),

  Table('expenses', [
    Column.text('school_id'),
    Column.text('title'),
    Column.real('amount'),
    Column.text('category'),
    Column.text('incurred_at'),
    Column.text('description'),
    Column.text('recipient'),
    Column.text('created_at'),
  ]),

  // ============================================================
  // FUNDRAISER & AUDIT
  // ============================================================
  // NOTE: billing_suspension_periods, billing_audit_log, and
  // billing_extensions are INTENTIONALLY EXCLUDED from PowerSync schema.
  // These tables contain critical financial state that must remain
  // server-side only with single-source-of-truth enforcement.
  // Access via Supabase Realtime (online-only) or RPC functions only.
  // See: SECURE_BILLING_ENGINE_ARCHITECTURE.md
  // ============================================================
  Table('campaigns', [
    Column.text('school_id'),
    Column.text('class_id'),
    Column.text('created_by_id'),
    Column.text('teacher_id'),
    Column.text('name'),
    Column.text('description'),
    Column.text('campaign_type'),
    Column.text('status'),
    Column.real('goal_amount'),
    Column.text('created_at'),
  ]),

  Table('campaign_donations', [
    Column.text('campaign_id'),
    Column.text('school_id'),
    Column.text('donor_name'),
    Column.real('amount'),
    Column.text('payment_method'),
    Column.text('date_received'),
    Column.text('notes'),
    Column.text('student_id'),
    Column.text('collected_by'),
    Column.text('approved_by'),
    Column.real('expected_cash'),
    Column.real('actual_cash'),
    Column.real('variance'),
    Column.text('updated_at'),
    Column.text('created_at'),
  ]),

  Table('campaign_expenses', [
    Column.text('campaign_id'),
    Column.text('school_id'),
    Column.text('category'),
    Column.real('amount'),
    Column.text('incurred_by'),
    Column.text('approved_by'),
    Column.text('notes'),
    Column.text('created_at'),
  ]),

  Table('campaign_funds', [
    Column.text('campaign_id'),
    Column.text('school_id'),
    Column.text('fund_name'),
    Column.integer('restricted'),
    Column.real('balance'),
    Column.text('updated_at'),
  ]),

  Table('banking_register', [
    Column.text('campaign_id'),
    Column.text('student_id'),
    Column.real('amount'),
    Column.text('direction'),
    Column.text('recorded_by'),
    Column.text('approved_by'),
    Column.text('reference'),
    Column.text('school_id'),
    Column.text('created_at'),
  ]),

  // ============================================================
  // ARCHIVES
  // ============================================================
  Table('student_archives', [
    Column.text('school_id'),
    Column.text('full_name'),
    Column.text('reason'),
    Column.text('archived_at'),
    Column.text('original_data'),
    Column.text('created_at'),
  ]),
]);

// ==========================================
// FILE: ./services/transaction_service.dart
// ==========================================

import 'package:intl/intl.dart';
import 'package:supabase_flutter/supabase_flutter.dart';
import 'package:uuid/uuid.dart';

import '../../core/errors/billing_exceptions.dart';
import 'device_authority_service.dart';
import 'database_service.dart';

/// 🔒 SECURE Transaction Processing Engine
/// Handles payment allocation, partial payments, and refunds
/// All operations support offline-first via PowerSync
/// 🔒 Only the billing engine device can record payments and allocate them
class TransactionService {
  final SupabaseClient supabase;
  final DeviceAuthorityService _deviceAuthority;

  TransactionService({required this.supabase})
      : _deviceAuthority = DeviceAuthorityService();

  // ========== PAYMENT PROCESSING ==========

  /// ✅ SECURE: Record payment with optional bill allocation
  /// Supports:
  /// - Full payment to single bill
  /// - Partial payment to single bill
  /// - Payment allocated across multiple bills
  /// 🔒 Only billing engine device can record payments
  Future<String> recordPayment({
    required String schoolId,
    required String studentId,
    required double amount,
    required String method, // 'Cash', 'Bank Transfer', 'Mobile Money', 'Cheque'
    required String
        category, // 'Tuition', 'Uniform', 'Levy', 'Transport', 'Donation'
    required DateTime datePaid,
    required String userId, // Required for RLS compliance
    String? payerName,
    String? description,
  }) async {
    // ✅ Check device authority
    final isBillingEngine =
        await _deviceAuthority.isBillingEngineForSchool(schoolId);
    if (!isBillingEngine) {
      throw BillingEnginePermissionException(
          'This device is not the billing engine for $schoolId. '
          'Only the billing engine device can record payments.');
    }

    try {
      final paymentId = const Uuid().v4();
      final now = DateTime.now();

      // Create payment record
      final paymentData = {
        'id': paymentId,
        'school_id': schoolId,
        'student_id': studentId,
        'amount': amount,
        'method': method,
        'category': category,
        'date_paid': DateFormat('yyyy-MM-dd').format(datePaid),
        'payer_name': payerName,
        'description': description,
        'user_id': userId, // ✅ Required for RLS compliance
        'device_id': _deviceAuthority
            .currentDeviceId, // ✅ Track which device recorded it
        'created_at': now.toIso8601String(),
        'updated_at': now.toIso8601String(),
      };

      // ✅ Use PowerSync for offline-first write
      final db = DatabaseService();
      await db.insert('payments', paymentData);

      // Trigger audit logging via server-side function (similar to billing suspension)
      try {
        await supabase.rpc('log_payment_action', params: {
          'p_payment_id': paymentId,
          'p_school_id': schoolId,
          'p_action': 'payment_recorded',
          'p_amount': amount,
          'p_user_id': userId,
          'p_device_id': _deviceAuthority.currentDeviceId,
        });
      } catch (e) {
        // Log call is non-critical
        debugPrintError('Payment audit log failed: $e');
      }

      return paymentId;
    } catch (e) {
      rethrow;
    }
  }

  // ========== PAYMENT ALLOCATION ==========

  /// ✅ NEW: Allocate payment to specific bills
  /// Enables partial payment tracking and bill-level payment status
  /// 🔒 Only billing engine device can allocate payments
  Future<void> allocatePaymentToBill({
    required String schoolId,
    required String paymentId,
    required String billId,
    required double allocatedAmount,
  }) async {
    // ✅ Check device authority
    final isBillingEngine =
        await _deviceAuthority.isBillingEngineForSchool(schoolId);
    if (!isBillingEngine) {
      throw BillingEnginePermissionException(
          'This device is not the billing engine for $schoolId. '
          'Only the billing engine device can allocate payments.');
    }

    try {
      final allocationId = const Uuid().v4();

      // Create payment allocation record
      final allocationData = {
        'id': allocationId,
        'payment_id': paymentId,
        'bill_id': billId,
        'school_id': schoolId,
        'amount': allocatedAmount,
        'device_id': _deviceAuthority.currentDeviceId,
        'created_at': DateTime.now().toIso8601String(),
      };

      // ✅ Use PowerSync for offline-first write
      final db = DatabaseService();
      await db.insert('payment_allocations', allocationData);

      // Update bill paid_amount
      await _updateBillPaidAmount(billId, allocatedAmount);
    } catch (e) {
      rethrow;
    }
  }

  /// Allocate a payment across multiple bills (partial payment support)
  Future<void> allocatePaymentToMultipleBills({
    required String schoolId,
    required String paymentId,
    required List<MapEntry<String, double>> billAllocations,
    // billAllocations: List of MapEntry<billId, allocatedAmount>
  }) async {
    try {
      for (final allocation in billAllocations) {
        await allocatePaymentToBill(
          schoolId: schoolId,
          paymentId: paymentId,
          billId: allocation.key,
          allocatedAmount: allocation.value,
        );
      }
    } catch (e) {
      rethrow;
    }
  }

  /// Get all allocations for a payment
  Future<List<Map<String, dynamic>>> getPaymentAllocations(
      String paymentId) async {
    try {
      final response = await supabase
          .from('payment_allocations')
          .select('id, bill_id, amount, created_at')
          .eq('payment_id', paymentId);

      return List<Map<String, dynamic>>.from(response);
    } catch (e) {
      rethrow;
    }
  }

  /// Get bills with outstanding balance for a student
  /// Shows how much is still owed per bill
  Future<List<Map<String, dynamic>>> getOutstandingBillsWithBalance(
      String studentId) async {
    try {
      final response =
          await supabase.rpc('get_outstanding_bills_with_balance', params: {
        'p_student_id': studentId,
      });

      return List<Map<String, dynamic>>.from(response);
    } catch (e) {
      rethrow;
    }
  }

  // ========== PARTIAL PAYMENT SUPPORT ==========

  /// ✅ NEW: Update bill paid amount and calculate remaining balance
  /// Automatically tracks if bill is fully paid
  Future<void> _updateBillPaidAmount(String billId, double addedAmount) async {
    try {
      final db = DatabaseService().db;

      // Get current bill state using PowerSync
      final billData = await db.getAll(
        'SELECT paid_amount, total_amount FROM bills WHERE id = ? LIMIT 1',
        [billId],
      );

      if (billData.isEmpty) {
        throw Exception('Bill not found: $billId');
      }

      final currentPaid = (billData[0]['paid_amount'] as num).toDouble();
      final totalAmount = (billData[0]['total_amount'] as num).toDouble();
      final newPaidAmount = currentPaid + addedAmount;
      final isFullyPaid = newPaidAmount >= totalAmount;

      // Update bill with new paid amount and status using PowerSync
      await db.execute(
        'UPDATE bills SET paid_amount = ?, is_paid = ?, status = ?, updated_at = ? WHERE id = ?',
        [
          newPaidAmount,
          isFullyPaid ? 1 : 0,
          isFullyPaid ? 'paid' : 'partial',
          DateTime.now().toIso8601String(),
          billId,
        ],
      );
    } catch (e) {
      rethrow;
    }
  }

  /// Calculate remaining balance for a bill
  Future<double> calculateBillBalance(String billId) async {
    try {
      final response = await supabase
          .from('bills')
          .select('paid_amount, total_amount')
          .eq('id', billId)
          .single();

      final paidAmount = (response['paid_amount'] as num).toDouble();
      final totalAmount = (response['total_amount'] as num).toDouble();

      return (totalAmount - paidAmount).clamp(0.0, totalAmount);
    } catch (e) {
      rethrow;
    }
  }

  /// Get payment allocation summary for a bill
  /// Shows total allocated, remaining, and allocation history
  Future<Map<String, dynamic>> getBillPaymentSummary(String billId) async {
    try {
      final response = await supabase.rpc('get_bill_payment_summary', params: {
        'p_bill_id': billId,
      });

      return response as Map<String, dynamic>;
    } catch (e) {
      rethrow;
    }
  }

  // ========== REFUND PROCESSING ==========

  /// ✅ NEW: Process refund for overpayment
  /// Creates reverse payment entry and adjusts bill status
  /// 🔒 Only billing engine device can process refunds
  Future<String> processRefund({
    required String originalPaymentId,
    required String studentId,
    required String schoolId,
    required double refundAmount,
    required String reason,
    required String refundMethod, // 'Cash', 'Bank Transfer', etc.
    required String userId, // Required for RLS compliance
    String? approvedBy,
  }) async {
    // ✅ Check device authority
    final isBillingEngine =
        await _deviceAuthority.isBillingEngineForSchool(schoolId);
    if (!isBillingEngine) {
      throw BillingEnginePermissionException(
          'This device is not the billing engine for $schoolId. '
          'Only the billing engine device can process refunds.');
    }

    try {
      final refundId = const Uuid().v4();
      final now = DateTime.now();

      // Create refund record (negative payment)
      final refundData = {
        'id': refundId,
        'school_id': schoolId,
        'student_id': studentId,
        'amount': -refundAmount, // Negative to indicate refund
        'method': refundMethod,
        'category': 'Refund',
        'date_paid': DateFormat('yyyy-MM-dd').format(now),
        'payer_name': 'School Refund',
        'description':
            'Refund for payment: $originalPaymentId. Reason: $reason',
        'original_payment_id': originalPaymentId,
        'refund_reason': reason,
        'approved_by': approvedBy,
        'user_id': userId, // ✅ Required for RLS compliance
        'device_id': _deviceAuthority.currentDeviceId,
        'created_at': now.toIso8601String(),
        'updated_at': now.toIso8601String(),
      };

      // ✅ Use PowerSync for offline-first write
      final db = DatabaseService();
      await db.insert('payments', refundData);

      // Log refund action
      try {
        await supabase.rpc('log_refund_action', params: {
          'p_refund_id': refundId,
          'p_school_id': schoolId,
          'p_original_payment_id': originalPaymentId,
          'p_amount': refundAmount,
          'p_reason': reason,
          'p_approved_by': approvedBy,
          'p_user_id': userId,
          'p_device_id': _deviceAuthority.currentDeviceId,
        });
      } catch (e) {
        debugPrintError('Refund audit log failed: $e');
      }

      return refundId;
    } catch (e) {
      rethrow;
    }
  }

  /// Reverse payment allocation (for refunded payments)
  Future<void> reversePaymentAllocation({
    required String allocationId,
    required String billId,
    required double allocationAmount,
  }) async {
    try {
      // Delete allocation
      await supabase
          .from('payment_allocations')
          .delete()
          .eq('id', allocationId);

      // Reduce bill paid amount
      await _reduceBillPaidAmount(billId, allocationAmount);
    } catch (e) {
      rethrow;
    }
  }

  /// Internal: Reduce paid amount (for refunds)
  Future<void> _reduceBillPaidAmount(String billId, double deductAmount) async {
    try {
      final db = DatabaseService().db;

      // Get current bill state using PowerSync
      final billData = await db.getAll(
        'SELECT paid_amount, total_amount FROM bills WHERE id = ? LIMIT 1',
        [billId],
      );

      if (billData.isEmpty) {
        throw Exception('Bill not found: $billId');
      }

      final currentPaid = (billData[0]['paid_amount'] as num).toDouble();
      final newPaidAmount =
          (currentPaid - deductAmount).clamp(0.0, double.infinity);
      final totalAmount = (billData[0]['total_amount'] as num).toDouble();
      final isFullyPaid = newPaidAmount >= totalAmount;

      // Update using PowerSync
      await db.execute(
        'UPDATE bills SET paid_amount = ?, is_paid = ?, status = ?, updated_at = ? WHERE id = ?',
        [
          newPaidAmount,
          isFullyPaid ? 1 : 0,
          isFullyPaid ? 'paid' : (newPaidAmount > 0 ? 'partial' : 'sent'),
          DateTime.now().toIso8601String(),
          billId,
        ],
      );
    } catch (e) {
      rethrow;
    }
  }

  /// Get refund history for a student
  Future<List<Map<String, dynamic>>> getRefundHistory(String studentId) async {
    try {
      final response = await supabase
          .from('payments')
          .select(
              'id, amount, date_paid, refund_reason, approved_by, original_payment_id')
          .eq('student_id', studentId)
          .lt('amount', 0) // Negative amounts are refunds
          .order('date_paid', ascending: false);

      return List<Map<String, dynamic>>.from(response);
    } catch (e) {
      rethrow;
    }
  }

  // ========== TRANSACTION HISTORY & REPORTING ==========

  /// Get all payments for a student with date range filtering
  Future<List<Map<String, dynamic>>> getPaymentHistory({
    required String studentId,
    DateTime? startDate,
    DateTime? endDate,
  }) async {
    try {
      final query = supabase.from('payments').select(
          'id, amount, method, category, date_paid, payer_name, created_at');

      var filtered = query.eq('student_id', studentId).gt('amount', 0);

      // Apply optional date filters inline
      final response = await (startDate != null && endDate != null
          ? filtered
              .gte('date_paid', DateFormat('yyyy-MM-dd').format(startDate))
              .lte('date_paid', DateFormat('yyyy-MM-dd').format(endDate))
              .order('date_paid', ascending: false)
          : startDate != null
              ? filtered
                  .gte('date_paid', DateFormat('yyyy-MM-dd').format(startDate))
                  .order('date_paid', ascending: false)
              : endDate != null
                  ? filtered
                      .lte(
                          'date_paid', DateFormat('yyyy-MM-dd').format(endDate))
                      .order('date_paid', ascending: false)
                  : filtered.order('date_paid', ascending: false));

      return List<Map<String, dynamic>>.from(response);
    } catch (e) {
      rethrow;
    }
  }

  /// Get transaction summary for school (dashboard)
  Future<Map<String, dynamic>> getTransactionSummary(String schoolId) async {
    try {
      final response = await supabase.rpc('get_transaction_summary', params: {
        'p_school_id': schoolId,
      });

      return response as Map<String, dynamic>;
    } catch (e) {
      rethrow;
    }
  }

  /// Reconcile payments with allocations (for auditing)
  Future<Map<String, dynamic>> reconcilePayments({
    required String schoolId,
    required DateTime startDate,
    required DateTime endDate,
  }) async {
    try {
      final response = await supabase.rpc('reconcile_payments', params: {
        'p_school_id': schoolId,
        'p_start_date': startDate.toIso8601String(),
        'p_end_date': endDate.toIso8601String(),
      });

      return response as Map<String, dynamic>;
    } catch (e) {
      rethrow;
    }
  }

  /// Get recent transactions for school (payments and expenses)
  Future<List<Map<String, dynamic>>> getSchoolTransactions(String schoolId,
      {int limit = 50}) async {
    try {
      final response = await supabase
          .from('payments')
          .select('*, students(name)')
          .eq('school_id', schoolId)
          .order('date_paid', ascending: false)
          .limit(limit);

      return List<Map<String, dynamic>>.from(response);
    } catch (e) {
      debugPrintError('Failed to fetch school transactions: $e');
      rethrow;
    }
  }
}

void debugPrintError(String message) {
  // TODO: Replace with proper logging service
  // Integrate with a logging framework like: Firebase Crashlytics, Sentry, or custom logger
  // ignore: avoid_print
  print('❌ ERROR: $message');
}

// ==========================================
// FILE: ./services/school_service.dart
// ==========================================

import 'dart:async';
import 'package:flutter/material.dart';
import 'package:uuid/uuid.dart';
import 'database_service.dart';
import 'package:supabase_flutter/supabase_flutter.dart';

class SchoolService {
  final DatabaseService _db;
  final _supabase = Supabase.instance.client;

  SchoolService(this._db);

  /// -----------------------------------------------------------------------
  /// REFRESH HELPER (Required by school_provider.dart)
  /// -----------------------------------------------------------------------
  Future<Map<String, dynamic>?> getSchoolForUser(String userId,
      {bool waitForSync = true}) async {
    Future<Map<String, dynamic>?> fetch() async {
      final profile = await _db
          .tryGet('SELECT school_id FROM user_profiles WHERE id = ?', [userId]);
      if (profile == null || profile['school_id'] == null) return null;

      return await _db
          .tryGet('SELECT * FROM schools WHERE id = ?', [profile['school_id']]);
    }

    final result = await fetch();
    if (result != null) return result;
    if (!waitForSync) return null;

    for (int i = 0; i < 10; i++) {
      await Future.delayed(const Duration(seconds: 1));
      final retryResult = await fetch();
      if (retryResult != null) return retryResult;
    }
    return null;
  }

  /// -----------------------------------------------------------------------
  /// CREATION HELPER
  /// -----------------------------------------------------------------------
  Future<String?> createSchool({
    required String adminId,
    required String schoolName,
    String tier = 'free',
  }) async {
    final schoolId = const Uuid().v4();
    final now = DateTime.now().toIso8601String();

    try {
      await _db.db.writeTransaction((tx) async {
        await tx.execute('''
          INSERT INTO schools (id, name, subscription_tier, max_students, is_suspended, created_at)
          VALUES (?, ?, ?, ?, ?, ?)
        ''', [schoolId, schoolName, tier, 100, 0, now]);

        await tx.execute('''
          UPDATE user_profiles SET school_id = ?, role = 'school_admin' WHERE id = ?
        ''', [schoolId, adminId]);

        await tx.execute('''
          INSERT INTO billing_configs (id, school_id, currency_code, late_fee_percentage, updated_at)
          VALUES (?, ?, ?, ?, ?)
        ''', [const Uuid().v4(), schoolId, 'USD', 0.0, now]);
      });

      return schoolId;
    } catch (e) {
      rethrow;
    }
  }

  Future<void> createSchoolWithDiagnostics(
    BuildContext context, {
    required String adminId,
    required String schoolName,
  }) async {
    try {
      await createSchool(adminId: adminId, schoolName: schoolName);
    } catch (e) {
      try {
        final response = await _supabase.rpc('debug_user_access', params: {
          'target_user_id': adminId,
        });

        final recommendation = response['recommendation'] ?? 'UNKNOWN_ERROR';

        if (context.mounted) {
          showProperChannelDialog(context, recommendation);
        }
      } catch (rpcError) {
        throw Exception("System is currently unreachable.");
      }
    }
  }

  /// -----------------------------------------------------------------------
  /// FORCE LOGOUT AND RE-AUTHENTICATE
  /// -----------------------------------------------------------------------
  Future<void> _forceLogoutAndReauth() async {
    await _db.factoryReset(); // Uses the new internal factoryReset
    await _supabase.auth.signOut();
  }

  void showProperChannelDialog(BuildContext context, String recommendation) {
    showDialog(
      context: context,
      barrierDismissible: false,
      builder: (context) => AlertDialog(
        backgroundColor: const Color(0xFF121212),
        title: const Text("System Alignment Required",
            style: TextStyle(color: Colors.blue)),
        content: Text(
          "Diagnostic Result: $recommendation\n\nTo resolve this, the app must restart your session.",
          style: const TextStyle(color: Colors.white70),
        ),
        actions: [
          TextButton(
            onPressed: () async {
              Navigator.pop(context);
              await _forceLogoutAndReauth();
            },
            child: const Text("RESET & RE-AUTHENTICATE",
                style: TextStyle(color: Colors.blue)),
          ),
        ],
      ),
    );
  }
}

// ==========================================
// FILE: ./models/transaction_stats.dart
// ==========================================

/// Transaction Statistics Data Model
class TransactionStats {
  final double totalIncome;
  final double totalExpenses;
  final double totalDonations;
  final int pendingCount;
  final double pendingAmount;
  final double netIncome;
  final int paymentsCount;
  final int expensesCount;
  final int donationsCount;

  TransactionStats({
    required this.totalIncome,
    required this.totalExpenses,
    required this.totalDonations,
    required this.pendingCount,
    required this.pendingAmount,
    required this.netIncome,
    required this.paymentsCount,
    required this.expensesCount,
    required this.donationsCount,
  });
}

// ==========================================
// FILE: ./models/core_models.dart
// ==========================================

class School {
  final String id;
  final String name;
  final String subscriptionTier; // 'free', 'basic', 'pro'
  final int maxStudents;
  final bool isSuspended;
  final DateTime createdAt;

  School({
    required this.id,
    required this.name,
    this.subscriptionTier = 'free',
    this.maxStudents = 50,
    this.isSuspended = false,
    required this.createdAt,
  });

  factory School.fromRow(Map<String, dynamic> row) {
    return School(
      id: row['id'] as String,
      name: row['name'] as String,
      subscriptionTier: row['subscription_tier'] ?? 'free',
      maxStudents: (row['max_students'] as num?)?.toInt() ?? 50,
      isSuspended: (row['is_suspended'] == 1),
      createdAt: DateTime.parse(row['created_at']),
    );
  }
}

class UserProfile {
  final String id;
  final String email;
  final String fullName;
  final String role; // 'super_admin', 'school_admin', 'teacher', 'student'
  final String? schoolId;
  final bool isBanned;
  final String? avatarUrl;

  UserProfile({
    required this.id,
    required this.email,
    required this.fullName,
    this.role = 'teacher',
    this.schoolId,
    this.isBanned = false,
    this.avatarUrl,
  });

  factory UserProfile.fromRow(Map<String, dynamic> row) {
    return UserProfile(
      id: row['id'] as String,
      email: row['email'] as String,
      fullName: row['full_name'] as String,
      role: row['role'] ?? 'teacher',
      schoolId: row['school_id'] as String?,
      isBanned: (row['is_banned'] == 1),
      avatarUrl: row['avatar_url'] as String?,
    );
  }
}

class BillingConfig {
  final String id;
  final String? schoolId;
  final String currencyCode;
  final double lateFeePercentage;
  final String? invoiceFooterNote;
  final bool allowPartialPayments;
  final double defaultFee;

  BillingConfig({
    required this.id,
    this.schoolId,
    this.currencyCode = 'USD',
    this.lateFeePercentage = 0.0,
    this.invoiceFooterNote,
    this.allowPartialPayments = true,
    this.defaultFee = 100.00,
  });

  factory BillingConfig.fromRow(Map<String, dynamic> row) {
    return BillingConfig(
      id: row['id'] as String,
      schoolId: row['school_id'] as String?,
      currencyCode: row['currency_code'] ?? 'USD',
      lateFeePercentage: (row['late_fee_percentage'] as num?)?.toDouble() ?? 0.0,
      invoiceFooterNote: row['invoice_footer_note'] as String?,
      allowPartialPayments: (row['allow_partial_payments'] == 1),
      defaultFee: (row['default_fee'] as num?)?.toDouble() ?? 100.00,
    );
  }
}

class NotificationModel {
  final String id;
  final String userId;
  final String? schoolId;
  final String title;
  final String body;
  final String type; // 'info', 'warning', etc.
  final bool isRead;
  final DateTime createdAt;

  NotificationModel({
    required this.id,
    required this.userId,
    this.schoolId,
    required this.title,
    required this.body,
    this.type = 'info',
    this.isRead = false,
    required this.createdAt,
  });

  factory NotificationModel.fromRow(Map<String, dynamic> row) {
    return NotificationModel(
      id: row['id'] as String,
      userId: row['user_id'] as String,
      schoolId: row['school_id'] as String?,
      title: row['title'] as String,
      body: row['body'] as String,
      type: row['type'] ?? 'info',
      isRead: (row['is_read'] == 1),
      createdAt: DateTime.parse(row['created_at']),
    );
  }
}
// ==========================================
// FILE: ./models/academic_models.dart
// ==========================================

class ClassModel {
  final String id;
  final String schoolId;
  final String name;
  final String? teacherId;
  final String? roomNumber;
  final String? subjectCode;

  ClassModel({
    required this.id,
    required this.schoolId,
    required this.name,
    this.teacherId,
    this.roomNumber,
    this.subjectCode,
  });

  factory ClassModel.fromRow(Map<String, dynamic> row) {
    return ClassModel(
      id: row['id'] as String,
      schoolId: row['school_id'] as String,
      name: row['name'] as String,
      teacherId: row['teacher_id'] as String?,
      roomNumber: row['room_number'] as String?,
      subjectCode: row['subject_code'] as String?,
    );
  }
}

class Enrollment {
  final String id;
  final String schoolId;
  final String studentId;
  final String classId;
  final DateTime enrolledAt;

  Enrollment({
    required this.id,
    required this.schoolId,
    required this.studentId,
    required this.classId,
    required this.enrolledAt,
  });

  factory Enrollment.fromRow(Map<String, dynamic> row) {
    return Enrollment(
      id: row['id'] as String,
      schoolId: row['school_id'] as String,
      studentId: row['student_id'] as String,
      classId: row['class_id'] as String,
      enrolledAt: DateTime.tryParse(row['enrolled_at'] ?? '') ?? DateTime.now(),
    );
  }
}

class SchoolYear {
  final String id;
  final String schoolId;
  final String yearLabel; // e.g., "2025"
  final DateTime startDate;
  final DateTime endDate;
  final bool active;

  SchoolYear({
    required this.id,
    required this.schoolId,
    required this.yearLabel,
    required this.startDate,
    required this.endDate,
    this.active = false,
  });

  factory SchoolYear.fromRow(Map<String, dynamic> row) {
    return SchoolYear(
      id: row['id'] as String,
      schoolId: row['school_id'] as String,
      yearLabel: row['year_label'] as String,
      startDate: DateTime.parse(row['start_date']),
      endDate: DateTime.parse(row['end_date']),
      active: (row['active'] == 1),
    );
  }
}

class SchoolYearMonth {
  final String id;
  final String schoolYearId;
  final String name; // "January"
  final int monthIndex; // 1
  final DateTime startDate;
  final DateTime endDate;
  final bool isBillable;

  SchoolYearMonth({
    required this.id,
    required this.schoolYearId,
    required this.name,
    required this.monthIndex,
    required this.startDate,
    required this.endDate,
    this.isBillable = true,
  });

  factory SchoolYearMonth.fromRow(Map<String, dynamic> row) {
    return SchoolYearMonth(
      id: row['id'] as String,
      schoolYearId: row['school_year_id'] as String,
      name: row['name'] as String,
      monthIndex: (row['month_index'] as num).toInt(),
      startDate: DateTime.parse(row['start_date']),
      endDate: DateTime.parse(row['end_date']),
      isBillable: (row['is_billable'] == 1),
    );
  }
}

class SchoolTerm {
  final String id;
  final String schoolId;
  final String name; // "Term 1"
  final DateTime startDate;
  final DateTime endDate;
  final int academicYear;

  SchoolTerm({
    required this.id,
    required this.schoolId,
    required this.name,
    required this.startDate,
    required this.endDate,
    required this.academicYear,
  });

  factory SchoolTerm.fromRow(Map<String, dynamic> row) {
    return SchoolTerm(
      id: row['id'] as String,
      schoolId: row['school_id'] as String,
      name: row['name'] as String,
      startDate: DateTime.parse(row['start_date']),
      endDate: DateTime.parse(row['end_date']),
      academicYear: (row['academic_year'] as num).toInt(),
    );
  }
}
// ==========================================
// FILE: ./models/billing/billing_configuration.dart
// ==========================================

import 'package:uuid/uuid.dart';

enum BillingFrequency {
  daily('daily', 'Daily'),
  weekly('weekly', 'Weekly'),
  monthly('monthly', 'Monthly'),
  termly('termly', 'Termly'),
  annually('annually', 'Annually'),
  custom('custom', 'Custom');

  final String code;
  final String display;
  const BillingFrequency(this.code, this.display);

  static BillingFrequency fromCode(String code) =>
      BillingFrequency.values.firstWhere(
        (e) => e.code == code,
        orElse: () => BillingFrequency.monthly,
      );
}

enum BillingType {
  tuition('tuition', 'Tuition'),
  transport('transport', 'Transport'),
  meals('meals', 'Meals'),
  activities('activities', 'Activities'),
  uniform('uniform', 'Uniform'),
  library('library', 'Library'),
  technology('technology', 'Technology'),
  custom('custom', 'Custom');

  final String code;
  final String display;
  const BillingType(this.code, this.display);

  static BillingType fromCode(String code) =>
      BillingType.values.firstWhere(
        (e) => e.code == code,
        orElse: () => BillingType.tuition,
      );
}

class FeeComponent {
  final String id;
  final String name;
  final BillingType type;
  final double amount;
  final bool isOptional;
  final bool isApplicable; // Used for conditional fees

  FeeComponent({
    String? id,
    required this.name,
    required this.type,
    required this.amount,
    this.isOptional = false,
    this.isApplicable = true,
  }) : id = id ?? const Uuid().v4();

  Map<String, dynamic> toMap() => {
        'id': id,
        'name': name,
        'type': type.code,
        'amount': amount,
        'is_optional': isOptional,
        'is_applicable': isApplicable,
      };

  factory FeeComponent.fromMap(Map<String, dynamic> map) => FeeComponent(
        id: map['id'] as String?,
        name: map['name'] as String,
        type: BillingType.fromCode(map['type'] as String),
        amount: (map['amount'] as num).toDouble(),
        isOptional: map['is_optional'] as bool? ?? false,
        isApplicable: map['is_applicable'] as bool? ?? true,
      );
}

class BillingConfiguration {
  final String id;
  final String schoolId;
  final String gradeLevel; // e.g., "Grade 1", "Grade 2", null for all
  final BillingFrequency frequency;
  final int billingDay; // Day of month when billing occurs
  final int dueDay; // Due day (usually billingDay + 7-30)
  final List<FeeComponent> feeComponents;
  final double? lateFeePercentage; // e.g., 5% = 5.0
  final double? minLateFee;
  final double? maxLateFee;
  final bool isActive;
  final DateTime effectiveFrom;
  final DateTime? effectiveUntil;

  BillingConfiguration({
    String? id,
    required this.schoolId,
    required this.gradeLevel,
    required this.frequency,
    required this.billingDay,
    required this.dueDay,
    required this.feeComponents,
    this.lateFeePercentage,
    this.minLateFee,
    this.maxLateFee,
    this.isActive = true,
    required this.effectiveFrom,
    this.effectiveUntil,
  }) : id = id ?? const Uuid().v4();

  double calculateTotalFee([List<String>? includeTypes]) {
    return feeComponents
        .where((fc) =>
            fc.isApplicable &&
            (includeTypes == null ||
                includeTypes.contains(fc.type.code)))
        .fold(0.0, (sum, fc) => sum + fc.amount);
  }

  Map<String, dynamic> toMap() => {
        'id': id,
        'school_id': schoolId,
        'grade_level': gradeLevel,
        'frequency': frequency.code,
        'billing_day': billingDay,
        'due_day': dueDay,
        'fee_components': feeComponents.map((fc) => fc.toMap()).toList(),
        'late_fee_percentage': lateFeePercentage,
        'min_late_fee': minLateFee,
        'max_late_fee': maxLateFee,
        'is_active': isActive,
        'effective_from': effectiveFrom.toIso8601String(),
        'effective_until': effectiveUntil?.toIso8601String(),
      };

  factory BillingConfiguration.fromMap(Map<String, dynamic> map) =>
      BillingConfiguration(
        id: map['id'] as String?,
        schoolId: map['school_id'] as String,
        gradeLevel: map['grade_level'] as String? ?? 'General',
        frequency: BillingFrequency.fromCode(map['frequency'] as String),
        billingDay: map['billing_day'] as int,
        dueDay: map['due_day'] as int,
        feeComponents: (map['fee_components'] as List<dynamic>?)
                ?.map((fc) =>
                    FeeComponent.fromMap(fc as Map<String, dynamic>))
                .toList() ??
            [],
        lateFeePercentage:
            (map['late_fee_percentage'] as num?)?.toDouble(),
        minLateFee: (map['min_late_fee'] as num?)?.toDouble(),
        maxLateFee: (map['max_late_fee'] as num?)?.toDouble(),
        isActive: map['is_active'] as bool? ?? true,
        effectiveFrom:
            DateTime.parse(map['effective_from'] as String),
        effectiveUntil: map['effective_until'] != null
            ? DateTime.parse(map['effective_until'] as String)
            : null,
      );
}

// ==========================================
// FILE: ./models/billing/billing_switch.dart
// ==========================================

import 'package:uuid/uuid.dart';
import 'billing_configuration.dart';

enum ProrationType {
  prorated('prorated', 'Prorated'),
  fullMonth('fullMonth', 'Full Month'),
  dailyRate('dailyRate', 'Daily Rate');

  final String code;
  final String display;
  const ProrationType(this.code, this.display);
}

class BillingSwitch {
  final String id;
  final String schoolId;
  final String studentId;
  final BillingConfiguration oldConfig;
  final BillingConfiguration newConfig;
  final DateTime effectiveDate;
  final ProrationType prorationType;
  final String? notes;
  final bool isProcessed;

  BillingSwitch({
    String? id,
    required this.schoolId,
    required this.studentId,
    required this.oldConfig,
    required this.newConfig,
    required this.effectiveDate,
    this.prorationType = ProrationType.prorated,
    this.notes,
    this.isProcessed = false,
  }) : id = id ?? const Uuid().v4();

  Map<String, dynamic> toMap() => {
        'id': id,
        'school_id': schoolId,
        'student_id': studentId,
        'old_config': oldConfig.toMap(),
        'new_config': newConfig.toMap(),
        'effective_date': effectiveDate.toIso8601String(),
        'proration_type': prorationType.code,
        'notes': notes,
        'is_processed': isProcessed,
      };
}

// ==========================================
// FILE: ./models/billing/generated_bill.dart
// ==========================================

import 'package:uuid/uuid.dart';
import 'billing_configuration.dart';

class BillLineItem {
  final String id;
  final BillingType type;
  final String description;
  final double unitPrice;
  final int quantity;
  final double total;
  final String? notes;

  BillLineItem({
    String? id,
    required this.type,
    required this.description,
    required this.unitPrice,
    this.quantity = 1,
    this.notes,
  })  : id = id ?? const Uuid().v4(),
        total = unitPrice * quantity;

  Map<String, dynamic> toMap() => {
        'id': id,
        'type': type.code,
        'description': description,
        'unit_price': unitPrice,
        'quantity': quantity,
        'total': total,
        'notes': notes,
      };
}

class GeneratedBill {
  final String id;
  final String schoolId;
  final String studentId;
  final String studentName;
  final String gradeLevel;
  final DateTime billingDate;
  final DateTime dueDate;
  final List<BillLineItem> lineItems;
  final double subtotal;
  final double lateFee;
  final double discount;
  final double total;
  final String frequency;
  final bool isSwitchBill; // Bill due to billing switch

  GeneratedBill({
    String? id,
    required this.schoolId,
    required this.studentId,
    required this.studentName,
    required this.gradeLevel,
    required this.billingDate,
    required this.dueDate,
    required this.lineItems,
    double? lateFee,
    double? discount,
    required this.frequency,
    this.isSwitchBill = false,
  })  : id = id ?? const Uuid().v4(),
        lateFee = lateFee ?? 0.0,
        discount = discount ?? 0.0,
        subtotal = lineItems.fold(0.0, (sum, item) => sum + item.total),
        total = (lineItems.fold(0.0, (sum, item) => sum + item.total) +
                (lateFee ?? 0.0) -
                (discount ?? 0.0))
            .clamp(0.0, double.infinity);

  Map<String, dynamic> toMap() => {
        'id': id,
        'school_id': schoolId,
        'student_id': studentId,
        'student_name': studentName,
        'grade_level': gradeLevel,
        'billing_date': billingDate.toIso8601String(),
        'due_date': dueDate.toIso8601String(),
        'line_items': lineItems.map((li) => li.toMap()).toList(),
        'subtotal': subtotal,
        'late_fee': lateFee,
        'discount': discount,
        'total': total,
        'frequency': frequency,
        'is_switch_bill': isSwitchBill,
      };
}

// ==========================================
// FILE: ./models/broadcast_filter.dart
// ==========================================

/// Broadcast feed filter types.
///
/// This enum replaces string literals ('All', 'System', 'Internal') with
/// compile-time safe, type-checked filter values.
///
/// **Before (Stringly-Typed - Unsafe):**
/// ```dart
/// String _filter = 'All'; // ❌ Typo: if you wrote 'AL' by mistake, no compile error!
/// if (_filter == 'Internal') { ... } // ❌ Fragile string comparison
/// if (_filter == 'Internak') { ... } // ❌ Silent bug - condition never true
/// ```
///
/// **After (Enum - Safe):**
/// ```dart
/// BroadcastFilter _filter = BroadcastFilter.all;
/// switch (_filter) {
///   case BroadcastFilter.all => ...,
///   case BroadcastFilter.system => ...,
///   case BroadcastFilter.internal => ...,
/// } // ✅ Compiler ensures all cases handled
/// ```
enum BroadcastFilter {
  /// Show all broadcasts (school + internal HQ messages)
  all('All'),

  /// Show only system-level announcements
  system('System'),

  /// Show only internal HQ messages
  internal('Internal');

  /// Human-readable display name
  final String displayName;

  const BroadcastFilter(this.displayName);

  /// Get filter from display name (for UI deserialization)
  ///
  /// Example: When deserializing from user preferences
  /// ```dart
  /// final saved = 'Internal';
  /// final filter = BroadcastFilter.fromDisplayName(saved);
  /// ```
  static BroadcastFilter fromDisplayName(String name) {
    try {
      return BroadcastFilter.values.firstWhere(
        (f) => f.displayName == name,
        orElse: () => BroadcastFilter.all,
      );
    } catch (e) {
      return BroadcastFilter.all;
    }
  }

  /// Check if this filter matches a broadcast
  ///
  /// Returns true if the broadcast should be shown when this filter is active
  bool matches(bool isSystemMessage, bool isInternalHQ) {
    switch (this) {
      case BroadcastFilter.all:
        // All filter shows everything
        return true;

      case BroadcastFilter.system:
        // System filter shows only system messages
        return isSystemMessage;

      case BroadcastFilter.internal:
        // Internal filter shows only internal HQ messages
        return isInternalHQ;
    }
  }
}

/// Extension for convenient string conversion
extension BroadcastFilterExt on BroadcastFilter {
  /// Get the broadcast provider to watch based on filter
  ///
  /// Example usage in BroadcastList:
  /// ```dart
  /// final provider = _filter.getProvider(); // Returns correct provider
  /// final feedAsync = ref.watch(provider);
  /// ```
  ///
  /// This is used with Riverpod's "Fortress Stream" pattern to
  /// dynamically switch between providers based on user's filter selection
  String getProviderName() {
    switch (this) {
      case BroadcastFilter.internal:
        return 'internalHQBroadcastProvider';
      case BroadcastFilter.all:
      case BroadcastFilter.system:
        return 'schoolBroadcastProvider';
    }
  }
}

// ==========================================
// FILE: ./models/all_models.dart
// ==========================================

/// Greyway.Co - Batch Tech 
/// Master Models Export - "The Fortress Architecture"
library;

export 'academic_models.dart';
export 'announcement_model.dart';
export 'attendance_models.dart';
export 'broadcast_model.dart';
export 'core_models.dart';
export 'finance_details_model.dart';
export 'finance_models.dart';
export 'fundraiser_models.dart';
export 'staff_model.dart';
export 'student_model.dart';
export 'subjects.dart';
export 'system_models.dart' hide Expense;
// ==========================================
// FILE: ./models/announcement_model.dart
// ==========================================

import 'package:flutter/material.dart';
import '../../core/constants/app_colors.dart';

enum AnnouncementCategory {
  // Original
  financial,
  academic,
  urgent,
  system,
  
  // The "Rainbow" Types
  success,        // Green
  failure,        // Red
  warning,        // Amber
  info,           // Blue
  security,       // Purple
}

class Announcement {
  final String id;
  final String schoolId;
  final String title;
  final String body;
  final DateTime time;
  final AnnouncementCategory category;
  final bool isRead;
  final String? userId; // For personal notifications

  Announcement({
    required this.id,
    required this.schoolId,
    required this.title,
    required this.body,
    required this.time,
    required this.category,
    required this.isRead,
    this.userId,
  });

  // --- FACTORY: THE CRASH FIX ---
  factory Announcement.fromRow(Map<String, dynamic> row) {
    // 1. Safe Boolean Parsing (Handles 1, 0, true, false, and null)
    final rawRead = row['is_read'];
    bool isReadSafe = false;
    if (rawRead is bool) {
      isReadSafe = rawRead;
    } else if (rawRead is int) {
      isReadSafe = rawRead == 1;
    }

    // 2. Safe Date Parsing
    DateTime parsedTime = DateTime.now();
    if (row['created_at'] != null) {
      parsedTime = DateTime.tryParse(row['created_at'].toString())?.toLocal() ?? DateTime.now();
    }

    return Announcement(
      id: row['id']?.toString() ?? '',
      schoolId: row['school_id']?.toString() ?? '',
      userId: row['user_id']?.toString(),
      title: row['title']?.toString() ?? 'No Title',
      body: row['body']?.toString() ?? '',
      time: parsedTime,
      isRead: isReadSafe,
      category: _parseCategory(row['type']?.toString() ?? 'info'),
    );
  }

  static AnnouncementCategory _parseCategory(String type) {
    switch (type.toLowerCase()) {
      case 'financial': return AnnouncementCategory.financial;
      case 'academic': return AnnouncementCategory.academic;
      case 'urgent': return AnnouncementCategory.urgent;
      case 'system': return AnnouncementCategory.system;
      case 'success': return AnnouncementCategory.success;
      case 'failure': 
      case 'error': return AnnouncementCategory.failure;
      case 'warning': return AnnouncementCategory.warning;
      case 'security': return AnnouncementCategory.security;
      default: return AnnouncementCategory.info;
    }
  }

  Map<String, dynamic> toMap() {
    return {
      'id': id,
      'school_id': schoolId,
      'user_id': userId,
      'title': title,
      'body': body,
      'type': category.name, 
      'is_read': isRead ? 1 : 0, // Store as Int for SQLite compatibility
      'created_at': time.toIso8601String(),
    };
  }

  // --- VISUAL GETTERS ---

  Color get color {
    switch (category) {
      case AnnouncementCategory.urgent:
      case AnnouncementCategory.failure:
        return AppColors.errorRed;
      
      case AnnouncementCategory.warning:
        return Colors.amber;
      
      case AnnouncementCategory.success:
        return AppColors.successGreen;
      
      case AnnouncementCategory.financial:
        return const Color(0xFF00BFA5); // Teal
      
      case AnnouncementCategory.security:
        return const Color(0xFF9333EA); // Purple
        
      case AnnouncementCategory.system:
      case AnnouncementCategory.info:
      default:
        return AppColors.primaryBlue;
    }
  }

  IconData get icon {
    switch (category) {
      case AnnouncementCategory.urgent: return Icons.notification_important_rounded;
      case AnnouncementCategory.failure: return Icons.error_outline_rounded;
      case AnnouncementCategory.warning: return Icons.warning_amber_rounded;
      case AnnouncementCategory.success: return Icons.check_circle_outline_rounded;
      case AnnouncementCategory.financial: return Icons.attach_money_rounded;
      case AnnouncementCategory.security: return Icons.security_rounded;
      case AnnouncementCategory.academic: return Icons.school_outlined;
      case AnnouncementCategory.system: return Icons.dns_outlined;
      default: return Icons.info_outline_rounded;
    }
  }

  String get badgeLabel {
    return category.name.toUpperCase();
  }
}
// ==========================================
// FILE: ./models/attendance_models.dart
// ==========================================

class Attendance {
  final String id;
  final String schoolId;
  final String studentId;
  final String? classId;
  final DateTime date;
  final String status; // 'present', 'absent', 'late', 'excused'
  final String? remarks;
  final String? recordedBy;

  Attendance({
    required this.id,
    required this.schoolId,
    required this.studentId,
    this.classId,
    required this.date,
    this.status = 'present',
    this.remarks,
    this.recordedBy,
  });

  factory Attendance.fromRow(Map<String, dynamic> row) {
    return Attendance(
      id: row['id'] as String,
      schoolId: row['school_id'] as String,
      studentId: row['student_id'] as String,
      classId: row['class_id'] as String?,
      date: DateTime.parse(row['date']),
      status: row['status'] ?? 'present',
      remarks: row['remarks'] as String?,
      recordedBy: row['recorded_by'] as String?,
    );
  }
}

class AttendanceSession {
  final String id;
  final String schoolId;
  final String classId;
  final String teacherId;
  final DateTime sessionDate;
  final bool isConfirmedByTeacher;
  final DateTime? confirmedAt;

  AttendanceSession({
    required this.id,
    required this.schoolId,
    required this.classId,
    required this.teacherId,
    required this.sessionDate,
    this.isConfirmedByTeacher = false,
    this.confirmedAt,
  });

  factory AttendanceSession.fromRow(Map<String, dynamic> row) {
    return AttendanceSession(
      id: row['id'] as String,
      schoolId: row['school_id'] as String,
      classId: row['class_id'] as String,
      teacherId: row['teacher_id'] as String,
      sessionDate: DateTime.parse(row['session_date']),
      isConfirmedByTeacher: (row['is_confirmed_by_teacher'] == 1),
      confirmedAt: row['confirmed_at'] != null 
          ? DateTime.tryParse(row['confirmed_at']) 
          : null,
    );
  }
}
// ==========================================
// FILE: ./models/finance_models.dart
// ==========================================

// ==========================================
// BILL MODEL
// ==========================================
class Bill {
  final String id;
  final String schoolId;
  final String studentId;
  final String title;
  final double totalAmount;
  final double paidAmount;
  final bool isPaid;
  final DateTime? dueDate;
  final String billType; // 'monthly', 'adhoc'
  final bool isClosed;
  final String? termId;

  Bill({
    required this.id,
    required this.schoolId,
    required this.studentId,
    required this.title,
    required this.totalAmount,
    this.paidAmount = 0.0,
    this.isPaid = false,
    this.dueDate,
    this.billType = 'monthly',
    this.isClosed = false,
    this.termId,
  });

  factory Bill.fromRow(Map<String, dynamic> row) {
    return Bill(
      id: row['id'] as String,
      schoolId: row['school_id'] as String,
      studentId: row['student_id'] as String,
      title: row['title'] as String,
      totalAmount: (row['total_amount'] as num?)?.toDouble() ?? 0.0,
      paidAmount: (row['paid_amount'] as num?)?.toDouble() ?? 0.0,
      isPaid: (row['is_paid'] == 1),
      dueDate: row['due_date'] != null ? DateTime.tryParse(row['due_date']) : null,
      billType: row['bill_type'] ?? 'monthly',
      isClosed: (row['is_closed'] == 1),
      termId: row['term_id'] as String?,
    );
  }

  Map<String, dynamic> toMap() {
    return {
      'id': id,
      'school_id': schoolId,
      'student_id': studentId,
      'title': title,
      'total_amount': totalAmount,
      'paid_amount': paidAmount,
      'is_paid': isPaid ? 1 : 0,
      'due_date': dueDate?.toIso8601String(),
      'bill_type': billType,
      'is_closed': isClosed ? 1 : 0,
      'term_id': termId,
    };
  }
}

// ==========================================
// PAYMENT MODEL
// ==========================================
class Payment {
  final String id;
  final String schoolId;
  final String studentId;
  final double amount;
  final DateTime datePaid;
  final String method; // 'cash', 'ecocash', etc.
  final String? payerName;
  final String? billId;

  Payment({
    required this.id,
    required this.schoolId,
    required this.studentId,
    required this.amount,
    required this.datePaid,
    this.method = 'cash',
    this.payerName,
    this.billId,
  });

  factory Payment.fromRow(Map<String, dynamic> row) {
    return Payment(
      id: row['id'] as String,
      schoolId: row['school_id'] as String,
      studentId: row['student_id'] as String,
      amount: (row['amount'] as num?)?.toDouble() ?? 0.0,
      datePaid: row['date_paid'] != null 
          ? DateTime.tryParse(row['date_paid']) ?? DateTime.now()
          : DateTime.now(),
      method: row['method'] ?? 'cash',
      payerName: row['payer_name'] as String?,
      billId: row['bill_id'] as String?,
    );
  }

  Map<String, dynamic> toMap() {
    return {
      'id': id,
      'school_id': schoolId,
      'student_id': studentId,
      'amount': amount,
      'date_paid': datePaid.toIso8601String(),
      'method': method,
      'payer_name': payerName,
      'bill_id': billId,
    };
  }
}

class Expense {
  final String id;
  final String schoolId;
  final String title;
  final double amount;
  final String? category;
  final DateTime incurredAt;
  final String? description; // Maps to 'description' column
  final String? recipient;

  Expense({
    required this.id,
    required this.schoolId,
    required this.title,
    required this.amount,
    this.category,
    required this.incurredAt,
    this.description,
    this.recipient,
  });

  factory Expense.fromRow(Map<String, dynamic> row) {
    return Expense(
      id: row['id'] as String,
      schoolId: row['school_id'] as String,
      title: row['title'] as String,
      amount: (row['amount'] as num).toDouble(),
      category: row['category'] as String?,
      incurredAt: DateTime.tryParse(row['incurred_at'] ?? '') ?? DateTime.now(),
      description: row['description'] as String?,
      recipient: row['recipient'] as String?,
    );
  }

  Map<String, dynamic> toMap() {
    return {
      'id': id,
      'school_id': schoolId,
      'title': title,
      'amount': amount,
      'category': category,
      'incurred_at': incurredAt.toIso8601String(),
      'description': description,
      'recipient': recipient,
      // 'created_at' is usually handled by Supabase defaults, 
      // but for PowerSync offline-first, we often include it.
      'created_at': DateTime.now().toIso8601String(), 
    };
  }
}
// ==========================================
// FILE: ./models/subjects.dart
// ==========================================

// File: lib/models/subjects.dart

class ZimsecSubject {
  static const Map<int, String> _codeMap = {
    // --- FORM 1 - 4 (O-LEVEL) CORE ---
    // These are the "Must-Haves" for almost every student.
    4005: 'English Language',
    4004: 'Mathematics',
    4003: 'Combined Science', // Replaces Integrated Science
    4006: 'Heritage Studies',
    4007: 'Shona',
    4068: 'Ndebele',
    4001: 'Agriculture',

    // --- FORM 1 - 4 (O-LEVEL) POPULAR ELECTIVES ---
    // Commercials & Arts
    4049: 'Commerce',
    4037: 'Geography',
    4044: 'History',
    4047: 'Family & Religious Studies', // F.R.S (formerly Divinity/R.E)
    4048: 'Business Enterprise Skills',
    4051: 'Principles of Accounting',

    // Sciences & Tech
    4029: 'Computer Science',
    4025: 'Biology',
    4023: 'Physics',
    4024:
        'Chemistry', // Often listed as 5070/5071 in older systems, but 4024 in new curriculum maps
    4059: 'Wood Technology and Design',

    // --- FORM 5 - 6 (A-LEVEL) ---
    // Commercials
    6001: 'Accounting (A-Level)',
    6025: 'Business Studies',
    6073: 'Economics',

    // Arts / Humanities
    6022: 'Geography (A-Level)',
    6006: 'History (A-Level)',
    6003: 'Divinity',
    6009: 'Literature in English',
    6081: 'Heritage Studies (A-Level)',

    // Sciences
    6042: 'Pure Mathematics',
    6030: 'Biology (A-Level)',
    6031: 'Chemistry (A-Level)',
    6032: 'Physics (A-Level)',
    6046: 'Statistics',
    6008: 'Computer Science (A-Level)',
  };

  // This is the getter your Registration Page is looking for:
  static List<String> get allNames => _codeMap.values.toList();

  static String nameFromCode(int code) => _codeMap[code] ?? 'Unknown';
}

class EnrolledSubject {
  final String subjectName;
  final String studentId;

  EnrolledSubject({required this.subjectName, required this.studentId});

  Map<String, dynamic> toJson() => {
    'subjectName': subjectName,
    'studentId': studentId,
  };

  factory EnrolledSubject.fromJson(Map<String, dynamic> json) {
    return EnrolledSubject(
      subjectName: json['subjectName'],
      studentId: json['studentId'],
    );
  }
}
// ==========================================
// FILE: ./models/student_model.dart
// ==========================================

class Student {
  final String id;
  final String schoolId;
  final String fullName;
  final String? studentId; // Manual ID (e.g., "STD-001")
  final String? grade;
  final String? parentContact;
  final DateTime? registrationDate;
  final String billingType; // 'monthly', 'termly'
  final double defaultFee;
  final bool isActive;
  final double owedTotal;
  final double paidTotal;
  final String? termId;
  final DateTime? dateOfBirth;
  final String? gender;
  final String? address;
  final String? emergencyContactName;
  final String? medicalNotes;
  final bool photoConsent;

  Student({
    required this.id,
    required this.schoolId,
    required this.fullName,
    this.studentId,
    this.grade,
    this.parentContact,
    this.registrationDate,
    this.billingType = 'monthly',
    this.defaultFee = 0.0,
    this.isActive = true,
    this.owedTotal = 0.0,
    this.paidTotal = 0.0,
    this.termId,
    this.dateOfBirth,
    this.gender,
    this.address,
    this.emergencyContactName,
    this.medicalNotes,
    this.photoConsent = false,
  });

  // Factory to create a Student from a PowerSync/SQLite Row
  factory Student.fromRow(Map<String, dynamic> row) {
    return Student(
      id: row['id'] as String,
      schoolId: row['school_id'] as String,
      fullName: row['full_name'] as String,
      studentId: row['student_id'] as String?,
      grade: row['grade'] as String?,
      parentContact: row['parent_contact'] as String?,
      registrationDate: row['registration_date'] != null 
          ? DateTime.tryParse(row['registration_date']) 
          : null,
      billingType: row['billing_type'] ?? 'monthly',
      defaultFee: (row['default_fee'] as num?)?.toDouble() ?? 0.0,
      isActive: (row['is_active'] == 1), // SQLite stores bools as 0/1
      owedTotal: (row['owed_total'] as num?)?.toDouble() ?? 0.0,
      paidTotal: (row['paid_total'] as num?)?.toDouble() ?? 0.0,
      termId: row['term_id'] as String?,
      dateOfBirth: row['date_of_birth'] != null 
          ? DateTime.tryParse(row['date_of_birth']) 
          : null,
      gender: row['gender'] as String?,
      address: row['address'] as String?,
      emergencyContactName: row['emergency_contact_name'] as String?,
      medicalNotes: row['medical_notes'] as String?,
      photoConsent: (row['photo_consent'] == 1),
    );
  }

  // Convert to Map for saving to Database
  Map<String, dynamic> toMap() {
    return {
      'id': id,
      'school_id': schoolId,
      'full_name': fullName,
      'student_id': studentId,
      'grade': grade,
      'parent_contact': parentContact,
      'registration_date': registrationDate?.toIso8601String(),
      'billing_type': billingType,
      'default_fee': defaultFee,
      'is_active': isActive ? 1 : 0,
      'owed_total': owedTotal,
      'paid_total': paidTotal,
      'term_id': termId,
      'date_of_birth': dateOfBirth?.toIso8601String(),
      'gender': gender,
      'address': address,
      'emergency_contact_name': emergencyContactName,
      'medical_notes': medicalNotes,
      'photo_consent': photoConsent ? 1 : 0,
    };
  }
}
// ==========================================
// FILE: ./models/notification_preferences_model.dart
// ==========================================

/// Notification preferences model
class NotificationPreferences {
  final bool billingInApp;
  final bool billingEmail;
  final String billingFreq;
  final bool campaignInApp;
  final bool campaignEmail;
  final bool attendanceInApp;
  final bool attendanceEmail;
  final bool announceInApp;
  final bool announceEmail;
  final bool channelEmail;
  final bool channelPush;
  final bool channelSMS;
  final bool dndEnabled;
  final String dndStart;
  final String dndEnd;

  const NotificationPreferences({
    this.billingInApp = true,
    this.billingEmail = true,
    this.billingFreq = 'Immediate',
    this.campaignInApp = true,
    this.campaignEmail = false,
    this.attendanceInApp = true,
    this.attendanceEmail = false,
    this.announceInApp = true,
    this.announceEmail = true,
    this.channelEmail = true,
    this.channelPush = true,
    this.channelSMS = false,
    this.dndEnabled = false,
    this.dndStart = '22:00',
    this.dndEnd = '07:00',
  });

  Map<String, dynamic> toJson() => {
        'billingInApp': billingInApp,
        'billingEmail': billingEmail,
        'billingFreq': billingFreq,
        'campaignInApp': campaignInApp,
        'campaignEmail': campaignEmail,
        'attendanceInApp': attendanceInApp,
        'attendanceEmail': attendanceEmail,
        'announceInApp': announceInApp,
        'announceEmail': announceEmail,
        'channelEmail': channelEmail,
        'channelPush': channelPush,
        'channelSMS': channelSMS,
        'dndEnabled': dndEnabled,
        'dndStart': dndStart,
        'dndEnd': dndEnd,
      };

  factory NotificationPreferences.fromJson(Map<String, dynamic> json) {
    return NotificationPreferences(
      billingInApp: json['billingInApp'] as bool? ?? true,
      billingEmail: json['billingEmail'] as bool? ?? true,
      billingFreq: json['billingFreq'] as String? ?? 'Immediate',
      campaignInApp: json['campaignInApp'] as bool? ?? true,
      campaignEmail: json['campaignEmail'] as bool? ?? false,
      attendanceInApp: json['attendanceInApp'] as bool? ?? true,
      attendanceEmail: json['attendanceEmail'] as bool? ?? false,
      announceInApp: json['announceInApp'] as bool? ?? true,
      announceEmail: json['announceEmail'] as bool? ?? true,
      channelEmail: json['channelEmail'] as bool? ?? true,
      channelPush: json['channelPush'] as bool? ?? true,
      channelSMS: json['channelSMS'] as bool? ?? false,
      dndEnabled: json['dndEnabled'] as bool? ?? false,
      dndStart: json['dndStart'] as String? ?? '22:00',
      dndEnd: json['dndEnd'] as String? ?? '07:00',
    );
  }

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is NotificationPreferences &&
          runtimeType == other.runtimeType &&
          billingInApp == other.billingInApp &&
          billingEmail == other.billingEmail &&
          billingFreq == other.billingFreq &&
          campaignInApp == other.campaignInApp &&
          campaignEmail == other.campaignEmail &&
          attendanceInApp == other.attendanceInApp &&
          attendanceEmail == other.attendanceEmail &&
          announceInApp == other.announceInApp &&
          announceEmail == other.announceEmail &&
          channelEmail == other.channelEmail &&
          channelPush == other.channelPush &&
          channelSMS == other.channelSMS &&
          dndEnabled == other.dndEnabled &&
          dndStart == other.dndStart &&
          dndEnd == other.dndEnd;

  @override
  int get hashCode =>
      billingInApp.hashCode ^
      billingEmail.hashCode ^
      billingFreq.hashCode ^
      campaignInApp.hashCode ^
      campaignEmail.hashCode ^
      attendanceInApp.hashCode ^
      attendanceEmail.hashCode ^
      announceInApp.hashCode ^
      announceEmail.hashCode ^
      channelEmail.hashCode ^
      channelPush.hashCode ^
      channelSMS.hashCode ^
      dndEnabled.hashCode ^
      dndStart.hashCode ^
      dndEnd.hashCode;
}

// ==========================================
// FILE: ./models/fundraiser_models.dart
// ==========================================

class Campaign {
  final String id;
  final String schoolId;
  final String createdById;
  final String name;
  final String? description;
  final String type; // Added to match Schema 'campaign_type'
  final String status; 
  final double goalAmount;
  final DateTime createdAt; // Useful for sorting

  Campaign({
    required this.id,
    required this.schoolId,
    required this.createdById,
    required this.name,
    this.description,
    this.type = 'General',
    this.status = 'active',
    this.goalAmount = 0.0,
    required this.createdAt,
  });

  factory Campaign.fromRow(Map<String, dynamic> row) {
    return Campaign(
      id: row['id'] as String,
      schoolId: row['school_id'] as String,
      createdById: row['created_by_id'] ?? '',
      name: row['name'] as String,
      description: row['description'] as String?,
      type: row['campaign_type'] ?? 'General',
      status: row['status'] ?? 'active',
      goalAmount: (row['goal_amount'] as num?)?.toDouble() ?? 0.0,
      createdAt: DateTime.tryParse(row['created_at'] ?? '') ?? DateTime.now(),
    );
  }

  Map<String, dynamic> toMap() {
    return {
      'id': id,
      'school_id': schoolId,
      'created_by_id': createdById,
      'name': name,
      'description': description,
      'campaign_type': type,
      'status': status,
      'goal_amount': goalAmount,
      'created_at': createdAt.toIso8601String(),
    };
  }
}

class CampaignDonation {
  final String id;
  final String campaignId;
  final String? donorName;
  final double amount;
  final String? paymentMethod;
  final DateTime dateReceived;
  final double expectedCash;
  final double actualCash;
  final double variance;

  CampaignDonation({
    required this.id,
    required this.campaignId,
    this.donorName,
    this.amount = 0.0,
    this.paymentMethod,
    required this.dateReceived,
    this.expectedCash = 0.0,
    this.actualCash = 0.0,
    this.variance = 0.0,
  });

  factory CampaignDonation.fromRow(Map<String, dynamic> row) {
    return CampaignDonation(
      id: row['id'] as String,
      campaignId: row['campaign_id'] as String,
      donorName: row['donor_name'] as String?,
      amount: (row['amount'] as num?)?.toDouble() ?? 0.0,
      paymentMethod: row['payment_method'] as String?,
      dateReceived: DateTime.tryParse(row['date_received'] ?? '') ?? DateTime.now(),
      expectedCash: (row['expected_cash'] as num?)?.toDouble() ?? 0.0,
      actualCash: (row['actual_cash'] as num?)?.toDouble() ?? 0.0,
      variance: (row['variance'] as num?)?.toDouble() ?? 0.0,
    );
  }
}

class CampaignExpense {
  final String id;
  final String campaignId;
  final String? category;
  final double amount;
  final String? incurredBy;

  CampaignExpense({
    required this.id,
    required this.campaignId,
    this.category,
    required this.amount,
    this.incurredBy,
  });

  factory CampaignExpense.fromRow(Map<String, dynamic> row) {
    return CampaignExpense(
      id: row['id'] as String,
      campaignId: row['campaign_id'] as String,
      category: row['category'] as String?,
      amount: (row['amount'] as num?)?.toDouble() ?? 0.0,
      incurredBy: row['incurred_by'] as String?,
    );
  }
}

class BankingRegister {
  final String id;
  final String? campaignId;
  final double amount;
  final String direction; // 'in' or 'out'
  final String? reference;
  final String schoolId;

  BankingRegister({
    required this.id,
    this.campaignId,
    required this.amount,
    required this.direction,
    this.reference,
    required this.schoolId,
  });

  factory BankingRegister.fromRow(Map<String, dynamic> row) {
    return BankingRegister(
      id: row['id'] as String,
      campaignId: row['campaign_id'] as String?,
      amount: (row['amount'] as num?)?.toDouble() ?? 0.0,
      direction: row['direction'] as String,
      reference: row['reference'] as String?,
      schoolId: row['school_id'] as String,
    );
  }
}
// ==========================================
// FILE: ./models/staff_model.dart
// ==========================================

// ==========================================
// TEACHER MODEL
// ==========================================
class Teacher {
  final String id;
  final String schoolId;
  final String fullName;
  final String? adminUid; // Links to user_profiles if they have logged in
  final DateTime createdAt;

  Teacher({
    required this.id,
    required this.schoolId,
    required this.fullName,
    this.adminUid,
    required this.createdAt,
  });

  factory Teacher.fromRow(Map<String, dynamic> row) {
    return Teacher(
      id: row['id'] as String,
      schoolId: row['school_id'] as String,
      fullName: row['full_name'] as String,
      adminUid: row['admin_uid'] as String?,
      createdAt: row['created_at'] != null 
          ? DateTime.tryParse(row['created_at']) ?? DateTime.now() 
          : DateTime.now(),
    );
  }

  Map<String, dynamic> toMap() {
    return {
      'id': id,
      'school_id': schoolId,
      'full_name': fullName,
      'admin_uid': adminUid,
      'created_at': createdAt.toIso8601String(),
    };
  }
}

// ==========================================
// TEACHER ACCESS TOKEN MODEL
// ==========================================
class TeacherAccessToken {
  final String id;
  final String schoolId;
  final String teacherId;
  final String grantedByTeacherId;
  final String accessCode;
  final String permissionType; // 'attendance', 'campaigns', 'both'
  final bool isUsed;
  final DateTime? usedAt;
  final DateTime expiresAt;

  TeacherAccessToken({
    required this.id,
    required this.schoolId,
    required this.teacherId,
    required this.grantedByTeacherId,
    required this.accessCode,
    required this.permissionType,
    this.isUsed = false,
    this.usedAt,
    required this.expiresAt,
  });

  bool get isExpired => DateTime.now().isAfter(expiresAt);

  factory TeacherAccessToken.fromRow(Map<String, dynamic> row) {
    return TeacherAccessToken(
      id: row['id'] as String,
      schoolId: row['school_id'] as String,
      teacherId: row['teacher_id'] as String,
      grantedByTeacherId: row['granted_by_teacher_id'] as String,
      accessCode: row['access_code'] as String,
      permissionType: row['permission_type'] ?? 'attendance',
      isUsed: (row['is_used'] == 1), // SQLite boolean handling
      usedAt: row['used_at'] != null 
          ? DateTime.tryParse(row['used_at']) 
          : null,
      expiresAt: row['expires_at'] != null 
          ? DateTime.tryParse(row['expires_at']) ?? DateTime.now()
          : DateTime.now(),
    );
  }

  Map<String, dynamic> toMap() {
    return {
      'id': id,
      'school_id': schoolId,
      'teacher_id': teacherId,
      'granted_by_teacher_id': grantedByTeacherId,
      'access_code': accessCode,
      'permission_type': permissionType,
      'is_used': isUsed ? 1 : 0,
      'used_at': usedAt?.toIso8601String(),
      'expires_at': expiresAt.toIso8601String(),
    };
  }
}
// ==========================================
// FILE: ./models/broadcast_model.dart
// ==========================================

import 'package:fees_up/core/constants/app_colors.dart';
import 'package:flutter/material.dart';

class Broadcast {
  final String id;
  final String? schoolId; // Null = Global Greyway.Co Broadcast
  final String authorId;
  final bool isSystemMessage;
  final String targetRole; // 'all', 'teacher', 'hq_internal'
  final String title;
  final String body;
  final String priority;
  final DateTime createdAt;

  Broadcast({
    required this.id,
    this.schoolId,
    required this.authorId,
    this.isSystemMessage = false,
    required this.targetRole,
    required this.title,
    required this.body,
    required this.priority,
    required this.createdAt,
  });

  factory Broadcast.fromRow(Map<String, dynamic> row) {
    return Broadcast(
      id: row['id'] as String,
      schoolId: row['school_id'] as String?,
      authorId: row['author_id'] as String,
      isSystemMessage: (row['is_system_message'] == 1),
      targetRole: row['target_role'] ?? 'all',
      title: row['title'] as String,
      body: row['body'] as String,
      priority: row['priority'] ?? 'normal',
      createdAt: DateTime.tryParse(row['created_at'] ?? '') ?? DateTime.now(),
    );
  }

  Map<String, dynamic> toMap() {
    return {
      'id': id,
      'school_id': schoolId,
      'author_id': authorId,
      'is_system_message': isSystemMessage ? 1 : 0,
      'target_role': targetRole,
      'title': title,
      'body': body,
      'priority': priority,
      'created_at': createdAt.toIso8601String(),
    };
  }

  // --- CE0 UI HELPERS ---
  
  bool get isInternalHQ => targetRole == 'hq_internal';

  Color get badgeColor {
    if (isInternalHQ) return AppColors.accentPurpleDark; // Security Purple
    if (isSystemMessage) return  AppColors.primaryBlue; // System Blue
    if (priority == 'critical') return AppColors.errorRed; // Failure Red
    return AppColors.successGreen; // General Green
  }

  String get authorLabel {
    if (isInternalHQ) return "Greyway HQ";
    if (isSystemMessage) return "Fees Up System";
    return "School Admin";
  }

  IconData get icon {
    if (isInternalHQ) return Icons.security;
    if (isSystemMessage) return Icons.settings_suggest;
    if (priority == 'critical') return Icons.report_problem;
    return Icons.campaign;
  }
}
// ==========================================
// FILE: ./models/finance_details_model.dart
// ==========================================

// ==========================================
// BILL ITEM MODEL (Line items inside a bill)
// ==========================================
class BillItem {
  final String id;
  final String billId;
  final String schoolId;
  final String description;
  final double amount;
  final int quantity;

  BillItem({
    required this.id,
    required this.billId,
    required this.schoolId,
    required this.description,
    required this.amount,
    this.quantity = 1,
  });

  // Calculate total for this line item
  double get total => amount * quantity;

  factory BillItem.fromRow(Map<String, dynamic> row) {
    return BillItem(
      id: row['id'] as String,
      billId: row['bill_id'] as String,
      schoolId: row['school_id'] as String,
      description: row['description'] as String,
      amount: (row['amount'] as num?)?.toDouble() ?? 0.0,
      quantity: (row['quantity'] as num?)?.toInt() ?? 1,
    );
  }

  Map<String, dynamic> toMap() {
    return {
      'id': id,
      'bill_id': billId,
      'school_id': schoolId,
      'description': description,
      'amount': amount,
      'quantity': quantity,
    };
  }
}

// ==========================================
// PAYMENT ALLOCATION MODEL (Splitting one payment across bills)
// ==========================================
class PaymentAllocation {
  final String id;
  final String paymentId;
  final String billId;
  final String schoolId;
  final double amount;

  PaymentAllocation({
    required this.id,
    required this.paymentId,
    required this.billId,
    required this.schoolId,
    required this.amount,
  });

  factory PaymentAllocation.fromRow(Map<String, dynamic> row) {
    return PaymentAllocation(
      id: row['id'] as String,
      paymentId: row['payment_id'] as String,
      billId: row['bill_id'] as String,
      schoolId: row['school_id'] as String,
      amount: (row['amount'] as num?)?.toDouble() ?? 0.0,
    );
  }

  Map<String, dynamic> toMap() {
    return {
      'id': id,
      'payment_id': paymentId,
      'bill_id': billId,
      'school_id': schoolId,
      'amount': amount,
    };
  }
}

// ==========================================
// CREDIT MODEL (Discounts or overpayments)
// ==========================================
class Credit {
  final String id;
  final String schoolId;
  final String studentId;
  final String? billId; // If applied to a specific bill
  final double amount;
  final String? reason;
  final String? creditId; // Manual reference ID

  Credit({
    required this.id,
    required this.schoolId,
    required this.studentId,
    required this.amount,
    this.billId,
    this.reason,
    this.creditId,
  });

  factory Credit.fromRow(Map<String, dynamic> row) {
    return Credit(
      id: row['id'] as String,
      schoolId: row['school_id'] as String,
      studentId: row['student_id'] as String,
      amount: (row['amount'] as num?)?.toDouble() ?? 0.0,
      billId: row['bill_id'] as String?,
      reason: row['reason'] as String?,
      creditId: row['credit_id'] as String?,
    );
  }

  Map<String, dynamic> toMap() {
    return {
      'id': id,
      'school_id': schoolId,
      'student_id': studentId,
      'amount': amount,
      'bill_id': billId,
      'reason': reason,
      'credit_id': creditId,
    };
  }
}
// ==========================================
// FILE: ./models/system_models.dart
// ==========================================

import 'dart:convert'; // Required for JSON decoding

class StudentArchive {
  final String id;
  final String schoolId;
  final String? fullName;
  final String? reason;
  final DateTime archivedAt;
  final Map<String, dynamic>? originalData; // Stored as JSONB in SQL

  StudentArchive({
    required this.id,
    required this.schoolId,
    this.fullName,
    this.reason,
    required this.archivedAt,
    this.originalData,
  });

  factory StudentArchive.fromRow(Map<String, dynamic> row) {
    return StudentArchive(
      id: row['id'] as String,
      schoolId: row['school_id'] as String,
      fullName: row['full_name'] as String?,
      reason: row['reason'] as String?,
      archivedAt: DateTime.tryParse(row['archived_at'] ?? '') ?? DateTime.now(),
      // Handle potential JSON string from SQLite
      originalData: row['original_data'] != null
          ? (row['original_data'] is String 
              ? jsonDecode(row['original_data']) 
              : row['original_data'])
          : null,
    );
  }
}

class Expense {
  final String id;
  final String schoolId;
  final String title;
  final double amount;
  final String? category;
  final DateTime incurredAt;
  final String? description;
  final String? recipient;
  final String? paymentMethod;

  Expense({
    required this.id,
    required this.schoolId,
    required this.title,
    required this.amount,
    this.category,
    required this.incurredAt,
    this.description,
    this.recipient,
    this.paymentMethod,
  });

  factory Expense.fromRow(Map<String, dynamic> row) {
    return Expense(
      id: row['id'] as String,
      schoolId: row['school_id'] as String,
      title: row['title'] as String,
      amount: (row['amount'] as num).toDouble(),
      category: row['category'] as String?,
      incurredAt: DateTime.tryParse(row['incurred_at'] ?? '') ?? DateTime.now(),
      description: row['description'] as String?,
      recipient: row['recipient'] as String?,
      paymentMethod: row['payment_method'] as String?,
    );
  }

  Map<String, dynamic> toMap() {
    return {
      'id': id,
      'school_id': schoolId,
      'title': title,
      'amount': amount,
      'category': category,
      'incurred_at': incurredAt.toIso8601String(),
      'description': description,
      'recipient': recipient,
      'payment_method': paymentMethod,
    };
  }
}
// ==========================================
// FILE: ./providers/billing_engine_provider.dart
// ==========================================

/// ============================================================================
/// BILLING ENGINE PROVIDER - RIVERPOD STATE MANAGEMENT
/// ============================================================================
library billing_engine_provider;

import 'package:fees_up/data/services/billing_engine.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

// Create instance provider for BillingEngine
final billingEngineProvider = Provider.family<BillingEngine, String>((ref, schoolId) {
  return BillingEngine(schoolId: schoolId);
});

// Provider for batch billing processor
final batchBillingProcessorProvider =
    Provider.family<BatchBillingProcessor, String>((ref, schoolId) {
  final engine = ref.watch(billingEngineProvider(schoolId));
  return BatchBillingProcessor(engine: engine);
});

// Provider for tracking generated bills
final generatedBillsProvider = StateNotifierProvider.family<
    GeneratedBillsNotifier,
    List<GeneratedBill>,
    String>((ref, schoolId) {
  return GeneratedBillsNotifier(schoolId);
});

// StateNotifier for managing generated bills
class GeneratedBillsNotifier extends StateNotifier<List<GeneratedBill>> {
  final String schoolId;

  GeneratedBillsNotifier(this.schoolId) : super([]);

  void addBill(GeneratedBill bill) {
    state = [...state, bill];
  }

  void addBills(List<GeneratedBill> bills) {
    state = [...state, ...bills];
  }

  void clearBills() {
    state = [];
  }

  void removeBill(String billId) {
    state = state.where((bill) => bill.id != billId).toList();
  }

  int get totalBills => state.length;
  double get totalAmount => state.fold(0.0, (sum, bill) => sum + bill.total);
}

// Provider for billing configurations cache
final billingConfigCacheProvider = StateNotifierProvider.family<
    BillingConfigCacheNotifier,
    Map<String, BillingConfiguration>,
    String>((ref, schoolId) {
  return BillingConfigCacheNotifier(schoolId);
});

class BillingConfigCacheNotifier
    extends StateNotifier<Map<String, BillingConfiguration>> {
  final String schoolId;

  BillingConfigCacheNotifier(this.schoolId) : super({});

  void registerConfig(BillingConfiguration config) {
    state = {...state, config.id: config};
  }

  void registerConfigs(List<BillingConfiguration> configs) {
    final newState = {...state};
    for (final config in configs) {
      newState[config.id] = config;
    }
    state = newState;
  }

  BillingConfiguration? getConfig(String configId) => state[configId];

  List<BillingConfiguration> getActiveConfigs() =>
      state.values.where((config) => config.isActive).toList();
}

// Provider for billing switch history
final billingSwitchHistoryProvider = StateNotifierProvider.family<
    BillingSwitchHistoryNotifier,
    Map<String, List<BillingSwitch>>,
    String>((ref, schoolId) {
  return BillingSwitchHistoryNotifier(schoolId);
});

class BillingSwitchHistoryNotifier
    extends StateNotifier<Map<String, List<BillingSwitch>>> {
  final String schoolId;

  BillingSwitchHistoryNotifier(this.schoolId) : super({});

  void recordSwitch(String studentId, BillingSwitch billSwitch) {
    state = {
      ...state,
      studentId: [...(state[studentId] ?? []), billSwitch],
    };
  }

  List<BillingSwitch> getSwitchHistory(String studentId) =>
      state[studentId] ?? [];

  int getTotalSwitches(String studentId) => state[studentId]?.length ?? 0;
}

// ==========================================
// FILE: ./providers/device_authority_provider.dart
// ==========================================

import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../services/device_authority_service.dart';

/// Provider for DeviceAuthorityService singleton
final deviceAuthorityProvider = Provider<DeviceAuthorityService>((ref) {
  return DeviceAuthorityService();
});

/// Check if current device is the billing engine for the given school
final isBillingEngineProvider =
    FutureProvider.family<bool, String>((ref, schoolId) async {
  final deviceAuthority = ref.watch(deviceAuthorityProvider);
  return await deviceAuthority.isBillingEngineForSchool(schoolId);
});

/// Get the active billing engine device for a school (if any)
final activeBillingEngineProvider =
    FutureProvider.family<Map<String, dynamic>?, String>((ref, schoolId) async {
  final deviceAuthority = ref.watch(deviceAuthorityProvider);
  return await deviceAuthority.getActiveBillingEngineForSchool(schoolId);
});

// ==========================================
// FILE: ./providers/report_builder_provider.dart
// ==========================================

import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:intl/intl.dart';

// --- STATE MODEL ---
class ReportBuilderState {
  final String category;
  final DateTimeRange dateRange;
  final String gradeFilter;
  final String exportFormat; // 'PDF' or 'Excel/CSV'

  ReportBuilderState({
    required this.category,
    required this.dateRange,
    required this.gradeFilter,
    required this.exportFormat,
  });

  ReportBuilderState copyWith({
    String? category,
    DateTimeRange? dateRange,
    String? gradeFilter,
    String? exportFormat,
  }) {
    return ReportBuilderState(
      category: category ?? this.category,
      dateRange: dateRange ?? this.dateRange,
      gradeFilter: gradeFilter ?? this.gradeFilter,
      exportFormat: exportFormat ?? this.exportFormat,
    );
  }
}

// --- NOTIFIER ---
class ReportBuilderNotifier extends StateNotifier<ReportBuilderState> {
  ReportBuilderNotifier() : super(ReportBuilderState(
    category: 'Tuition & Fee Collection',
    dateRange: DateTimeRange(
      start: DateTime.now().subtract(const Duration(days: 30)), 
      end: DateTime.now()
    ),
    gradeFilter: 'All Grades',
    exportFormat: 'PDF',
  ));

  void setCategory(String value) => state = state.copyWith(category: value);
  void setDateRange(DateTimeRange value) => state = state.copyWith(dateRange: value);
  void setGradeFilter(String value) => state = state.copyWith(gradeFilter: value);
  void setExportFormat(String value) => state = state.copyWith(exportFormat: value);
}

// --- PROVIDER ---
final reportBuilderProvider = StateNotifierProvider<ReportBuilderNotifier, ReportBuilderState>((ref) {
  return ReportBuilderNotifier();
});

// --- HELPER TO GET SUMMARY TEXT ---
// Used in the right-side summary panel of your UI
final reportSummaryProvider = Provider.autoDispose<Map<String, String>>((ref) {
  final state = ref.watch(reportBuilderProvider);
  final dateFormat = DateFormat('MMM d, yyyy');

  return {
    'Type': state.category,
    'Period': "${dateFormat.format(state.dateRange.start)} - ${dateFormat.format(state.dateRange.end)}",
    'Scope': state.gradeFilter,
    'Format': state.exportFormat == 'PDF' ? 'PDF Document' : 'Excel / CSV',
  };
});
// ==========================================
// FILE: ./providers/campaign_provider.dart
// ==========================================

import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:uuid/uuid.dart';
import '../services/database_service.dart';
import '../models/fundraiser_models.dart';
import 'auth_provider.dart'; 

// 1. WATCH: Listen for ANY active campaign for this school
final activeCampaignProvider = StreamProvider.family<Campaign?, String>((ref, schoolId) {
  final db = DatabaseService();
  // We limit to 1 because the UI logic assumes sequential campaigns for safety
  return db.db.watch(
    "SELECT * FROM campaigns WHERE school_id = ? AND status = 'active' ORDER BY created_at DESC LIMIT 1",
    parameters: [schoolId],
  ).map((rows) {
    if (rows.isEmpty) return null;
    return Campaign.fromRow(rows.first);
  });
});

// 2. CONTROLLER: Handle Create & Close actions
final campaignControllerProvider = StateNotifierProvider<CampaignController, AsyncValue<void>>((ref) {
  return CampaignController(ref);
});

class CampaignController extends StateNotifier<AsyncValue<void>> {
  final Ref _ref;
  CampaignController(this._ref) : super(const AsyncData(null));

  Future<bool> createCampaign({
    required String schoolId,
    required String name,
    required String type,
    required double goal,
    required String description,
  }) async {
    state = const AsyncLoading();
    try {
      final user = _ref.read(currentUserProvider);
      final id = const Uuid().v4();
      
      final newCampaign = Campaign(
        id: id,
        schoolId: schoolId,
        createdById: user?.id ?? 'unknown',
        name: name,
        type: type,
        goalAmount: goal,
        description: description,
        status: 'active',
        createdAt: DateTime.now(),
      );

      await DatabaseService().insert('campaigns', newCampaign.toMap());

      state = const AsyncData(null);
      return true;
    } catch (e, st) {
      state = AsyncError(e, st);
      return false;
    }
  }

  Future<bool> closeCampaign(String campaignId) async {
    state = const AsyncLoading();
    try {
      await DatabaseService().update('campaigns', campaignId, {
        'status': 'closed',
      });
      state = const AsyncData(null);
      return true;
    } catch (e, st) {
      state = AsyncError(e, st);
      return false;
    }
  }
}
// ==========================================
// FILE: ./providers/notifications_provider.dart
// ==========================================

import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../models/announcement_model.dart';
import '../repositories/announcements_repository.dart';
import 'school_provider.dart';

/// 1. DATA STREAM
/// The "Single Source of Truth" for the Rainbow Notification system.
/// Listens to PowerSync for any changes in the notifications table.
final notificationsProvider = StreamProvider<List<Announcement>>((ref) {
  final schoolId = ref.watch(activeSchoolIdProvider);
  if (schoolId == null) return const Stream.empty();

  final repository = ref.watch(announcementsRepositoryProvider);
  return repository.watchAnnouncements(schoolId);
});

/// 2. LOGIC CONTROLLER
/// Handles user interactions for the notification system.
final notificationLogicProvider = Provider((ref) => NotificationLogic(ref));

class NotificationLogic {
  final Ref _ref;
  NotificationLogic(this._ref);

  /// Bulk Action: Clears the "Unread" status for everything in the school.
  Future<void> markAllRead() async {
    final schoolId = _ref.read(activeSchoolIdProvider);
    if (schoolId != null) {
      await _ref.read(announcementsRepositoryProvider).markAllAsRead(schoolId);
    }
  }

  /// Single Action: Mark one specific item as read.
  /// Seals the logic gap by calling the explicit repository method.
  Future<void> markAsRead(String notificationId) async {
    final repository = _ref.read(announcementsRepositoryProvider);
    await repository.markOneAsRead(notificationId);
  }

  /// Single Action: Delete a notification (Cleanup rights).
  /// Ensures the "Fortress" table stays clean of old logs.
  Future<void> delete(String notificationId) async {
    final repository = _ref.read(announcementsRepositoryProvider);
    await repository.deleteNotification(notificationId);
  }
}
// ==========================================
// FILE: ./providers/dashboard_provider.dart
// ==========================================

import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../repositories/dashboard_repository.dart';
import '../services/database_service.dart';
import 'auth_provider.dart';
import 'school_provider.dart'; // ✅ Imported

final dashboardRepositoryProvider = Provider<DashboardRepository>((ref) {
  return DashboardRepository(DatabaseService());
});

// A simple class to hold our dashboard data snapshot
class DashboardData {
  final String schoolId;
  final String schoolName;
  final String userName;
  final int studentCount;
  final double outstandingBalance;
  final List<Map<String, dynamic>> recentPayments;

  DashboardData({
    required this.schoolId,
    required this.schoolName,
    required this.userName,
    required this.studentCount,
    required this.outstandingBalance,
    required this.recentPayments,
  });
}
final dashboardDataProvider = StreamProvider<DashboardData>((ref) async* {
  final user = ref.watch(currentUserProvider);
  if (user == null) throw 'User not logged in';

  // 1. Get the school data (caches after first successful fetch)
  final school = await ref.watch(currentSchoolProvider.future);
  
  if (school == null) {
    yield DashboardData(
      schoolId: '',
      schoolName: 'Loading...',
      userName: '',
      studentCount: 0,
      outstandingBalance: 0,
      recentPayments: [],
    );
    return;
  }

  final schoolId = school['id'];
  final schoolName = school['name'];
  final dbService = DatabaseService();

  // 2. Listen for ANY changes in the relevant tables
  // This keeps the Batch Tech dashboard live and reactive
  await for (final _ in dbService.db.onChange(['students', 'bills', 'payments', 'user_profiles'])) {
    
    // Fetch profile and stats in parallel for better performance
    final results = await Future.wait([
      dbService.getUserProfile(user.id),
      dbService.db.get('SELECT count(*) as c FROM students WHERE school_id = ?', [schoolId]),
      dbService.db.get('SELECT sum(total_amount - paid_amount) as t FROM bills WHERE school_id = ?', [schoolId]),
      dbService.db.getAll('SELECT * FROM payments WHERE school_id = ? ORDER BY date_paid DESC LIMIT 5', [schoolId]),
    ]);

    final profile = results[0] as Map<String, dynamic>?;
    final students = results[1] as Map<String, dynamic>;
    final bills = results[2] as Map<String, dynamic>;
    final payments = results[3] as List<Map<String, dynamic>>;

    yield DashboardData(
      schoolId: schoolId,
      schoolName: schoolName,
      userName: profile?['full_name'] ?? 'Admin',
      studentCount: (students['c'] as int),
      outstandingBalance: (bills['t'] as num?)?.toDouble() ?? 0.0,
      recentPayments: payments,
    );
  }
});
// ==========================================
// FILE: ./providers/expense_provider.dart
// ==========================================

import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:fees_up/data/models/finance_models.dart';
import 'package:fees_up/data/repositories/expense_repository.dart';
import 'package:fees_up/data/providers/school_provider.dart'; // Assuming you have this for currentSchoolId

// 1. STREAM: Live list of expenses
final recentExpensesProvider = StreamProvider.autoDispose<List<Expense>>((ref) {
  // Replace with your actual provider for getting the active school ID
  // e.g. ref.watch(currentSchoolIdProvider);
  // For safety, I'll return an empty stream if ID is missing.
  final schoolId = ref.watch(activeSchoolIdProvider); 
  
  if (schoolId == null) return const Stream.empty();

  final repo = ref.read(expenseRepositoryProvider);
  return repo.watchRecentExpenses(schoolId);
});

// 2. CONTROLLER: Handles the Save Action
class ExpenseController extends StateNotifier<AsyncValue<void>> {
  final Ref ref;

  ExpenseController(this.ref) : super(const AsyncData(null));

  Future<bool> saveExpense({
    required String title,
    required double amount,
    required DateTime date,
    String? category,
    String? recipient,
    String? notes,
    String? paymentMethod,
  }) async {
    state = const AsyncLoading();
    try {
      final schoolId = ref.read(activeSchoolIdProvider);
      if (schoolId == null) throw Exception("No active school found.");

      final repo = ref.read(expenseRepositoryProvider);
      
      await repo.createExpense(
        schoolId: schoolId,
        title: title,
        amount: amount,
        incurredAt: date,
        category: category,
        recipient: recipient,
        notes: notes,
        paymentMethod: paymentMethod,
      );

      state = const AsyncData(null);
      return true;
    } catch (e, stack) {
      state = AsyncError(e, stack);
      return false;
    }
  }
}

final expenseControllerProvider = StateNotifierProvider<ExpenseController, AsyncValue<void>>((ref) {
  return ExpenseController(ref);
});
// ==========================================
// FILE: ./providers/staff_provider.dart
// ==========================================

import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../repositories/staff_repository.dart';

/// Load all staff for a school
final loadStaffProvider =
    FutureProvider.autoDispose.family<List<StaffMember>, String>(
  (ref, schoolId) async {
    final repository = StaffRepositoryImpl();
    return repository.loadStaff(schoolId);
  },
);

/// Watch staff changes in real-time
final watchStaffProvider =
    StreamProvider.autoDispose.family<List<StaffMember>, String>(
  (ref, schoolId) {
    final repository = StaffRepositoryImpl();
    return repository.watchStaff(schoolId);
  },
);

/// Get staff count by role
final staffCountByRoleProvider =
    FutureProvider.autoDispose.family<Map<String, int>, String>(
  (ref, schoolId) async {
    final repository = StaffRepositoryImpl();
    return repository.getStaffCountByRole(schoolId);
  },
);

// ==========================================
// FILE: ./providers/fundraising_provider.dart
// ==========================================

import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../services/database_service.dart';
import 'dashboard_provider.dart';

class FundraisingData {
  final String campaignName;
  final double goalAmount;
  final double raisedAmount;
  final double percentage;

  FundraisingData({
    required this.campaignName,
    required this.goalAmount,
    required this.raisedAmount,
    required this.percentage,
  });
}

final fundraisingProvider = FutureProvider<FundraisingData?>((ref) async {
  final dashboardData = await ref.watch(dashboardDataProvider.future);
  final schoolId = dashboardData.schoolId;
  final db = DatabaseService().db;

  // 1. Get the ACTIVE campaign for this school
  // We explicitly look for status = 'active'
  final campaigns = await db.getAll(
    "SELECT * FROM campaigns WHERE school_id = ? AND status = 'active' ORDER BY created_at DESC LIMIT 1",
    [schoolId],
  );

  if (campaigns.isEmpty) return null; // No active campaign found

  final campaign = campaigns.first;
  final campaignId = campaign['id'];
  final goal = (campaign['goal_amount'] as num?)?.toDouble() ?? 100.0; 
  final name = campaign['name'] ?? 'Campaign';

  // 2. Sum donations for this specific campaign ID
  final donations = await db.getAll(
    "SELECT sum(amount) as total FROM campaign_donations WHERE campaign_id = ?",
    [campaignId],
  );

  final raised = (donations.first['total'] as num?)?.toDouble() ?? 0.0;

  // 3. Calculate Percentage (Safe division)
  double percent = 0.0;
  if (goal > 0) {
    percent = (raised / goal) * 100;
  }
  
  // Cap percentage visual at 100% (optional, but looks better on progress bars)
  // For the text value, we keep the real percentage.
  
  return FundraisingData(
    campaignName: name,
    goalAmount: goal,
    raisedAmount: raised,
    percentage: percent,
  );
});
// ==========================================
// FILE: ./providers/billing_suspension_provider.dart
// ==========================================

/// ============================================================================
/// BILLING SUSPENSION PROVIDER - RIVERPOD STATE MANAGEMENT
/// ============================================================================
/// 
/// Provides reactive state management for billing suspension operations
/// using Riverpod. Enables real-time updates to suspension status across
/// the application.
///
/// Author: Nyasha Gabriel / Batch Tech
/// Date: January 3, 2026
library billing_suspension_provider;

// ✅ CORRECT: Only export non-sensitive utility classes and enums
// ❌ DO NOT export: SuspensionPeriod, BillingAuditEntry, BillingExtension
// These tables are server-side only and must never be synced to client
export '../services/billing_suspension_service.dart'
    show
        BillingSuppressionStatusData,
        BillingSuppressionScope,
        SuspensionStatus,
        SuspensionScopeType,
        AuditAction;

import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:supabase_flutter/supabase_flutter.dart';
import '../services/billing_suspension_service.dart';

// ============================================================================
// PROVIDERS
// ============================================================================

/// Provides instance of BillingSuppressionService scoped by school ID
final billingSuppressionServiceProvider =
    Provider.family<BillingSuppressionService, String>((ref, schoolId) {
  final supabase = Supabase.instance.client;
  final userId = supabase.auth.currentUser?.id ?? '';

  return BillingSuppressionService(
    supabase: supabase,
    schoolId: schoolId,
    userId: userId,
  );
});

/// Provides current billing suspension status (is any suspension active?)
final billingSuppressionStatusProvider =
    FutureProvider.family<bool, String>((ref, schoolId) async {
  final service = ref.watch(billingSuppressionServiceProvider(schoolId));
  return await service.isBillingSuspended();
});

/// Provides all active suspension periods for a school
/// 
/// ✅ SECURE: Returns boolean status only, not full period data
/// ✅ Server validates all suspension logic
final activeSuspensionsProvider = FutureProvider.family<bool, String>(
    (ref, schoolId) async {
  final service = ref.watch(billingSuppressionServiceProvider(schoolId));
  return await service.getActiveSuspensions();
});

/// Provides suspension summary for UI display
final suspensionSummaryProvider =
    FutureProvider.family<Map<String, dynamic>, String>((ref, schoolId) async {
  final service = ref.watch(billingSuppressionServiceProvider(schoolId));
  return await service.getSuspensionSummary();
});

/// Provides audit log entries (admin/read-only)
/// 
/// ✅ SECURE: Returns raw maps, no client-side models
/// ✅ Server enforces admin-only access via RLS
final billingAuditLogProvider =
    FutureProvider.family<List<Map<String, dynamic>>, String>(
        (ref, schoolId) async {
  final service = ref.watch(billingSuppressionServiceProvider(schoolId));
  return await service.getAuditLog(limit: 100);
});

/// StateNotifier for managing suspension UI state
class SuspensionStateNotifier extends StateNotifier<SuspensionUIState> {
  final BillingSuppressionService _service;

  SuspensionStateNotifier({required BillingSuppressionService service})
      : _service = service,
        super(const SuspensionUIState());

  /// Trigger suspension
  /// 
  /// ✅ SECURE: Uses RPC call via service
  /// ✅ No direct table access
  Future<bool> suspendBilling({
    required String reason,
    BillingSuppressionScope? scope,
    String? customNote,
  }) async {
    state = state.copyWith(isLoading: true, error: null);
    try {
      final result = await _service.suspendBilling(
        reason: reason,
        scope: scope,
        customNote: customNote,
      );

      state = state.copyWith(
        isLoading: false,
        isSuspended: result,
      );
      return result;
    } catch (e) {
      state = state.copyWith(
        isLoading: false,
        error: e.toString(),
      );
      return false;
    }
  }

  /// Trigger resumption
  /// 
  /// ✅ SECURE: Uses RPC call via service
  /// ✅ Server validates engine assignment
  Future<bool> resumeBilling() async {
    state = state.copyWith(isLoading: true, error: null);
    try {
      final result = await _service.resumeBilling();

      state = state.copyWith(
        isLoading: false,
        isSuspended: !result, // false when resume succeeds
      );
      return result;
    } catch (e) {
      state = state.copyWith(
        isLoading: false,
        error: e.toString(),
      );
      return false;
    }
  }

  /// Refresh suspension status
  /// 
  /// ✅ SECURE: Queries current status from server via RPC
  Future<void> refreshStatus() async {
    state = state.copyWith(isLoading: true, error: null);
    try {
      final isSuspended = await _service.isBillingSuspended();

      state = state.copyWith(
        isLoading: false,
        isSuspended: isSuspended,
      );
    } catch (e) {
      state = state.copyWith(
        isLoading: false,
        error: e.toString(),
      );
    }
  }

  /// Clear error state
  void clearError() {
    state = state.copyWith(error: null);
  }
}

/// UI State for suspension operations
/// 
/// ✅ SECURE: Only contains suspension status, not sensitive period data
/// Sensitive data (periods, audit log) is server-side only
class SuspensionUIState {
  final bool isSuspended;
  final bool isLoading;
  final String? error;

  const SuspensionUIState({
    this.isSuspended = false,
    this.isLoading = false,
    this.error,
  });

  SuspensionUIState copyWith({
    bool? isSuspended,
    bool? isLoading,
    String? error,
  }) {
    return SuspensionUIState(
      isSuspended: isSuspended ?? this.isSuspended,
      isLoading: isLoading ?? this.isLoading,
      error: error,
    );
  }
}

/// StateNotifier provider for suspension state
final suspensionStateProvider =
    StateNotifierProvider.family<SuspensionStateNotifier, SuspensionUIState,
        String>((ref, schoolId) {
  final service = ref.watch(billingSuppressionServiceProvider(schoolId));
  return SuspensionStateNotifier(service: service);
});

// ==========================================
// FILE: ./providers/revenue_provider.dart
// ==========================================

import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:intl/intl.dart';
import '../services/database_service.dart';
import 'dashboard_provider.dart';

// --- FILTER ENUM ---
enum RevenueFilter { thisWeek, lastWeek }

final revenueFilterProvider = StateProvider<RevenueFilter>((ref) => RevenueFilter.thisWeek);

class WeeklyRevenueData {
  final double totalWeekRevenue;
  final Map<int, double> dailyTotals; // Key: Weekday (1=Mon ... 7=Sun)

  WeeklyRevenueData({required this.totalWeekRevenue, required this.dailyTotals});
}

final weeklyRevenueProvider = FutureProvider<WeeklyRevenueData>((ref) async {
  final dashboardData = await ref.watch(dashboardDataProvider.future);
  final schoolId = dashboardData.schoolId;
  final filter = ref.watch(revenueFilterProvider);

  // 1. Calculate Date Range
  final now = DateTime.now();
  final currentWeekStart = now.subtract(Duration(days: now.weekday - 1)); // This Monday
  
  DateTime startOfWeek;
  DateTime endOfWeek;

  if (filter == RevenueFilter.thisWeek) {
    startOfWeek = DateTime(currentWeekStart.year, currentWeekStart.month, currentWeekStart.day);
    endOfWeek = startOfWeek.add(const Duration(days: 6, hours: 23, minutes: 59));
  } else {
    // Last Week
    startOfWeek = currentWeekStart.subtract(const Duration(days: 7));
    endOfWeek = startOfWeek.add(const Duration(days: 6, hours: 23, minutes: 59));
  }

  final startStr = DateFormat('yyyy-MM-dd').format(startOfWeek);
  final endStr = DateFormat('yyyy-MM-dd').format(endOfWeek);

  // 2. Query Database
  final db = DatabaseService().db;
  final results = await db.getAll(
    'SELECT amount, date_paid FROM payments WHERE school_id = ? AND date_paid >= ? AND date_paid <= ?',
    [schoolId, startStr, endStr],
  );

  // 3. Group by Day
  double total = 0.0;
  final Map<int, double> dailyMap = {1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 0};

  for (var row in results) {
    final amount = (row['amount'] as num).toDouble();
    final dateStr = row['date_paid'] as String;
    final date = DateTime.parse(dateStr);
    
    // Ensure we map correctly even if the date parsing varies slightly
    dailyMap[date.weekday] = (dailyMap[date.weekday] ?? 0) + amount;
    total += amount;
  }

  return WeeklyRevenueData(totalWeekRevenue: total, dailyTotals: dailyMap);
});
// ==========================================
// FILE: ./providers/payment_allocations_provider.dart
// ==========================================

import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../services/database_service.dart';

/// Get payment allocation history for a specific payment
final paymentAllocationsProvider =
    StreamProvider.family<List<Map<String, dynamic>>, String>(
  (ref, paymentId) {
    final db = DatabaseService();
    return db.db.watch(
      '''SELECT pa.*, b.title as bill_title, b.total_amount, b.paid_amount 
         FROM payment_allocations pa 
         LEFT JOIN bills b ON pa.bill_id = b.id 
         WHERE pa.payment_id = ? 
         ORDER BY pa.created_at DESC''',
      parameters: [paymentId],
    );
  },
);

/// Get all payment allocations for a student
final studentPaymentAllocationsProvider =
    StreamProvider.family<List<Map<String, dynamic>>, String>(
  (ref, studentId) {
    final db = DatabaseService();
    return db.db.watch(
      '''SELECT pa.*, p.amount as payment_amount, p.date_paid,
                b.title as bill_title, b.total_amount, b.paid_amount
         FROM payment_allocations pa
         JOIN payments p ON pa.payment_id = p.id
         JOIN bills b ON pa.bill_id = b.id
         WHERE p.student_id = ?
         ORDER BY p.date_paid DESC''',
      parameters: [studentId],
    );
  },
);

/// Get unallocated portion of a payment
final unallocatedPaymentAmountProvider = FutureProvider.family<double, String>(
  (ref, paymentId) async {
    final db = DatabaseService();

    // Get payment total
    final paymentResult = await db.db.getAll(
      'SELECT amount FROM payments WHERE id = ?',
      [paymentId],
    );

    if (paymentResult.isEmpty) return 0.0;
    final paymentAmount =
        (paymentResult.first['amount'] as num?)?.toDouble() ?? 0.0;

    // Get allocated amount
    final allocatedResult = await db.db.getAll(
      'SELECT SUM(amount) as total FROM payment_allocations WHERE payment_id = ?',
      [paymentId],
    );

    final allocatedAmount =
        (allocatedResult.first['total'] as num?)?.toDouble() ?? 0.0;

    return paymentAmount - allocatedAmount;
  },
);

/// Create a new payment allocation
class PaymentAllocationNotifier
    extends StateNotifier<AsyncValue<Map<String, dynamic>?>> {
  PaymentAllocationNotifier(this._db) : super(const AsyncData(null));

  final DatabaseService _db;

  Future<void> allocatePayment({
    required String paymentId,
    required String billId,
    required double amount,
  }) async {
    state = const AsyncLoading();
    try {
      final allocationId = DateTime.now().millisecondsSinceEpoch.toString();

      await _db.db.execute(
        '''INSERT INTO payment_allocations (payment_id, bill_id, school_id, amount, created_at)
           SELECT ?, ?, school_id, ?, ? FROM payments WHERE id = ?''',
        [
          paymentId,
          billId,
          amount,
          DateTime.now().toIso8601String(),
          paymentId,
        ],
      );

      // Recalculate bill paid_amount
      await _db.db.execute(
        '''UPDATE bills 
           SET paid_amount = (SELECT COALESCE(SUM(amount), 0) FROM payment_allocations WHERE bill_id = ?)
           WHERE id = ?''',
        [billId, billId],
      );

      state = AsyncData({'id': allocationId, 'paymentId': paymentId});
    } catch (e, st) {
      state = AsyncError(e, st);
    }
  }

  Future<void> removeAllocation({
    required String allocationId,
    required String billId,
  }) async {
    try {
      await _db.db.execute(
        'DELETE FROM payment_allocations WHERE id = ?',
        [allocationId],
      );

      // Recalculate bill paid_amount
      await _db.db.execute(
        '''UPDATE bills 
           SET paid_amount = (SELECT COALESCE(SUM(amount), 0) FROM payment_allocations WHERE bill_id = ?)
           WHERE id = ?''',
        [billId, billId],
      );
    } catch (e) {
      rethrow;
    }
  }
}

final paymentAllocationNotifierProvider = StateNotifierProvider.autoDispose<
    PaymentAllocationNotifier, AsyncValue<Map<String, dynamic>?>>(
  (ref) => PaymentAllocationNotifier(DatabaseService()),
);

// ==========================================
// FILE: ./providers/auth_provider.dart
// ==========================================

import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:supabase_flutter/supabase_flutter.dart';
import '../repositories/auth_repository.dart';

// 1. The Repository Provider (This is what was missing)
final authRepositoryProvider = Provider<AuthRepository>((ref) {
  return AuthRepository();
});

// 2. Auth State Stream (Listens to Login/Logout events)
final authStateProvider = StreamProvider<AuthState>((ref) {
  final repo = ref.watch(authRepositoryProvider);
  return repo.authStateChanges;
});

// 3. Current User Helper
final currentUserProvider = Provider<User?>((ref) {
  final authState = ref.watch(authStateProvider);
  return authState.value?.session?.user;
});
// ==========================================
// FILE: ./providers/year_configuration_provider.dart
// ==========================================

/// Year Configuration Providers
/// Manages all Riverpod state for year configuration.
/// Widgets use these providers instead of accessing the database directly.
library;

import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../repositories/year_configuration_repository.dart';
import '../repositories/year_configuration_repository_impl.dart';
import '../services/database_service.dart';
import '../providers/school_year_seeder.dart';

/// Provides the YearConfigurationRepository instance
final yearConfigurationRepositoryProvider = Provider((ref) {
  return YearConfigurationRepositoryImpl(
    db: DatabaseService(),
    seeder: SchoolYearSeeder(),
  );
});

/// Loads year data (with terms and months) - used once on widget load
final loadYearProvider = FutureProvider.autoDispose
    .family<Map<String, dynamic>?, (String, String)>((ref, params) async {
  final (yearId, schoolId) = params;
  final repository = ref.watch(yearConfigurationRepositoryProvider);
  return repository.loadYear(yearId, schoolId);
});

/// Watches year changes in real-time
final watchYearProvider = StreamProvider.autoDispose
    .family<Map<String, dynamic>?, (String, String)>((ref, params) {
  final (yearId, schoolId) = params;
  final repository = ref.watch(yearConfigurationRepositoryProvider);
  return repository.watchYear(yearId, schoolId);
});

/// Watches months for a year in real-time
final watchMonthsProvider = StreamProvider.autoDispose
    .family<List<Map<String, dynamic>>, (String, String)>((ref, params) {
  final (yearId, schoolId) = params;
  final repository = ref.watch(yearConfigurationRepositoryProvider);
  return repository.watchMonths(yearId, schoolId);
});

/// Save year data - called by widget when user clicks Save
class SaveYearNotifier extends StateNotifier<AsyncValue<void>> {
  SaveYearNotifier(this._repository) : super(const AsyncValue.data(null));

  final YearConfigurationRepository _repository;

  Future<void> saveYear({
    required String yearId,
    required String schoolId,
    required String yearLabel,
    required String startDate,
    required String endDate,
    required String description,
    required bool active,
    required List<Map<String, dynamic>> terms,
    required List<String> removedTermIds,
    required List<Map<String, dynamic>> months,
  }) async {
    state = const AsyncValue.loading();
    try {
      await _repository.saveYear(
        yearId: yearId,
        schoolId: schoolId,
        yearLabel: yearLabel,
        startDate: startDate,
        endDate: endDate,
        description: description,
        active: active,
        terms: terms,
        removedTermIds: removedTermIds,
        months: months,
      );
      state = const AsyncValue.data(null);
    } catch (e, st) {
      state = AsyncValue.error(e, st);
      rethrow;
    }
  }
}

final saveYearProvider =
    StateNotifierProvider.autoDispose<SaveYearNotifier, AsyncValue<void>>(
  (ref) {
    final repository = ref.watch(yearConfigurationRepositoryProvider);
    return SaveYearNotifier(repository);
  },
);

// ==========================================
// FILE: ./providers/notification_preferences_provider.dart
// ==========================================

import 'dart:convert';
import 'package:flutter/foundation.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../services/database_service.dart';

class NotificationPreferences {
  final bool billingInApp;
  final bool billingEmail;
  final String billingFreq;
  final bool campaignInApp;
  final bool campaignEmail;
  final bool attendanceInApp;
  final bool attendanceEmail;
  final bool announceInApp;
  final bool announceEmail;
  final bool channelEmail;
  final bool channelPush;
  final bool channelSMS;
  final bool dndEnabled;
  final String dndStart;
  final String dndEnd;

  NotificationPreferences({
    this.billingInApp = true,
    this.billingEmail = true,
    this.billingFreq = 'Immediate',
    this.campaignInApp = true,
    this.campaignEmail = false,
    this.attendanceInApp = true,
    this.attendanceEmail = false,
    this.announceInApp = true,
    this.announceEmail = true,
    this.channelEmail = true,
    this.channelPush = true,
    this.channelSMS = false,
    this.dndEnabled = false,
    this.dndStart = '22:00',
    this.dndEnd = '07:00',
  });

  Map<String, dynamic> toJson() => {
        'billingInApp': billingInApp,
        'billingEmail': billingEmail,
        'billingFreq': billingFreq,
        'campaignInApp': campaignInApp,
        'campaignEmail': campaignEmail,
        'attendanceInApp': attendanceInApp,
        'attendanceEmail': attendanceEmail,
        'announceInApp': announceInApp,
        'announceEmail': announceEmail,
        'channelEmail': channelEmail,
        'channelPush': channelPush,
        'channelSMS': channelSMS,
        'dndEnabled': dndEnabled,
        'dndStart': dndStart,
        'dndEnd': dndEnd,
      };

  factory NotificationPreferences.fromJson(Map<String, dynamic> json) {
    return NotificationPreferences(
      billingInApp: json['billingInApp'] as bool? ?? true,
      billingEmail: json['billingEmail'] as bool? ?? true,
      billingFreq: json['billingFreq'] as String? ?? 'Immediate',
      campaignInApp: json['campaignInApp'] as bool? ?? true,
      campaignEmail: json['campaignEmail'] as bool? ?? false,
      attendanceInApp: json['attendanceInApp'] as bool? ?? true,
      attendanceEmail: json['attendanceEmail'] as bool? ?? false,
      announceInApp: json['announceInApp'] as bool? ?? true,
      announceEmail: json['announceEmail'] as bool? ?? true,
      channelEmail: json['channelEmail'] as bool? ?? true,
      channelPush: json['channelPush'] as bool? ?? true,
      channelSMS: json['channelSMS'] as bool? ?? false,
      dndEnabled: json['dndEnabled'] as bool? ?? false,
      dndStart: json['dndStart'] as String? ?? '22:00',
      dndEnd: json['dndEnd'] as String? ?? '07:00',
    );
  }
}

class NotificationPreferencesNotifier
    extends StateNotifier<AsyncValue<NotificationPreferences>> {
  final String schoolId;
  final DatabaseService _db = DatabaseService();

  NotificationPreferencesNotifier(this.schoolId)
      : super(const AsyncValue.loading()) {
    _loadPreferences();
  }

  Future<void> _loadPreferences() async {
    try {
      final results = await _db.db.getAll(
        'SELECT notification_prefs FROM schools WHERE id = ?',
        [schoolId],
      );

      if (results.isEmpty) {
        state = AsyncValue.data(NotificationPreferences());
        return;
      }

      final prefsJson = results.first['notification_prefs'] as String? ?? '';
      if (prefsJson.isEmpty) {
        state = AsyncValue.data(NotificationPreferences());
        return;
      }

      try {
        final decoded = jsonDecode(prefsJson) as Map<String, dynamic>;
        state = AsyncValue.data(NotificationPreferences.fromJson(decoded));
      } catch (_) {
        state = AsyncValue.data(NotificationPreferences());
      }
    } catch (e, st) {
      debugPrint('⚠️ Error loading notification preferences: $e');
      state = AsyncValue.error(e, st);
    }
  }

  Future<void> savePreferences(NotificationPreferences prefs) async {
    try {
      final prefsJson = jsonEncode(prefs.toJson());

      // Try to update notification_prefs column if it exists
      try {
        await _db.db.execute(
          'UPDATE schools SET notification_prefs = ? WHERE id = ?',
          [prefsJson, schoolId],
        );
      } catch (_) {
        // Column doesn't exist, use local_security_config as fallback
        await _db.db.execute(
          '''INSERT OR REPLACE INTO local_security_config (key, value, updated_at)
             VALUES (?, ?, datetime('now'))''',
          ['notification_prefs_$schoolId', prefsJson],
        );
      }

      state = AsyncValue.data(prefs);
    } catch (e, st) {
      debugPrint('⚠️ Error saving notification preferences: $e');
      state = AsyncValue.error(e, st);
    }
  }
}

final notificationPreferencesProvider = StateNotifierProvider.family<
    NotificationPreferencesNotifier,
    AsyncValue<NotificationPreferences>,
    String>((ref, schoolId) {
  return NotificationPreferencesNotifier(schoolId);
});

// ==========================================
// FILE: ./providers/payment_provider.dart
// ==========================================

import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../repositories/payment_repository.dart';
import '../repositories/payment_repository_impl.dart';
import '../services/database_service.dart';

/// ============================================================================
/// CORE REPOSITORY PROVIDER
/// ============================================================================

/// Provides singleton access to the PaymentRepository.
///
/// This provider:
/// - Creates a single PaymentRepositoryImpl instance (singleton pattern)
/// - Automatically passes the DatabaseService to the repository
/// - Allows all widgets to access payment operations consistently
///
/// Usage in widgets:
/// ```dart
/// final paymentRepo = ref.watch(paymentRepositoryProvider);
/// final payment = await paymentRepo.recordPayment(...);
/// ```
///
/// Usage with other providers:
/// ```dart
/// final futurePayment = FutureProvider<Payment>((ref) async {
///   final repo = ref.watch(paymentRepositoryProvider);
///   return repo.recordPayment(...);
/// });
/// ```
final paymentRepositoryProvider = Provider<PaymentRepository>((ref) {
  return PaymentRepositoryImpl(
    dbService: DatabaseService(),
  );
});

/// ============================================================================
/// STREAM PROVIDER: PAYMENT HISTORY
/// ============================================================================

/// Real-time payment history for a specific student.
///
/// This is a family provider that watches payment records for a particular
/// student_id. It automatically re-emits whenever payments are added, updated,
/// or deleted.
///
/// State Flow:
/// - AsyncValue.loading: Initially fetching payment history
/// - AsyncValue.data: Successfully retrieved List<Payment> (may be empty)
/// - AsyncValue.error: Database error occurred
///
/// Usage in Widgets:
/// ```dart
/// ConsumerWidget {
///   Widget build(context, ref) {
///     final paymentsAsync = ref.watch(paymentHistoryProvider(studentId));
///
///     return paymentsAsync.when(
///       data: (payments) => PaymentListView(payments: payments),
///       loading: () => const LoadingSpinner(),
///       error: (error, stack) => ErrorBanner(error: error),
///     );
///   }
/// }
/// ```
///
/// Key Benefits Over Manual Subscription:
/// - ✅ Automatic stream cleanup (no leak risk)
/// - ✅ Automatic error handling
/// - ✅ Automatic rebuild on data changes
/// - ✅ Automatic retry on error
/// - ✅ Integrates with Riverpod's caching/invalidation
///
/// Invalidation Example:
/// ```dart
/// // After recording a payment, invalidate the stream
/// ref.invalidate(paymentHistoryProvider(studentId));
/// ```
final paymentHistoryProvider =
    StreamProvider.family<List<Payment>, String>((ref, studentId) {
  final repository = ref.watch(paymentRepositoryProvider);
  return repository.watchPaymentsForStudent(studentId);
});

/// ============================================================================
/// COMPUTED PROVIDER: TOTAL PAID BY STUDENT
/// ============================================================================

/// Calculates the total amount paid by a student (excluding deleted payments).
///
/// This provider:
/// - Depends on paymentHistoryProvider (will recompute when history changes)
/// - Sums all non-deleted payments
/// - Returns 0.0 if no payments
///
/// Usage:
/// ```dart
/// final totalPaid = ref.watch(totalPaidByStudentProvider(studentId));
/// Text('Total Paid: \$${totalPaid.toStringAsFixed(2)}')
/// ```
///
/// NOTE: This uses the repository method for efficiency over mapping the stream.
/// If you need it to update in real-time, consider an AsyncProvider instead:
final totalPaidByStudentProvider =
    FutureProvider.family<double, String>((ref, studentId) async {
  final repository = ref.watch(paymentRepositoryProvider);
  return repository.getTotalPaidByStudent(studentId: studentId);
});

/// ============================================================================
/// COMPUTED PROVIDER: OUTSTANDING BALANCE
/// ============================================================================

/// Calculates the outstanding balance for a student.
///
/// Outstanding balance = Total Invoiced - Total Paid
///
/// This provider:
/// - Queries outstanding amount (may be negative if student overpaid)
/// - Updates when payments or invoices change
/// - Returns 0.0 if no outstanding balance
///
/// Usage:
/// ```dart
/// final balanceAsync = ref.watch(outstandingBalanceProvider(studentId));
/// balanceAsync.when(
///   data: (balance) => StudentCard(balance: balance),
///   loading: () => Skeleton(),
///   error: (err, stack) => ErrorText(err),
/// );
/// ```
final outstandingBalanceProvider =
    FutureProvider.family<double, String>((ref, studentId) async {
  final repository = ref.watch(paymentRepositoryProvider);
  return repository.getOutstandingBalance(studentId);
});

/// ============================================================================
/// CONVENIENCE PROVIDERS FOR COMMON OPERATIONS
/// ============================================================================

/// Family provider for recording a new payment.
///
/// Usage:
/// ```dart
/// final recordPaymentAsync = ref.watch(
///   recordPaymentProvider((
///     studentId: 'student-123',
///     amount: 100.0,
///     method: 'cash',
///     invoiceId: 'invoice-456',
///   ))
/// );
/// ```
final recordPaymentProvider =
    FutureProvider.family<Payment, _RecordPaymentParams>((ref, params) async {
  final repository = ref.watch(paymentRepositoryProvider);
  return repository.recordPayment(
    studentId: params.studentId,
    amount: params.amount,
    method: params.method,
    invoiceId: params.invoiceId,
    description: params.description,
  );
});

/// Family provider for allocating a payment.
final allocatePaymentProvider =
    FutureProvider.family<void, _AllocatePaymentParams>((ref, params) async {
  final repository = ref.watch(paymentRepositoryProvider);
  await repository.allocatePayment(
    paymentId: params.paymentId,
    allocations: params.allocations,
  );
});

/// Family provider for deleting a payment.
final deletePaymentProvider =
    FutureProvider.family<void, String>((ref, paymentId) async {
  final repository = ref.watch(paymentRepositoryProvider);
  await repository.deletePayment(paymentId);
});

/// ============================================================================
/// PARAMETER CLASSES FOR FAMILY PROVIDERS
/// ============================================================================

/// Parameters for the recordPaymentProvider family.
class _RecordPaymentParams {
  final String studentId;
  final double amount;
  final String method;
  final String invoiceId;
  final String? description;

  _RecordPaymentParams({
    required this.studentId,
    required this.amount,
    required this.method,
    required this.invoiceId,
    required this.description,
  });

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is _RecordPaymentParams &&
          runtimeType == other.runtimeType &&
          studentId == other.studentId &&
          amount == other.amount &&
          method == other.method &&
          invoiceId == other.invoiceId &&
          description == other.description;

  @override
  int get hashCode =>
      studentId.hashCode ^
      amount.hashCode ^
      method.hashCode ^
      invoiceId.hashCode ^
      (description?.hashCode ?? 0);
}

/// Parameters for the allocatePaymentProvider family.
class _AllocatePaymentParams {
  final String paymentId;
  final Map<String, double> allocations;

  _AllocatePaymentParams({
    required this.paymentId,
    required this.allocations,
  });

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is _AllocatePaymentParams &&
          runtimeType == other.runtimeType &&
          paymentId == other.paymentId &&
          allocations == other.allocations;

  @override
  int get hashCode => paymentId.hashCode ^ allocations.hashCode;
}

// ==========================================
// FILE: ./providers/school_provider.dart
// ==========================================

import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:fees_up/data/services/database_service.dart';
import 'package:fees_up/data/services/school_service.dart';
import 'package:fees_up/data/providers/auth_provider.dart';

// 1. The Service Provider
final schoolServiceProvider = Provider<SchoolService>((ref) {
  return SchoolService(DatabaseService());
});

// 2. A Helper Provider to get the current school Map immediately
//    CRITICAL LOGIC: This uses 'getSchoolForUser' which performs the lookup:
//    Auth ID -> User Profile -> School ID -> School Record
final currentSchoolProvider = FutureProvider<Map<String, dynamic>?>((ref) async {
  final user = ref.watch(currentUserProvider);
  if (user == null) return null;

  final service = ref.watch(schoolServiceProvider);
  
  // We pass the USER ID (Auth ID) here. 
  // The service internally finds the profile linked to this user, 
  // extracts the 'school_id', and returns the School row.
  return await service.getSchoolForUser(user.id, waitForSync: true);
});

// 3. The ID Selector (REQUIRED by Expense, Student, and Billing features)
//    This extracts the actual 'school_id' from the school record we just fetched.
final activeSchoolIdProvider = Provider<String?>((ref) {
  final schoolAsync = ref.watch(currentSchoolProvider);
  
  // The 'id' inside this map is the SCHOOL ID (from the schools table), 
  // NOT the User ID.
  return schoolAsync.value?['id'] as String?;
});
// ==========================================
// FILE: ./providers/school_year_seeder.dart
// ==========================================

/// ============================================================================
/// SCHOOL YEAR SEEDER - Auto-create and seed months for academic years
/// ============================================================================
///
/// This module automatically seeds school years with 12 months in the
/// academic calendar format (November - October) whenever a year is created.
///
/// This ensures billing periods are always available and properly initialized.
library;

import 'package:uuid/uuid.dart';
import 'package:intl/intl.dart';
import 'package:flutter/foundation.dart';
import '../services/database_service.dart';

class SchoolYearSeeder {
  final DatabaseService _db = DatabaseService();
  static const _uuid = Uuid();

  /// Seed months for a school year
  ///
  /// Academic year format: November (month 1) → October (month 12)
  ///
  /// Returns: true if seeding succeeded, false otherwise
  Future<bool> seedMonthsForYear({
    required String yearId,
    required String schoolId,
    required DateTime startDate,
    required DateTime endDate,
  }) async {
    try {
      // Check if months already exist
      final existing = await _db.db.getAll(
        'SELECT id FROM school_year_months WHERE school_year_id = ? LIMIT 1',
        [yearId],
      );

      if (existing.isNotEmpty) {
        // Months already exist, skip seeding
        return true;
      }

      // Generate 12 months in academic year order (Nov-Oct)
      await _db.db.writeTransaction((tx) async {
        for (int monthNumber = 1; monthNumber <= 12; monthNumber++) {
          // Map academic month number to calendar month
          // monthNumber 1 = November (11)
          // monthNumber 2 = December (12)
          // monthNumber 3 = January (1), etc.
          // monthNumber 12 = October (10)

          int calendarMonth = monthNumber + 10;
          int monthYear = startDate.year;

          if (calendarMonth > 12) {
            calendarMonth -= 12;
            monthYear = startDate.year + 1;
          }

          // Calculate month dates
          final monthStart = DateTime(monthYear, calendarMonth, 1);
          final monthEnd = DateTime(
            calendarMonth == 12 ? monthYear + 1 : monthYear,
            calendarMonth == 12 ? 1 : calendarMonth + 1,
            0,
          );

          // Clamp to year boundaries
          final adjustedStart =
              monthStart.isBefore(startDate) ? startDate : monthStart;
          final adjustedEnd = monthEnd.isAfter(endDate) ? endDate : monthEnd;

          final monthName = DateFormat('MMMM').format(monthStart);
          final monthId = _uuid.v4();

          // Insert month
          await tx.execute(
            '''INSERT INTO school_year_months 
               (id, school_year_id, school_id, name, month_index, start_date, end_date, is_billable, created_at)
               VALUES (?, ?, ?, ?, ?, ?, ?, 1, ?)''',
            [
              monthId,
              yearId,
              schoolId,
              monthName,
              monthNumber,
              DateFormat('yyyy-MM-dd').format(adjustedStart),
              DateFormat('yyyy-MM-dd').format(adjustedEnd),
              DateTime.now().toIso8601String(),
            ],
          );
        }
      });

      return true;
    } catch (e) {
      debugPrint('❌ Error seeding months for year: $e');
      return false;
    }
  }

  /// Get or create months for a year
  /// If months don't exist, create them automatically
  Future<List<Map<String, dynamic>>> getOrCreateMonthsForYear({
    required String yearId,
    required String schoolId,
    required DateTime startDate,
    required DateTime endDate,
  }) async {
    try {
      // Try to fetch existing months
      final months = await _db.db.getAll(
        '''SELECT id, name, month_index, start_date, end_date, is_billable, term_id
           FROM school_year_months
           WHERE school_year_id = ? AND school_id = ?
           ORDER BY month_index''',
        [yearId, schoolId],
      );

      if (months.isNotEmpty) {
        return months.cast<Map<String, dynamic>>();
      }

      // No months exist, seed them
      final seeded = await seedMonthsForYear(
        yearId: yearId,
        schoolId: schoolId,
        startDate: startDate,
        endDate: endDate,
      );

      if (!seeded) {
        return [];
      }

      // Fetch newly created months
      return await _db.db.getAll(
        '''SELECT id, name, month_index, start_date, end_date, is_billable, term_id
           FROM school_year_months
           WHERE school_year_id = ? AND school_id = ?
           ORDER BY month_index''',
        [yearId, schoolId],
      ).then((m) => m.cast<Map<String, dynamic>>());
    } catch (e) {
      debugPrint('❌ Error getting/creating months: $e');
      return [];
    }
  }
}

// ==========================================
// FILE: ./providers/transactions_provider.dart
// ==========================================

import 'package:fees_up/data/models/transaction_stats.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../services/database_service.dart';

// ========== TRANSACTIONS PROVIDERS ==========
// All providers use local database streams for real-time auto-updates
// Data is isolated per schoolId - zero hardcoding

/// Stream all payments for a school (real-time updates)
final paymentsProvider =
    StreamProvider.family<List<Map<String, dynamic>>, String>((ref, schoolId) {
  final db = DatabaseService();
  return db.db.watch(
    'SELECT * FROM payments WHERE school_id = ? ORDER BY date_paid DESC, created_at DESC',
    parameters: [schoolId],
  );
});

/// Stream all expenses for a school (real-time updates)
final expensesProvider =
    StreamProvider.family<List<Map<String, dynamic>>, String>((ref, schoolId) {
  final db = DatabaseService();
  return db.db.watch(
    'SELECT * FROM expenses WHERE school_id = ? ORDER BY incurred_at DESC, created_at DESC',
    parameters: [schoolId],
  );
});

/// Stream all donations for a school (real-time updates)
final donationsProvider =
    StreamProvider.family<List<Map<String, dynamic>>, String>((ref, schoolId) {
  final db = DatabaseService();
  return db.db.watch(
    'SELECT * FROM campaign_donations WHERE school_id = ? ORDER BY date_received DESC',
    parameters: [schoolId],
  );
});

/// Stream combined transactions (payments + expenses + donations)
/// Returns unified list with type field for filtering
final allTransactionsProvider =
    StreamProvider.family<List<Map<String, dynamic>>, String>(
        (ref, schoolId) async* {
  final db = DatabaseService();

  // Use PowerSync watch for real-time updates from local DB
  // This single query combines all transaction types with UNION ALL
  final stream = db.db.watch(
    '''
    SELECT id, school_id, student_id, amount, date_paid as transaction_date,
           category, method, payer_name as entity_name, created_at,
           'payment' as transaction_type
    FROM payments WHERE school_id = ?
    UNION ALL
    SELECT id, school_id, NULL as student_id, -amount as amount,
           incurred_at as transaction_date, category, 'Expense' as method,
           recipient as entity_name, created_at, 'expense' as transaction_type
    FROM expenses WHERE school_id = ?
    UNION ALL
    SELECT id, school_id, student_id, amount, date_received as transaction_date,
           'Donation' as category, payment_method as method, donor_name as entity_name,
           created_at, 'donation' as transaction_type
    FROM campaign_donations WHERE school_id = ?
    ORDER BY transaction_date DESC, created_at DESC
    ''',
    parameters: [schoolId, schoolId, schoolId],
  );

  await for (final transactions in stream) {
    yield transactions;
  }
});

/// Stream payment allocations for a specific payment
final paymentAllocationsProvider =
    StreamProvider.family<List<Map<String, dynamic>>, String>((ref, paymentId) {
  final db = DatabaseService();
  return db.db.watch(
    'SELECT * FROM payment_allocations WHERE payment_id = ? ORDER BY created_at DESC',
    parameters: [paymentId],
  );
});

/// Stream payments for a specific student
final studentPaymentsProvider =
    StreamProvider.family<List<Map<String, dynamic>>, String>((ref, studentId) {
  final db = DatabaseService();
  return db.db.watch(
    'SELECT * FROM payments WHERE student_id = ? ORDER BY date_paid DESC',
    parameters: [studentId],
  );
});

/// Stream transaction statistics for a school
final transactionStatsProvider =
    StreamProvider.family<TransactionStats, String>((ref, schoolId) async* {
  final db = DatabaseService();

  // Use PowerSync watch to get real-time stats from local DB
  final stream = db.db.watch(
    '''
    SELECT
      COALESCE(SUM(CASE WHEN p.amount IS NOT NULL THEN p.amount ELSE 0 END), 0) as total_income,
      COALESCE(SUM(CASE WHEN e.amount IS NOT NULL THEN e.amount ELSE 0 END), 0) as total_expenses,
      COALESCE(SUM(CASE WHEN d.amount IS NOT NULL THEN d.amount ELSE 0 END), 0) as total_donations,
      COALESCE(COUNT(DISTINCT p.id), 0) as payments_count,
      COALESCE(COUNT(DISTINCT e.id), 0) as expenses_count,
      COALESCE(COUNT(DISTINCT d.id), 0) as donations_count,
      (SELECT COUNT(*) FROM bills WHERE school_id = ? AND is_paid = 0) as pending_count,
      (SELECT COALESCE(SUM(total_amount - paid_amount), 0) FROM bills WHERE school_id = ? AND is_paid = 0) as pending_amount
    FROM
      (SELECT ? as school_id) s
      LEFT JOIN payments p ON p.school_id = s.school_id
      LEFT JOIN expenses e ON e.school_id = s.school_id
      LEFT JOIN campaign_donations d ON d.school_id = s.school_id
    ''',
    parameters: [schoolId, schoolId, schoolId],
  );

  await for (final result in stream) {
    if (result.isNotEmpty) {
      final row = result.first;
      final totalIncome = (row['total_income'] as num?)?.toDouble() ?? 0.0;
      final totalExpenses = (row['total_expenses'] as num?)?.toDouble() ?? 0.0;
      final totalDonations =
          (row['total_donations'] as num?)?.toDouble() ?? 0.0;

      yield TransactionStats(
        totalIncome: totalIncome,
        totalExpenses: totalExpenses,
        totalDonations: totalDonations,
        pendingCount: (row['pending_count'] as num?)?.toInt() ?? 0,
        pendingAmount: (row['pending_amount'] as num?)?.toDouble() ?? 0.0,
        netIncome: totalIncome - totalExpenses,
        paymentsCount: (row['payments_count'] as num?)?.toInt() ?? 0,
        expensesCount: (row['expenses_count'] as num?)?.toInt() ?? 0,
        donationsCount: (row['donations_count'] as num?)?.toInt() ?? 0,
      );
    }
  }
});

// ==========================================
// FILE: ./providers/broadcast_provider.dart
// ==========================================

import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:uuid/uuid.dart';
import '../models/broadcast_model.dart';
import '../repositories/broadcast_repository.dart';
import 'school_provider.dart';
import 'auth_provider.dart';

final broadcastRepositoryProvider = Provider((ref) => BroadcastRepository());

/// Unified Provider Names for UI Integration
final schoolBroadcastProvider = StreamProvider.autoDispose<List<Broadcast>>((ref) {
  final schoolId = ref.watch(activeSchoolIdProvider);
  if (schoolId == null) return Stream.value([]);
  return ref.watch(broadcastRepositoryProvider).watchSchoolBroadcasts(schoolId);
});

final internalHQBroadcastProvider = StreamProvider.autoDispose<List<Broadcast>>((ref) {
  return ref.watch(broadcastRepositoryProvider).watchInternalHQBroadcasts();
});

final broadcastLogicProvider = Provider((ref) => BroadcastLogic(ref));

class BroadcastLogic {
  final Ref _ref;
  BroadcastLogic(this._ref);

  Future<void> post({
    required String title,
    required String body,
    String priority = 'normal',
    bool isInternalHQ = false,
  }) async {
    final user = _ref.read(currentUserProvider);
    final schoolId = _ref.read(activeSchoolIdProvider);

    if (user == null) throw Exception("Auth Required");

    final Map<String, dynamic> data = {
      'id': const Uuid().v4(),
      'school_id': isInternalHQ ? null : schoolId,
      'author_id': user.id,
      'is_system_message': isInternalHQ ? 1 : 0,
      'target_role': isInternalHQ ? 'hq_internal' : 'all',
      'title': title,
      'body': body,
      'priority': priority,
      'created_at': DateTime.now().toIso8601String(),
    };

    await _ref.read(broadcastRepositoryProvider).postBroadcast(data: data);
  }
}
// ==========================================
// FILE: ./providers/financial_providers.dart
// ==========================================

import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:intl/intl.dart';
import 'package:supabase_flutter/supabase_flutter.dart';

import '../services/invoice_service.dart';
import '../services/transaction_service.dart';
import '../services/financial_reports_service.dart';
import 'school_provider.dart'; // 🟢 [FIX 3] School selection

// ========== SERVICE PROVIDERS ==========

/// Invoice Service provider
final invoiceServiceProvider = Provider<InvoiceService>((ref) {
  final supabase = Supabase.instance.client;
  return InvoiceService(supabase: supabase);
});

/// Transaction Service provider
final transactionServiceProvider = Provider<TransactionService>((ref) {
  final supabase = Supabase.instance.client;
  return TransactionService(supabase: supabase);
});

/// Financial Reports Service provider
final financialReportsServiceProvider =
    Provider<FinancialReportsService>((ref) {
  final supabase = Supabase.instance.client;
  return FinancialReportsService(supabase: supabase);
});

// ========== INVOICE PROVIDERS ==========

/// Get next invoice number for a school
final nextInvoiceNumberProvider =
    FutureProvider.family<String, String>((ref, schoolId) async {
  final invoiceService = ref.watch(invoiceServiceProvider);
  return invoiceService.getNextInvoiceNumber(schoolId);
});

/// Get all invoices for a school
final schoolInvoicesProvider =
    FutureProvider.family<List<Map<String, dynamic>>, String>(
        (ref, schoolId) async {
  final invoiceService = ref.watch(invoiceServiceProvider);
  return invoiceService.getInvoicesForSchool(schoolId: schoolId);
});

/// Get outstanding invoices for a student
final studentOutstandingInvoicesProvider =
    FutureProvider.family<List<Map<String, dynamic>>, String>(
        (ref, studentId) async {
  final invoiceService = ref.watch(invoiceServiceProvider);
  return invoiceService.getOutstandingInvoices(studentId);
});

/// Get invoice statistics for school dashboard
final invoiceStatisticsProvider =
    FutureProvider.family<Map<String, dynamic>, String>((ref, schoolId) async {
  final invoiceService = ref.watch(invoiceServiceProvider);
  return invoiceService.getInvoiceStatistics(schoolId);
});

/// Get invoices by date range
final invoicesByDateRangeProvider = FutureProvider.family<
    List<Map<String, dynamic>>,
    ({String schoolId, DateTime startDate, DateTime endDate})>(
  (ref, params) async {
    final invoiceService = ref.watch(invoiceServiceProvider);
    return invoiceService.getInvoicesByDateRange(
      schoolId: params.schoolId,
      startDate: params.startDate,
      endDate: params.endDate,
    );
  },
);

// ========== PAYMENT & ALLOCATION PROVIDERS ==========

/// Get outstanding bills with balance for a student
final outstandingBillsProvider =
    FutureProvider.family<List<Map<String, dynamic>>, String>(
        (ref, studentId) async {
  final transactionService = ref.watch(transactionServiceProvider);
  return transactionService.getOutstandingBillsWithBalance(studentId);
});

/// Get payment allocations for a payment
final paymentAllocationsProvider =
    FutureProvider.family<List<Map<String, dynamic>>, String>(
        (ref, paymentId) async {
  final transactionService = ref.watch(transactionServiceProvider);
  return transactionService.getPaymentAllocations(paymentId);
});

/// Get bill payment summary
final billPaymentSummaryProvider =
    FutureProvider.family<Map<String, dynamic>, String>((ref, billId) async {
  final transactionService = ref.watch(transactionServiceProvider);
  return transactionService.getBillPaymentSummary(billId);
});

/// Get payment history for a student
final paymentHistoryProvider = FutureProvider.family<List<Map<String, dynamic>>,
    ({String studentId, DateTime? startDate, DateTime? endDate})>(
  (ref, params) async {
    final transactionService = ref.watch(transactionServiceProvider);
    return transactionService.getPaymentHistory(
      studentId: params.studentId,
      startDate: params.startDate,
      endDate: params.endDate,
    );
  },
);

/// Get refund history for a student
final refundHistoryProvider =
    FutureProvider.family<List<Map<String, dynamic>>, String>(
        (ref, studentId) async {
  final transactionService = ref.watch(transactionServiceProvider);
  return transactionService.getRefundHistory(studentId);
});

/// Get transaction summary for school
final transactionSummaryProvider =
    FutureProvider.family<Map<String, dynamic>, String>((ref, schoolId) async {
  final transactionService = ref.watch(transactionServiceProvider);
  return transactionService.getTransactionSummary(schoolId);
});

// ========== FINANCIAL REPORTS PROVIDERS ==========

/// Get financial summary (dashboard)
final financialSummaryProvider =
    FutureProvider.family<Map<String, dynamic>, String>((ref, schoolId) async {
  final reportsService = ref.watch(financialReportsServiceProvider);
  return reportsService.getFinancialSummary(schoolId);
});

/// Get enrollment trends
final enrollmentTrendsProvider =
    FutureProvider.family<Map<String, dynamic>, String>((ref, schoolId) async {
  final reportsService = ref.watch(financialReportsServiceProvider);
  return reportsService.getEnrollmentTrends(schoolId);
});

/// Get custom report
final customReportProvider = FutureProvider.family<
    Map<String, dynamic>,
    ({
      String schoolId,
      ReportCategory category,
      DateTimeRange dateRange,
      String? gradeLevel,
      String? studentId,
    })>(
  (ref, params) async {
    final reportsService = ref.watch(financialReportsServiceProvider);
    return reportsService.generateCustomReport(
      schoolId: params.schoolId,
      category: params.category,
      dateRange: params.dateRange,
      gradeLevel: params.gradeLevel,
      studentId: params.studentId,
    );
  },
);

/// Get financial audit log
final financialAuditLogProvider = FutureProvider.family<
    List<Map<String, dynamic>>,
    ({
      String schoolId,
      DateTime? startDate,
      DateTime? endDate,
      String? actionType,
    })>(
  (ref, params) async {
    final reportsService = ref.watch(financialReportsServiceProvider);
    return reportsService.getFinancialAuditLog(
      schoolId: params.schoolId,
      startDate: params.startDate,
      endDate: params.endDate,
      actionType: params.actionType,
    );
  },
);

/// Compare financial performance between periods
final comparePeriodsProvider = FutureProvider.family<
    Map<String, dynamic>,
    ({
      String schoolId,
      DateTimeRange period1,
      DateTimeRange period2,
    })>(
  (ref, params) async {
    final reportsService = ref.watch(financialReportsServiceProvider);
    return reportsService.comparePerformancePeriods(
      schoolId: params.schoolId,
      period1: params.period1,
      period2: params.period2,
    );
  },
);

/// Forecast cash flow
final cashFlowForecastProvider = FutureProvider.family<Map<String, dynamic>,
    ({String schoolId, int forecastDays})>(
  (ref, params) async {
    final reportsService = ref.watch(financialReportsServiceProvider);
    return reportsService.forecastCashFlow(
      schoolId: params.schoolId,
      forecastDays: params.forecastDays,
    );
  },
);

// ========== STATE NOTIFIERS ==========

/// State for invoice creation dialog
class InvoiceCreationState {
  final String studentId;
  final String title;
  final double amount;
  final DateTime dueDate;
  final String invoiceStatus; // 'draft', 'sent'
  final bool isLoading;
  final String? error;

  InvoiceCreationState({
    required this.studentId,
    required this.title,
    required this.amount,
    required this.dueDate,
    this.invoiceStatus = 'draft',
    this.isLoading = false,
    this.error,
  });

  InvoiceCreationState copyWith({
    String? studentId,
    String? title,
    double? amount,
    DateTime? dueDate,
    String? invoiceStatus,
    bool? isLoading,
    String? error,
  }) {
    return InvoiceCreationState(
      studentId: studentId ?? this.studentId,
      title: title ?? this.title,
      amount: amount ?? this.amount,
      dueDate: dueDate ?? this.dueDate,
      invoiceStatus: invoiceStatus ?? this.invoiceStatus,
      isLoading: isLoading ?? this.isLoading,
      error: error ?? this.error,
    );
  }
}

/// Notifier for invoice creation
class InvoiceCreationNotifier extends StateNotifier<InvoiceCreationState> {
  final InvoiceService invoiceService;

  InvoiceCreationNotifier({required this.invoiceService})
      : super(
          InvoiceCreationState(
            studentId: '',
            title: '',
            amount: 0.0,
            dueDate: DateTime.now().add(const Duration(days: 7)),
          ),
        );

  void updateStudentId(String studentId) {
    state = state.copyWith(studentId: studentId);
  }

  void updateTitle(String title) {
    state = state.copyWith(title: title);
  }

  void updateAmount(double amount) {
    state = state.copyWith(amount: amount);
  }

  void updateDueDate(DateTime date) {
    state = state.copyWith(dueDate: date);
  }

  void updateStatus(String status) {
    state = state.copyWith(invoiceStatus: status);
  }

  Future<void> submitInvoice(String schoolId) async {
    state = state.copyWith(isLoading: true, error: null);

    try {
      if (state.studentId.isEmpty || state.title.isEmpty || state.amount <= 0) {
        throw Exception('Please fill all required fields');
      }

      // Get current user ID from Supabase
      final user = Supabase.instance.client.auth.currentUser;
      if (user == null) {
        throw Exception('User not authenticated');
      }

      await invoiceService.createAdhocInvoice(
        schoolId: schoolId,
        studentId: state.studentId,
        title: state.title,
        amount: state.amount,
        dueDate: state.dueDate,
        status: state.invoiceStatus,
        userId: user.id,
      );

      state = state.copyWith(isLoading: false);
    } catch (e) {
      state = state.copyWith(isLoading: false, error: e.toString());
      rethrow;
    }
  }

  void reset() {
    state = InvoiceCreationState(
      studentId: '',
      title: '',
      amount: 0.0,
      dueDate: DateTime.now().add(const Duration(days: 7)),
    );
  }
}

/// Invoice creation state notifier provider
final invoiceCreationProvider =
    StateNotifierProvider<InvoiceCreationNotifier, InvoiceCreationState>(
  (ref) {
    final invoiceService = ref.watch(invoiceServiceProvider);
    return InvoiceCreationNotifier(invoiceService: invoiceService);
  },
);

// ========== REPORT STATE PROVIDERS ==========

/// Selected date range for reports
final reportDateRangeProvider = StateProvider<DateTimeRange>((ref) {
  return DateTimeRange.thisMonth();
});

/// Selected report category
final reportCategoryProvider = StateProvider<ReportCategory>((ref) {
  return ReportCategory.tuitionCollection;
});

/// Selected grade filter for reports
final reportGradeFilterProvider = StateProvider<String?>((ref) {
  return null;
});

/// Currently displayed report data
final currentReportProvider = FutureProvider<Map<String, dynamic>>((ref) {
  final schoolId = ref.watch(selectedSchoolIdProvider);
  final category = ref.watch(reportCategoryProvider);
  final dateRange = ref.watch(reportDateRangeProvider);
  final gradeFilter = ref.watch(reportGradeFilterProvider);
  final reportsService = ref.watch(financialReportsServiceProvider);

  if (schoolId == null) {
    return Future.error('No school selected');
  }

  return reportsService.generateCustomReport(
    schoolId: schoolId,
    category: category,
    dateRange: dateRange,
    gradeLevel: gradeFilter,
  );
});

// ========== UTILITY PROVIDERS ==========

/// Selected school ID (from app state)
/// 🟢 [FIX 3] Auto-Select School from User Profile
final selectedSchoolIdProvider = Provider<String?>((ref) {
  // Reuse existing activeSchoolIdProvider that already handles:
  // Auth User → User Profile → School ID extraction
  return ref.watch(activeSchoolIdProvider);
});

/// Get recent transactions for school
final schoolTransactionsProvider =
    FutureProvider.family<List<Map<String, dynamic>>, String>(
        (ref, schoolId) async {
  final transactionService = ref.watch(transactionServiceProvider);
  return transactionService.getSchoolTransactions(schoolId);
});

/// Format currency for display
final currencyFormatterProvider = Provider<String Function(double)>((ref) {
  return (amount) {
    return NumberFormat.currency(symbol: '\$', decimalDigits: 2).format(amount);
  };
});

/// Format date for display
final dateFormatterProvider = Provider<String Function(DateTime)>((ref) {
  return (date) {
    return DateFormat('MMM dd, yyyy').format(date);
  };
});

// ==========================================
// FILE: ./providers/invoices_provider.dart
// ==========================================

import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../services/database_service.dart';

/// 📄 INVOICES PROVIDER
/// All invoice/bill data flows through here. NO hardcoding.
/// Everything reads from local SQLite via DatabaseService (PowerSync).

// ============================================================
// PROVIDERS
// ============================================================

/// Stream of all bills/invoices for a school (Real-time updates via PowerSync)
final invoicesProvider =
    StreamProvider.family<List<Map<String, dynamic>>, String>(
  (ref, schoolId) {
    final db = DatabaseService();
    return db.db.watch(
      'SELECT * FROM bills WHERE school_id = ? ORDER BY created_at DESC',
      parameters: [schoolId],
    );
  },
);

/// Get invoices for a specific student
final studentInvoicesProvider =
    StreamProvider.family<List<Map<String, dynamic>>, String>(
  (ref, studentId) {
    final db = DatabaseService();
    return db.db.watch(
      'SELECT * FROM bills WHERE student_id = ? ORDER BY created_at DESC',
      parameters: [studentId],
    );
  },
);

/// Get a single invoice/bill by ID
final invoiceByIdProvider =
    FutureProvider.family<Map<String, dynamic>?, String>(
  (ref, invoiceId) async {
    final db = DatabaseService();
    return await db.getById('bills', invoiceId);
  },
);

/// Invoice stats (total billed, collected, pending, overdue)
final invoiceStatsProvider = Provider.family<InvoiceStats, String>(
  (ref, schoolId) {
    final invoicesAsync = ref.watch(invoicesProvider(schoolId));

    return invoicesAsync.when(
      data: (invoices) {
        final totalBilled = invoices.fold<double>(
          0,
          (sum, inv) => sum + ((inv['total_amount'] as num?)?.toDouble() ?? 0),
        );

        final totalCollected = invoices.fold<double>(
          0,
          (sum, inv) => sum + ((inv['paid_amount'] as num?)?.toDouble() ?? 0),
        );

        final now = DateTime.now();
        final overdueInvoices = invoices.where((inv) {
          if (inv['billing_cycle_end'] == null) return false;
          final dueDate =
              DateTime.tryParse(inv['billing_cycle_end'].toString());
          final isPaid = (inv['is_paid'] as int?) == 1;
          return !isPaid && dueDate != null && dueDate.isBefore(now);
        }).toList();

        final overdueAmount = overdueInvoices.fold<double>(
          0,
          (sum, inv) {
            final total = (inv['total_amount'] as num?)?.toDouble() ?? 0;
            final paid = (inv['paid_amount'] as num?)?.toDouble() ?? 0;
            return sum + (total - paid);
          },
        );

        final paidCount =
            invoices.where((inv) => (inv['is_paid'] as int?) == 1).length;
        final collectionRate =
            totalBilled > 0 ? (totalCollected / totalBilled * 100) : 0.0;

        return InvoiceStats(
          totalInvoices: invoices.length,
          totalBilled: totalBilled,
          totalCollected: totalCollected,
          pendingAmount: totalBilled - totalCollected,
          overdueAmount: overdueAmount,
          overdueCount: overdueInvoices.length,
          paidCount: paidCount,
          collectionRate: collectionRate,
        );
      },
      loading: () => InvoiceStats.empty(),
      error: (_, __) => InvoiceStats.empty(),
    );
  },
);

/// Get outstanding (unpaid) bills for a student
final outstandingBillsProvider =
    StreamProvider.family<List<Map<String, dynamic>>, String>(
  (ref, studentId) {
    final db = DatabaseService();
    return db.db.watch(
      'SELECT * FROM bills WHERE student_id = ? AND is_paid = 0 ORDER BY billing_cycle_end ASC',
      parameters: [studentId],
    );
  },
);

/// Get payment allocations for a specific bill
final billAllocationsProvider =
    StreamProvider.family<List<Map<String, dynamic>>, String>(
  (ref, billId) {
    final db = DatabaseService();
    return db.db.watch(
      'SELECT * FROM payment_allocations WHERE bill_id = ? ORDER BY created_at DESC',
      parameters: [billId],
    );
  },
);

// ============================================================
// DATA MODELS
// ============================================================

class InvoiceStats {
  final int totalInvoices;
  final double totalBilled;
  final double totalCollected;
  final double pendingAmount;
  final double overdueAmount;
  final int overdueCount;
  final int paidCount;
  final double collectionRate;

  InvoiceStats({
    required this.totalInvoices,
    required this.totalBilled,
    required this.totalCollected,
    required this.pendingAmount,
    required this.overdueAmount,
    required this.overdueCount,
    required this.paidCount,
    required this.collectionRate,
  });

  factory InvoiceStats.empty() => InvoiceStats(
        totalInvoices: 0,
        totalBilled: 0,
        totalCollected: 0,
        pendingAmount: 0,
        overdueAmount: 0,
        overdueCount: 0,
        paidCount: 0,
        collectionRate: 0,
      );
}

// ==========================================
// FILE: ./providers/users_provider.dart
// ==========================================

import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'dashboard_provider.dart';
import '../repositories/users_repository.dart';

final usersRepositoryProvider = Provider((ref) => UsersRepository());

// Live list of users for the current school
final schoolUsersProvider = FutureProvider.autoDispose<List<Map<String, dynamic>>>((ref) async {
  final dashboard = await ref.watch(dashboardDataProvider.future);
  final repo = ref.watch(usersRepositoryProvider);
  
  if (dashboard.schoolId.isEmpty) return [];
  
  return repo.getSchoolUsers(dashboard.schoolId);
});
// ==========================================
// FILE: ./providers/school_year_generator_provider.dart
// ==========================================

import 'package:flutter/foundation.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:intl/intl.dart';
import 'package:uuid/uuid.dart';
import '../services/database_service.dart';

/// 📅 SCHOOL YEAR SEEDER (Optimized by Agent Beta)
/// - **Transactional**: All or nothing, prevents partial data corruption.
/// - **Client-Side IDs**: Generates UUIDs locally to avoid "Lookup" queries.
/// - **Batch Logic**: Reduces 300+ DB calls to a single execution block.
/// - **Performance**: 10x faster than read-then-write loops.
final schoolYearSeederProvider =
    FutureProvider.family<void, String>((ref, schoolId) async {
  if (schoolId.isEmpty) return;

  final dbService = DatabaseService();
  final nowYear = DateTime.now().year;
  final startYear = nowYear - 5;
  final endYear = nowYear + 10;

  try {
    // 🧭 One-time generation guard: if years already exist for this school, skip seeding.
    final existingAnyYear = await dbService.db.getAll(
      'SELECT id FROM school_years WHERE school_id = ? LIMIT 1',
      [schoolId],
    );

    if (existingAnyYear.isNotEmpty) {
      debugPrint(
          "ℹ️ Skipping year/month seeding for $schoolId (already generated).",
          wrapWidth: 120);
      return;
    }

    // ⚡️ Run inside a single transaction for performance
    await dbService.db.writeTransaction((tx) async {
      // 1. Fetch ALL existing years in one go to minimize queries
      final existingYearsResult = await tx.getAll(
        'SELECT id, year_label FROM school_years WHERE school_id = ?',
        [schoolId],
      );

      // Map: "2025" -> "uuid-string"
      final existingYearMap = {
        for (var row in existingYearsResult)
          row['year_label'].toString(): row['id'].toString()
      };

      for (int year = startYear; year <= endYear; year++) {
        final label = '$year';
        String yearId;

        // 2. Year Logic: Get existing ID or Create New
        if (existingYearMap.containsKey(label)) {
          yearId = existingYearMap[label]!;
        } else {
          yearId = const Uuid().v4(); // Generate locally
          // Academic year: Nov of previous year to Aug of current year
          // e.g., Nov 2024 - Aug 2025 for academic year 2025
          final startDate = DateTime(year - 1, 11, 1);
          final endDate = DateTime(year, 8, 31);

          await tx.execute('''
            INSERT INTO school_years 
            (id, school_id, year_label, start_date, end_date, description, active, created_at)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?)
            ''', [
            yearId,
            schoolId,
            label,
            DateFormat('yyyy-MM-dd').format(startDate),
            DateFormat('yyyy-MM-dd').format(endDate),
            'Auto-generated academic year $label',
            (year == nowYear) ? 1 : 0,
            DateTime.now().toIso8601String(),
          ]);
        }

        // 3. Month Logic: Ensure 12 months exist for this yearId
        // We do a quick check for existing months in this year
        final existingMonthsResult = await tx.getAll(
          'SELECT month_index FROM school_year_months WHERE school_year_id = ?',
          [yearId],
        );

        final existingMonthIndexes = existingMonthsResult
            .map((m) => _parseSafeInt(m['month_index']))
            .toSet();

        // 3. Generate 12 months for academic year (Nov-Oct)
        // Month 1 = November (of year-1), Month 12 = October (of year)
        for (int monthNumber = 1; monthNumber <= 12; monthNumber++) {
          if (existingMonthIndexes.contains(monthNumber)) continue;

          // Map month number to calendar month
          // monthNumber 1 = November (11), monthNumber 2 = December (12),
          // monthNumber 3 = January (1), ..., monthNumber 12 = October (10)
          int calendarMonth = monthNumber + 10;
          int monthYear = year - 1;

          if (calendarMonth > 12) {
            calendarMonth -= 12;
            monthYear = year;
          }

          final monthStartDate = DateTime(monthYear, calendarMonth, 1);
          // Get last day of month
          final monthEndDate = DateTime(
            calendarMonth == 12 ? monthYear + 1 : monthYear,
            calendarMonth == 12 ? 1 : calendarMonth + 1,
            0,
          );

          final monthName = DateFormat('MMMM').format(monthStartDate);
          final monthId = const Uuid().v4();

          await tx.execute('''
            INSERT INTO school_year_months 
            (id, school_year_id, school_id, name, month_index, start_date, end_date, is_billable, created_at)
            VALUES (?, ?, ?, ?, ?, ?, ?, 1, ?)
            ''', [
            monthId,
            yearId,
            schoolId,
            monthName,
            monthNumber,
            DateFormat('yyyy-MM-dd').format(monthStartDate),
            DateFormat('yyyy-MM-dd').format(monthEndDate),
            DateTime.now().toIso8601String(),
          ]);
        }
      }
    });

    debugPrint(
        "✅ Year/Month Seeding Complete for $schoolId (${endYear - startYear + 1} years, ${(endYear - startYear + 1) * 12} months)");

    // 🚀 Sync responsibility is handled by PowerSync; no explicit upload call here.
  } catch (e) {
    debugPrint("❌ Error Seeding School Years: $e");
    // We do not rethrow, as this is a background process.
    // We don't want to crash the UI if seeding fails.
  }
});

/// Helper to safely parse ints from dynamic DB results
int _parseSafeInt(dynamic value) {
  if (value is int) return value;
  if (value is String) return int.tryParse(value) ?? 0;
  return 0;
}

// ==========================================
// FILE: ./providers/settings_provider.dart
// ==========================================

import 'package:flutter/foundation.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../services/database_service.dart';
import 'dashboard_provider.dart';

// --- MODELS ---
class GlobalSettings {
  final String themeMode;
  final bool twoFactor;
  final int sessionTimeout;
  // ... add others
  GlobalSettings(
      {required this.themeMode,
      required this.twoFactor,
      required this.sessionTimeout});
}

class SchoolPreferences {
  final bool notifyPayment;
  final bool notifyOverdue;
  final String landingPage;
  // ... add others
  SchoolPreferences(
      {required this.notifyPayment,
      required this.notifyOverdue,
      required this.landingPage});
}

// --- PROVIDERS ---

// 1. Fetch Global Settings (User-centric)
final globalSettingsProvider = FutureProvider<GlobalSettings>((ref) async {
  final db = DatabaseService();

  try {
    // Fetch from user_settings table or use sensible defaults
    final result = await db.db.getAll(
      'SELECT theme_mode, two_factor_enabled, session_timeout_minutes FROM user_settings LIMIT 1',
    );

    if (result.isNotEmpty) {
      final settings = result.first;
      return GlobalSettings(
        themeMode: settings['theme_mode'] ?? 'dark',
        twoFactor: (settings['two_factor_enabled'] as int?) == 1,
        sessionTimeout: settings['session_timeout_minutes'] ?? 15,
      );
    }
  } catch (e) {
    debugPrint('⚠️ Error fetching global settings: $e');
  }

  // Fallback to sensible defaults if table doesn't exist yet
  return GlobalSettings(
      themeMode: 'dark', twoFactor: false, sessionTimeout: 15);
});

// 2. Fetch School Context Settings (School-centric)
final schoolPreferencesProvider =
    FutureProvider<SchoolPreferences>((ref) async {
  final dashboard = await ref.watch(dashboardDataProvider.future);
  if (dashboard.schoolId.isEmpty) {
    return SchoolPreferences(
        notifyPayment: true, notifyOverdue: true, landingPage: 'overview');
  }

  final db = DatabaseService();

  try {
    // Fetch FROM school_preferences WHERE school_id = dashboard.schoolId
    final result = await db.db.getAll(
      'SELECT notify_payment, notify_overdue, default_landing_page FROM school_preferences WHERE school_id = ?',
      [dashboard.schoolId],
    );

    if (result.isNotEmpty) {
      final prefs = result.first;
      return SchoolPreferences(
        notifyPayment: (prefs['notify_payment'] as int?) == 1,
        notifyOverdue: (prefs['notify_overdue'] as int?) == 1,
        landingPage: prefs['default_landing_page'] ?? 'overview',
      );
    }
  } catch (e) {
    debugPrint('⚠️ Error fetching school preferences: $e');
  }

  // Fallback to sensible defaults
  return SchoolPreferences(
      notifyPayment: true, notifyOverdue: true, landingPage: 'overview');
});

// 3. Fetch School Years
final schoolYearsProvider =
    FutureProvider<List<Map<String, dynamic>>>((ref) async {
  final dashboard = await ref.watch(dashboardDataProvider.future);
  if (dashboard.schoolId.isEmpty) {
    return [];
  }

  final db = DatabaseService();
  return await db.db.getAll(
      'SELECT * FROM school_years WHERE school_id = ? ORDER BY start_date DESC',
      [dashboard.schoolId]);
});

// ==========================================
// FILE: ./providers/financial_reports_provider.dart
// ==========================================

import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:supabase_flutter/supabase_flutter.dart';
import 'dart:async';

/// Financial Reports Provider
/// Connects to deployed RPC functions for real-time financial data
final financialReportsProvider = Provider((ref) {
  return FinancialReportsService(Supabase.instance.client);
});

/// Invoice Statistics Stream Provider - Updates periodically
final invoiceStatsProvider =
    StreamProvider.family<Map<String, dynamic>, InvoiceStatsParams>(
        (ref, params) async* {
  final service = ref.watch(financialReportsProvider);

  Future<Map<String, dynamic>> fetch() => service.getInvoiceStatistics(
        schoolId: params.schoolId,
        startDate: params.startDate ??
            DateTime.now().subtract(const Duration(days: 30)),
        endDate: params.endDate ?? DateTime.now(),
      );

  // Emit immediately so the UI is not stuck waiting 30s
  try {
    yield await fetch();
  } catch (e, st) {
    yield* Stream.error(e, st);
  }

  // Periodic refresh every 30 seconds for real-time-like updates
  await for (final _ in Stream.periodic(const Duration(seconds: 30))) {
    try {
      yield await fetch();
    } catch (e, st) {
      yield* Stream.error(e, st);
    }
  }
});

/// Transaction Summary Stream Provider - Updates periodically
final transactionSummaryProvider =
    StreamProvider.family<Map<String, dynamic>, TransactionSummaryParams>(
        (ref, params) async* {
  final service = ref.watch(financialReportsProvider);

  Future<Map<String, dynamic>> fetch() => service.getTransactionSummary(
        schoolId: params.schoolId,
        startDate: params.startDate ??
            DateTime.now().subtract(const Duration(days: 30)),
        endDate: params.endDate ?? DateTime.now(),
      );

  try {
    yield await fetch();
  } catch (e, st) {
    yield* Stream.error(e, st);
  }

  // Periodic refresh every 30 seconds for real-time-like updates
  await for (final _ in Stream.periodic(const Duration(seconds: 30))) {
    try {
      yield await fetch();
    } catch (e, st) {
      yield* Stream.error(e, st);
    }
  }
});

/// Outstanding Bills Stream Provider - Updates periodically
final outstandingBillsProvider =
    StreamProvider.family<List<Map<String, dynamic>>, String>(
        (ref, studentId) async* {
  final service = ref.watch(financialReportsProvider);

  Future<List<Map<String, dynamic>>> fetch() =>
      service.getOutstandingBills(studentId);

  try {
    yield await fetch();
  } catch (e, st) {
    yield* Stream.error(e, st);
  }

  // Periodic refresh every 30 seconds for real-time-like updates
  await for (final _ in Stream.periodic(const Duration(seconds: 30))) {
    try {
      yield await fetch();
    } catch (e, st) {
      yield* Stream.error(e, st);
    }
  }
});

/// Payment Allocation History Stream Provider - Updates periodically
final paymentAllocationHistoryProvider =
    StreamProvider.family<List<Map<String, dynamic>>, AllocationHistoryParams>(
        (ref, params) async* {
  final service = ref.watch(financialReportsProvider);

  Future<List<Map<String, dynamic>>> fetch() =>
      service.getPaymentAllocationHistory(
        studentId: params.studentId,
        limit: params.limit,
      );

  try {
    yield await fetch();
  } catch (e, st) {
    yield* Stream.error(e, st);
  }

  // Periodic refresh every 30 seconds for real-time-like updates
  await for (final _ in Stream.periodic(const Duration(seconds: 30))) {
    try {
      yield await fetch();
    } catch (e, st) {
      yield* Stream.error(e, st);
    }
  }
});

// Parameter Classes
class InvoiceStatsParams {
  final String schoolId;
  final DateTime? startDate;
  final DateTime? endDate;

  InvoiceStatsParams({
    required this.schoolId,
    this.startDate,
    this.endDate,
  });

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is InvoiceStatsParams &&
          runtimeType == other.runtimeType &&
          schoolId == other.schoolId &&
          startDate == other.startDate &&
          endDate == other.endDate;

  @override
  int get hashCode => Object.hash(schoolId, startDate, endDate);
}

class TransactionSummaryParams {
  final String schoolId;
  final DateTime? startDate;
  final DateTime? endDate;

  TransactionSummaryParams({
    required this.schoolId,
    this.startDate,
    this.endDate,
  });

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is TransactionSummaryParams &&
          runtimeType == other.runtimeType &&
          schoolId == other.schoolId &&
          startDate == other.startDate &&
          endDate == other.endDate;

  @override
  int get hashCode => Object.hash(schoolId, startDate, endDate);
}

class AllocationHistoryParams {
  final String studentId;
  final int limit;

  AllocationHistoryParams({
    required this.studentId,
    this.limit = 50,
  });

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is AllocationHistoryParams &&
          runtimeType == other.runtimeType &&
          studentId == other.studentId &&
          limit == other.limit;

  @override
  int get hashCode => Object.hash(studentId, limit);
}

/// Financial Reports Service
/// Uses deployed Supabase RPC functions
class FinancialReportsService {
  final SupabaseClient _supabase;

  FinancialReportsService(this._supabase);

  /// Get invoice statistics using deployed RPC function
  Future<Map<String, dynamic>> getInvoiceStatistics({
    required String schoolId,
    DateTime? startDate,
    DateTime? endDate,
  }) async {
    try {
      final result = await _supabase.rpc(
        'get_invoice_statistics',
        params: {
          'p_school_id': schoolId,
          if (startDate != null)
            'p_start_date': startDate.toIso8601String().split('T')[0],
          if (endDate != null)
            'p_end_date': endDate.toIso8601String().split('T')[0],
        },
      );

      return result as Map<String, dynamic>;
    } catch (e) {
      throw Exception('Failed to fetch invoice statistics: $e');
    }
  }

  /// Get transaction summary using deployed RPC function
  Future<Map<String, dynamic>> getTransactionSummary({
    required String schoolId,
    DateTime? startDate,
    DateTime? endDate,
  }) async {
    try {
      final result = await _supabase.rpc(
        'get_transaction_summary',
        params: {
          'p_school_id': schoolId,
          if (startDate != null)
            'p_start_date': startDate.toIso8601String().split('T')[0],
          if (endDate != null)
            'p_end_date': endDate.toIso8601String().split('T')[0],
        },
      );

      return result as Map<String, dynamic>;
    } catch (e) {
      throw Exception('Failed to fetch transaction summary: $e');
    }
  }

  /// Get outstanding bills using deployed RPC function
  Future<List<Map<String, dynamic>>> getOutstandingBills(
      String studentId) async {
    try {
      final result = await _supabase.rpc(
        'get_outstanding_bills_with_balance',
        params: {
          'p_student_id': studentId,
        },
      );

      return List<Map<String, dynamic>>.from(result as List);
    } catch (e) {
      throw Exception('Failed to fetch outstanding bills: $e');
    }
  }

  /// Get payment allocation history using deployed RPC function
  Future<List<Map<String, dynamic>>> getPaymentAllocationHistory({
    required String studentId,
    int limit = 50,
  }) async {
    try {
      final result = await _supabase.rpc(
        'get_payment_allocation_history',
        params: {
          'p_student_id': studentId,
          'p_limit': limit,
        },
      );

      return List<Map<String, dynamic>>.from(result as List);
    } catch (e) {
      throw Exception('Failed to fetch payment history: $e');
    }
  }

  /// Get bill payment summary using deployed RPC function
  Future<Map<String, dynamic>> getBillPaymentSummary(String billId) async {
    try {
      final result = await _supabase.rpc(
        'get_bill_payment_summary',
        params: {
          'p_bill_id': billId,
        },
      );

      return result as Map<String, dynamic>;
    } catch (e) {
      throw Exception('Failed to fetch bill payment summary: $e');
    }
  }

  /// Generate next invoice number using deployed RPC function
  Future<String> generateNextInvoiceNumber(String schoolId) async {
    try {
      final result = await _supabase.rpc(
        'generate_next_invoice_number',
        params: {
          'p_school_id': schoolId,
        },
      );

      return result as String;
    } catch (e) {
      throw Exception('Failed to generate invoice number: $e');
    }
  }
}

// ==========================================
// FILE: ./providers/billing_config_provider.dart
// ==========================================

import 'package:flutter/foundation.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:uuid/uuid.dart';

import '../services/database_service.dart';

const _uuid = Uuid();
const _defaultBillingConfig = <String, dynamic>{
  'currency_code': 'USD',
  'tax_rate_percentage': 0.0,
  'registration_fee': 0.0,
  'grace_period_days': 7,
  'invoice_prefix': 'INV-',
  'invoice_sequence_seed': 1000,
  'late_fee_percentage': 0.0,
  'invoice_footer_note': '',
  'allow_partial_payments': 1,
  'default_fee': 0.0,
};

final billingConfigProvider = StateNotifierProvider.autoDispose.family<
    BillingConfigNotifier, AsyncValue<Map<String, dynamic>>, String>(
  (ref, schoolId) {
    final notifier = BillingConfigNotifier(DatabaseService(), schoolId);
    notifier.load();
    return notifier;
  },
);

class BillingConfigNotifier
    extends StateNotifier<AsyncValue<Map<String, dynamic>>> {
  BillingConfigNotifier(this._db, this.schoolId)
      : super(const AsyncLoading());

  final DatabaseService _db;
  final String schoolId;

  Future<void> load() async {
    state = const AsyncLoading();
    try {
      final result = await _db.db.getAll(
        'SELECT * FROM billing_configs WHERE school_id = ? LIMIT 1',
        [schoolId],
      );
      if (result.isNotEmpty) {
        state = AsyncData(result.first);
      } else {
        state = const AsyncData(_defaultBillingConfig);
      }
    } catch (e, st) {
      debugPrint('⚠️ Failed to load billing config: $e');
      state = AsyncError(e, st);
    }
  }

  Future<void> saveConfig({
    required String currencyCode,
    required double taxRate,
    required double registrationFee,
    required int gracePeriodDays,
    required String invoicePrefix,
    required int invoiceSequenceSeed,
    required double lateFeePercentage,
    required double defaultFee,
    required bool allowPartialPayments,
    required String invoiceFooterNote,
  }) async {
    try {
      final existing = await _db.db.getAll(
        'SELECT id FROM billing_configs WHERE school_id = ? LIMIT 1',
        [schoolId],
      );

      final payload = <String, dynamic>{
        'school_id': schoolId,
        'currency_code': currencyCode,
        'tax_rate_percentage': taxRate,
        'registration_fee': registrationFee,
        'grace_period_days': gracePeriodDays,
        'invoice_prefix': invoicePrefix,
        'invoice_sequence_seed': invoiceSequenceSeed,
        'late_fee_percentage': lateFeePercentage,
        'default_fee': defaultFee,
        'allow_partial_payments': allowPartialPayments ? 1 : 0,
        'invoice_footer_note': invoiceFooterNote,
        'updated_at': DateTime.now().toIso8601String(),
      };

      if (existing.isEmpty) {
        await _db.insert('billing_configs', {
          'id': _uuid.v4(),
          ...payload,
        });
      } else {
        await _db.update(
          'billing_configs',
          existing.first['id'] as String,
          payload,
        );
      }

      await load();
    } catch (e, st) {
      debugPrint('❌ Failed to save billing config: $e');
      state = AsyncError(e, st);
      rethrow;
    }
  }
}

// ==========================================
// FILE: ./providers/students_provider.dart
// ==========================================

import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../services/database_service.dart';
import 'auth_provider.dart';
import '../../core/utils/safe_data.dart';

/// 🎓 STUDENTS PROVIDER
/// All student data flows through here. NO hardcoding.
/// Everything reads/writes to local SQLite via DatabaseService.

// ============================================================
// PROVIDERS
// ============================================================

final databaseServiceProvider = Provider<DatabaseService>((ref) {
  return DatabaseService();
});

/// Stream of all students for a school (Real-time updates via PowerSync)
final studentsProvider =
    StreamProvider.family<List<Map<String, dynamic>>, String>(
  (ref, schoolId) {
    final db = ref.watch(databaseServiceProvider);
    return db.watchStudents(schoolId);
  },
);

/// Get a single student by ID
final studentByIdProvider =
    FutureProvider.family<Map<String, dynamic>?, String>(
  (ref, studentId) async {
    final db = ref.watch(databaseServiceProvider);
    return await db.getById('students', studentId);
  },
);

/// � CLASSES PROVIDER
/// Stream of all classes for a school (Real-time updates via PowerSync)
// 🟢 [FIX 1] Real Classes Data
final classesProvider =
    StreamProvider.family<List<Map<String, dynamic>>, String>(
  (ref, schoolId) {
    final db = ref.watch(databaseServiceProvider);
    return db.watchClasses(schoolId);
  },
);

/// 🎯 SELECTED STUDENT PROVIDER
/// Tracks which student is currently selected for viewing details
final selectedStudentProvider =
    StateProvider<Map<String, dynamic>?>((ref) => null);

/// 📢 NOTIFICATIONS PROVIDER
/// Stream of all notifications for a user (Real-time updates via PowerSync)
// 🟢 [FIX 2] Real Notification Data
final notificationsProvider = StreamProvider<List<Map<String, dynamic>>>(
  (ref) {
    final user = ref.watch(currentUserProvider);
    if (user == null) return Stream.value([]);

    final db = ref.watch(databaseServiceProvider);
    return db.watchNotifications(user.id);
  },
);

/// 🔍 FILTER STATE NOTIFIERS
/// Manage filter state for the students table

final studentSearchProvider = StateProvider<String>((ref) => '');

final studentGradeFilterProvider = StateProvider<String?>((ref) => null);

final studentClassFilterProvider = StateProvider<String?>((ref) => null);

final studentStatusFilterProvider = StateProvider<String?>((ref) => null);

final studentFinancialFilterProvider = StateProvider<String?>((ref) => null);

/// Filtered & Searched Students
final filteredStudentsProvider =
    Provider.family<List<Map<String, dynamic>>, String>(
  (ref, schoolId) {
    final studentsAsync = ref.watch(studentsProvider(schoolId));
    final searchQuery = ref.watch(studentSearchProvider).toLowerCase();
    final gradeFilter = ref.watch(studentGradeFilterProvider);
    final classFilter = ref.watch(studentClassFilterProvider);
    final statusFilter = ref.watch(studentStatusFilterProvider);
    final financialFilter = ref.watch(studentFinancialFilterProvider);

    return studentsAsync.when(
      data: (students) {
        return students.where((student) {
          // Search filter
          if (searchQuery.isNotEmpty) {
            final name = (student['full_name'] ?? '').toString().toLowerCase();
            final id = (student['student_id'] ?? '').toString().toLowerCase();
            final contact =
                (student['parent_contact'] ?? '').toString().toLowerCase();
            final parentName = (student['emergency_contact_name'] ?? '')
                .toString()
                .toLowerCase();

            if (!name.contains(searchQuery) &&
                !id.contains(searchQuery) &&
                !contact.contains(searchQuery) &&
                !parentName.contains(searchQuery)) {
              return false;
            }
          }

          // Grade filter
          if (gradeFilter != null && gradeFilter != 'All Grades') {
            final grade = (student['grade'] ?? '').toString();
            if (grade != gradeFilter) return false;
          }

          // Class filter
          if (classFilter != null && classFilter != 'All Classes') {
            final studentClass = (student['class'] ?? '').toString();
            if (studentClass != classFilter) return false;
          }

          // Status filter
          if (statusFilter != null && statusFilter != 'Status: All') {
            // 🛡️ Issue #2 Fix: Safe type parsing instead of unsafe 'as int?'
            final isActive = SafeData.parseInt(student['is_active']) == 1;
            final isSuspended = SafeData.parseInt(student['is_suspended']) == 1;

            if (statusFilter == 'Status: Active' &&
                (!isActive || isSuspended)) {
              return false;
            }
            if (statusFilter == 'Status: Inactive' && isActive) return false;
            if (statusFilter == 'Status: Suspended' && !isSuspended) {
              return false;
            }
            if (statusFilter == 'Status: Banned Forever' &&
                (!isSuspended || isActive)) {
              return false;
            }
          }

          // Financial filter
          if (financialFilter != null && financialFilter != 'Financial: All') {
            // 🛡️ Issue #2 Fix: Safe double parsing
            final owed = SafeData.parseDouble(student['owed_total']);
            if (financialFilter == 'Financial: Owed' && owed <= 0) return false;
            if (financialFilter == 'Financial: Paid' && owed > 0) return false;
          }

          return true;
        }).toList();
      },
      loading: () => [],
      error: (_, __) => [],
    );
  },
);

// ============================================================
// ZIMBABWE ZIMSEC GRADES/FORMS
// ============================================================
/// Grades 1-7 (Primary): Grade 1, Grade 2, ..., Grade 7
/// Forms 1-6 (Secondary): Form 1 (O-Level), Form 2 (O-Level), Form 3 (A-Level),
///                        Form 4 (A-Level), Form 5 (A-Level), Form 6 (A-Level)
const List<String> zimsecGrades = [
  'Grade 1',
  'Grade 2',
  'Grade 3',
  'Grade 4',
  'Grade 5',
  'Grade 6',
  'Grade 7',
  'Form 1 (O-Level)',
  'Form 2 (O-Level)',
  'Form 3 (A-Level)',
  'Form 4 (A-Level)',
  'Form 5 (A-Level)',
  'Form 6 (A-Level)',
];

const List<String> studentStatusOptions = [
  'Status: All',
  'Status: Active',
  'Status: Inactive',
  'Status: Suspended',
  'Status: Banned Forever',
];

// ============================================================
// DATA MODELS
// ============================================================

class StudentStats {
  final int totalCount;
  final double totalOwed;
  final double totalPaid;

  StudentStats({
    required this.totalCount,
    required this.totalOwed,
    required this.totalPaid,
  });
}

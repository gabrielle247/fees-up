# Brick Offline-First Directory

This directory contains all Brick-related configuration and utilities for offline-first data synchronization with Supabase.

## ğŸ“ Directory Structure

```text
lib/brick/
â”œâ”€â”€ README.md                           # This file
â”œâ”€â”€ brick.g.dart                        # Main Brick configuration
â”œâ”€â”€ adapters/                           # Generated model adapters (auto-generated)
â”‚   â””â”€â”€ *.g.dart                        # DO NOT EDIT - Generated by build_runner
â”œâ”€â”€ db/
â”‚   â””â”€â”€ encrypted_database_helper.dart  # Database encryption management
â”œâ”€â”€ repository/
â”‚   â””â”€â”€ brick_repository.dart           # Main repository singleton
â””â”€â”€ testing/
    â””â”€â”€ brick_test_helper.dart          # Testing utilities
```

## ğŸš€ Quick Start

1. **Generate Adapters:**

   ```bash
   flutter pub run build_runner build --delete-conflicting-outputs
   ```

2. **Use Repository:**

   ```dart
   final repo = BrickRepository.instance;
   final students = await repo.getAll<Student>();
   ```

3. **Run Tests:**

   ```dart
   import 'package:fees_up/brick/testing/brick_test_helper.dart';
   await runBrickTests();
   ```

## ğŸ“„ File Descriptions

\n### brick.g.dart
Main configuration file that:

- Connects models with adapters
- Configures Supabase provider
- Configures SQLite provider
- Manages migrations
- Initializes repository

**After build_runner:** Update this file to include your generated model adapters.

\n### db/encrypted_database_helper.dart
Manages database encryption:

- Creates encrypted SQLite database
- Generates/stores encryption keys
- Handles key rotation
- Verifies database integrity
- Manages database lifecycle

\n### repository/brick_repository.dart
Main repository interface:

- Singleton pattern for app-wide access
- CRUD operations
- Query support
- Real-time subscriptions
- Sync management
- Offline queue handling

\n### testing/brick_test_helper.dart
Testing utilities:

- Health checks
- CRUD tests
- Query tests
- Integration tests
- Diagnostic tools

\n### adapters/
Auto-generated directory containing:

- Model serializers
- Supabase adapters
- SQLite adapters

**âš ï¸ DO NOT EDIT FILES IN THIS DIRECTORY**
They are regenerated by build_runner.

## ğŸ” Security

- Database encrypted with SQLCipher
- Keys stored in FlutterSecureStorage
- Automatic key generation
- Key rotation support
- No keys in source code

## ğŸ“š Documentation

For detailed information, see:

- `BRICK_IMPLEMENTATION_GUIDE.md` - Complete guide
- `BRICK_QUICK_REFERENCE.md` - Quick reference
- `BRICK_IMPLEMENTATION_SUMMARY.md` - What was built
- `BRICK_CHECKLIST.md` - Implementation checklist

## ğŸ› ï¸ Development Workflow

### Adding New Models

1. Create Brick-annotated model:

   ```dart
   @ConnectOfflineFirstWithSupabase(
     supabaseConfig: SupabaseSerializable(tableName: 'table'),
   )
   class MyModel extends OfflineFirstWithSupabaseModel {
     // ...
   }
   ```

2. Run build_runner:

   ```bash
   flutter pub run build_runner build --delete-conflicting-outputs
   ```

3. Update `brick.g.dart`:

   - Import the model
   - Import the generated adapter
   - Add to modelDictionary

4. Test:

   ```dart
   final model = MyModel(...);
   await BrickRepository.instance.upsert(model);
   ```

### Modifying Models

1. Update model annotations
2. Run: `flutter pub run build_runner build --delete-conflicting-outputs`
3. Test changes
4. May need migration if schema changed

### Debugging

Enable verbose logging in `brick_repository.dart`:

```dart
debugPrint('Your debug message');
```

Check database:

```dart
final isValid = await BrickRepository.instance.verifyIntegrity();
```

## ğŸ”„ Sync Behavior

- **Local First:** All reads from local DB
- **Auto Queue:** Writes queued for sync
- **Background:** Syncs in background
- **Conflict Resolution:** Last-write-wins
- **Retry:** Automatic retry on failure

## ğŸ“Š Performance

- Encrypted operations: ~5% overhead
- Query performance: Optimized with indexes
- Sync: Batched for efficiency
- Memory: Lazy loading supported

## ğŸ› Troubleshooting

### Repository Not Initialized

```dart
// Ensure in main.dart:
await BrickRepository.instance.initialize();
```

### Adapters Not Generated

```bash
flutter pub run build_runner clean
flutter pub run build_runner build --delete-conflicting-outputs
```

### Database Corruption

```dart
await BrickRepository.instance.reset();
```

### Sync Issues

- Check network
- Verify Supabase credentials
- Check RLS policies
- Review queue length

## ğŸ§ª Testing

Run test suite:

```dart
import 'testing/brick_test_helper.dart';
await runBrickTests();
```

Health check:

```dart
import 'testing/brick_test_helper.dart';
await brickHealthCheck();
```

## ğŸ”— Related Files

Outside this directory:

- `lib/models/*_brick.dart` - Brick models
- `lib/services/*_service.dart` - Services using Brick
- `lib/providers/*_provider.dart` - Riverpod providers
- `build.yaml` - Build configuration
- `pubspec.yaml` - Dependencies

## ğŸ’¡ Best Practices

1. **Always use upsert** instead of separate insert/update
2. **Subscribe to changes** for reactive UI
3. **Use requireRemote: false** for better offline UX
4. **Test offline scenarios** regularly
5. **Monitor sync queue** for issues
6. **Wrap in services** for clean architecture
7. **Use providers** for state management
8. **Handle errors** gracefully

## ğŸ“ Support

If you need help:

1. Check `BRICK_IMPLEMENTATION_GUIDE.md`
2. Run `brick_test_helper.dart` tests
3. Review console logs
4. Check Brick documentation: <https://github.com/GetDutchie/brick>

## ğŸ¯ Next Steps

1. Generate adapters for your models
2. Test basic operations
3. Integrate into UI
4. Test offline scenarios
5. Monitor performance
6. Optimize as needed

---

Last Updated: December 2025

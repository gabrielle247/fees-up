import 'dart:io'; // For Platform check
import 'package:fees_up/services/database_service.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';
import 'package:flutter/services.dart'; // For PlatformException
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:flutter_dotenv/flutter_dotenv.dart';
import 'package:local_auth/local_auth.dart'; // Must be ^3.0.0
import 'package:sqflite_common_ffi/sqflite_ffi.dart';
import 'package:supabase_flutter/supabase_flutter.dart';
import 'package:fees_up/pages/auth_page.dart';
import 'package:fees_up/pages/home_screen.dart';
import 'package:fees_up/providers/auth_provider.dart';

// 1. Global Navigator Key for context-less navigation
final GlobalKey<NavigatorState> navigatorKey = GlobalKey<NavigatorState>();

Future<void> main() async {
  WidgetsFlutterBinding.ensureInitialized();

  // 2. Load Env
  await dotenv.load(fileName: 'assets/keys.env');
  final supabaseUrl = dotenv.env['SUPABASE_URL'];
  final supabaseAnonKey = dotenv.env['SUPABASE_ANON_KEY'];

  if (supabaseUrl == null || supabaseAnonKey == null) {
    throw Exception('Missing Supabase keys in assets/keys.env');
  }

  // 3. Desktop DB Support (Linux/Windows/Mac)
  if (!kIsWeb &&
      (defaultTargetPlatform == TargetPlatform.linux ||
          defaultTargetPlatform == TargetPlatform.windows ||
          defaultTargetPlatform == TargetPlatform.macOS)) {
    sqfliteFfiInit();
    databaseFactory = databaseFactoryFfi;
  }

  // 4. Initialize Services
  await Supabase.initialize(url: supabaseUrl, anonKey: supabaseAnonKey);
  final db = DatabaseService.instance;
  await db.database;

  // 5. Admin Setup
  try {
    final user = Supabase.instance.client.auth.currentUser;
    if (user != null) {
      final meta = user.userMetadata;
      await db.ensureAdminExists(
        user.id,
        defaults: {
          'email': user.email,
          'full_name': meta?['full_name'] ?? user.email,
          'school_name': meta?['school_name'] ?? 'My School',
        },
      );
      await db.enforceAdminUidToAllTables(user.id);
    }
  } catch (e) {
    if (kDebugMode) print("Admin init error: $e");
  }

  runApp(const ProviderScope(child: FeesUpApp()));
}

class FeesUpApp extends ConsumerWidget {
  const FeesUpApp({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    // ----------------------------------------------------------------------
    // LOGOUT LISTENER: Forces navigation to AuthPage on sign-out
    // ----------------------------------------------------------------------
    ref.listen<AsyncValue<AuthState>>(
      authStateChangesProvider,
      (previous, next) {
        next.whenData((authState) {
          if (authState.event == AuthChangeEvent.signedOut) {
            // Clear history and go to Auth
            navigatorKey.currentState?.pushNamedAndRemoveUntil(
              AuthPage.routeName,
              (route) => false,
            );
          } else if (authState.event == AuthChangeEvent.signedIn) {
             // Optional: Handle auto-navigation on login if needed, 
             // though usually handled by the initial home widget logic.
          }
        });
      },
    );

    final theme = ThemeData(
      brightness: Brightness.dark,
      fontFamily: 'Poppins',
      useMaterial3: true,
      scaffoldBackgroundColor: const Color(0xff121b22),
      colorScheme: ColorScheme.dark(
        primary: const Color(0xff3498db),
        surface: const Color(0xff1c2a35),
        onSurface: Colors.white,
        error: const Color(0xffff4c4c),
      ),
      appBarTheme: const AppBarTheme(
        elevation: 0,
        backgroundColor: Colors.transparent,
      ),
    );

    // Watch auth state to determine INITIAL screen
    final authStateAsync = ref.watch(authControllerProvider);

    return MaterialApp(
      navigatorKey: navigatorKey, // Crucial for global navigation
      title: 'Fees Up',
      debugShowCheckedModeBanner: false,
      theme: theme,
      routes: {
        AuthPage.routeName: (context) => const AuthPage(),
        HomeScreen.routeName: (context) => const HomeScreen(),
      },
      // INTELLIGENT HOME ROUTING
      home: authStateAsync.when(
        loading: () => const Scaffold(
          body: Center(child: CircularProgressIndicator()),
        ),
        error: (e, s) => Scaffold(
          body: Center(child: Text("Startup Error: $e")),
        ),
        data: (isAuthenticated) {
          if (isAuthenticated) {
            // User is logged in -> Enforce Biometrics before showing Home
            return const BiometricGuard(child: HomeScreen());
          } else {
            // Not logged in -> Show Login
            return const AuthPage();
          }
        },
      ),
    );
  }
}

// -----------------------------------------------------------------------------
// BIOMETRIC GUARD WIDGET (Local Auth 3.0.0 Compatible)
// Wraps the HomeScreen and forces local auth on initialization
// -----------------------------------------------------------------------------
class BiometricGuard extends StatefulWidget {
  final Widget child;
  const BiometricGuard({super.key, required this.child});

  @override
  State<BiometricGuard> createState() => _BiometricGuardState();
}

class _BiometricGuardState extends State<BiometricGuard> {
  final LocalAuthentication auth = LocalAuthentication();
  bool _isAuthenticated = false;
  bool _isAuthenticating = false;

  @override
  void initState() {
    super.initState();
    _checkBiometrics();
  }

  Future<void> _checkBiometrics() async {
    // 1. BYPASS LINUX / DESKTOP / WEB
    // Local Auth plugin crashes or is unsupported on generic Linux.
    if (kIsWeb || Platform.isLinux || Platform.isWindows || Platform.isMacOS) {
      if (mounted) setState(() => _isAuthenticated = true);
      return;
    }

    try {
      // 2. CHECK HARDWARE SUPPORT (Android/iOS)
      final bool canCheckBiometrics = await auth.canCheckBiometrics;
      final bool isDeviceSupported = await auth.isDeviceSupported();

      if (!canCheckBiometrics || !isDeviceSupported) {
        // Fallback: If no hardware (e.g., emulator without setup), let them in
        if (mounted) setState(() => _isAuthenticated = true);
        return;
      }

      // 3. AUTHENTICATE
      if (mounted) setState(() => _isAuthenticating = true);

      final bool didAuthenticate = await auth.authenticate(
        localizedReason: 'Please authenticate to access Fees Up',
        // CORRECT SYNTAX FOR LOCAL AUTH 3.0.0+
        options: const AuthenticationOptions(
          stickyAuth: true,
          biometricOnly: false, // Allow PIN/Pattern as fallback
          useErrorDialogs: true,
        ),
      );

      if (mounted) {
        setState(() {
          _isAuthenticated = didAuthenticate;
          _isAuthenticating = false;
        });
        
        // If auth failed, you could optionally sign them out here
        // if (!didAuthenticate) { ... }
      }
    } on PlatformException catch (e) {
      debugPrint("Auth Error: $e");
      // If platform error occurs (e.g. auth not enrolled), let them in or handle error
      if (mounted) {
        // For development safety, we default to true if error is non-fatal
        // In high security apps, you might default to false.
        setState(() {
          _isAuthenticated = true; 
          _isAuthenticating = false;
        });
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    // If authenticated (or skipped on Linux), show the app
    if (_isAuthenticated) {
      return widget.child;
    }

    // Otherwise show the Lock Screen
    return Scaffold(
      body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            const Icon(Icons.lock_outline, size: 80, color: Colors.grey),
            const SizedBox(height: 20),
            const Text(
              "Fees Up is Locked",
              style: TextStyle(fontSize: 20, fontWeight: FontWeight.bold),
            ),
            const SizedBox(height: 20),
            if (_isAuthenticating)
              const CircularProgressIndicator()
            else
              ElevatedButton.icon(
                onPressed: _checkBiometrics,
                icon: const Icon(Icons.fingerprint),
                label: const Text("Unlock"),
                style: ElevatedButton.styleFrom(
                  backgroundColor: const Color(0xff3498db),
                  foregroundColor: Colors.white,
                  padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 12),
                ),
              ),
          ],
        ),
      ),
    );
  }
}import 'package:flutter/material.dart';
import '../models/subjects.dart'; // Ensure this points to your ZimsecSubject file

class SubjectSelectionModal extends StatefulWidget {
  final List<String> selectedSubjects;
  final ValueChanged<List<String>> onConfirmed;

  const SubjectSelectionModal({
    super.key,
    required this.selectedSubjects,
    required this.onConfirmed,
  });

  @override
  State<SubjectSelectionModal> createState() => _SubjectSelectionModalState();
}

class _SubjectSelectionModalState extends State<SubjectSelectionModal> {
  late List<String> _tempSelected;
  String _searchQuery = '';

  // CORE / POPULAR Subjects in Zimbabwe
  final List<String> _coreSubjects = [
    'Mathematics',
    'English Language',
    'Combined Science',
    'Shona',
    'Ndebele',
    'Heritage Studies',
    'Agriculture',
    'Computer Science',
    'Geography'
  ];

  @override
  void initState() {
    super.initState();
    _tempSelected = List.from(widget.selectedSubjects);
  }

  @override
  Widget build(BuildContext context) {
    final allSubjects = ZimsecSubject.allNames;
    
    // Filter logic
    final filteredSubjects = allSubjects.where((s) {
      return s.toLowerCase().contains(_searchQuery.toLowerCase());
    }).toList();

    // Split into Core and Others for display
    final coreMatches = filteredSubjects.where((s) => _coreSubjects.contains(s)).toList();
    final otherMatches = filteredSubjects.where((s) => !_coreSubjects.contains(s)).toList();

    return Container(
      height: MediaQuery.of(context).size.height * 0.85,
      padding: const EdgeInsets.all(16),
      decoration: BoxDecoration(
        color: Theme.of(context).colorScheme.surface,
        borderRadius: const BorderRadius.vertical(top: Radius.circular(20)),
      ),
      child: Column(
        children: [
          // Handle Bar
          Container(
            width: 40,
            height: 4,
            margin: const EdgeInsets.only(bottom: 20),
            decoration: BoxDecoration(
              color: Colors.grey.withAlpha(77),
              borderRadius: BorderRadius.circular(2),
            ),
          ),
          
          // Header
          Row(
            mainAxisAlignment: MainAxisAlignment.spaceBetween,
            children: [
              Text(
                "Select Subjects",
                style: Theme.of(context).textTheme.headlineSmall?.copyWith(fontWeight: FontWeight.bold),
              ),
              TextButton(
                onPressed: () {
                  widget.onConfirmed(_tempSelected);
                  Navigator.pop(context);
                },
                child: const Text("Done"),
              )
            ],
          ),
          
          const SizedBox(height: 10),

          // Search Bar
          TextField(
            onChanged: (val) => setState(() => _searchQuery = val),
            decoration: InputDecoration(
              prefixIcon: const Icon(Icons.search),
              hintText: "Search subjects...",
              filled: true,
              fillColor: Theme.of(context).colorScheme.surfaceContainerHighest.withAlpha(77),
              border: OutlineInputBorder(
                borderRadius: BorderRadius.circular(12),
                borderSide: BorderSide.none,
              ),
              contentPadding: const EdgeInsets.symmetric(vertical: 0, horizontal: 16),
            ),
          ),

          const SizedBox(height: 16),

          // List
          Expanded(
            child: ListView(
              children: [
                if (_searchQuery.isEmpty && coreMatches.isNotEmpty) ...[
                  _buildSectionHeader("CORE / POPULAR"),
                  ...coreMatches.map(_buildCheckboxTile),
                  const Divider(height: 32),
                  _buildSectionHeader("ALL SUBJECTS"),
                ],
                ...otherMatches.map(_buildCheckboxTile),
                
                if (coreMatches.isEmpty && otherMatches.isEmpty)
                  const Padding(
                    padding: EdgeInsets.only(top: 40),
                    child: Center(child: Text("No subjects found")),
                  )
              ],
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildSectionHeader(String title) {
    return Padding(
      padding: const EdgeInsets.only(bottom: 8.0, top: 8.0),
      child: Text(
        title,
        style: TextStyle(
          color: Theme.of(context).colorScheme.primary,
          fontWeight: FontWeight.bold,
          letterSpacing: 1.0,
          fontSize: 12,
        ),
      ),
    );
  }

  Widget _buildCheckboxTile(String subject) {
    final isSelected = _tempSelected.contains(subject);
    return CheckboxListTile(
      value: isSelected,
      title: Text(subject),
      activeColor: Theme.of(context).colorScheme.primary,
      contentPadding: EdgeInsets.zero,
      onChanged: (bool? value) {
        setState(() {
          if (value == true) {
            _tempSelected.add(subject);
          } else {
            _tempSelected.remove(subject);
          }
        });
      },
    );
  }
}import 'dart:async';

import '../models/student_full.dart';
import '../services/database_service.dart';
// package:collection is available if advanced list/grouping utilities are needed later.

/// Repository that wraps database hydration, adds computed indicators
/// and exposes a stream for UI layers.
class StudentFullRepository {
  StudentFullRepository({DatabaseService? db}) : _db = db ?? DatabaseService.instance;

  final DatabaseService _db;
  List<StudentFull>? _cache;
  final StreamController<List<StudentFull>> _controller = StreamController.broadcast();

  Stream<List<StudentFull>> get stream => _controller.stream;

  Future<List<StudentFull>> refresh({bool includeInactive = false}) async {
    // Use DatabaseService's hydration as the source of truth and then
    // compute additional derived fields for each StudentFull entry.
    final list = await _db.refreshStudentFullCache(includeInactive: includeInactive);
    _cache = list.map((s) => _withIndicators(s)).toList();
    _controller.add(_cache!);
    return _cache!;
  }

  Future<List<StudentFull>> all({bool includeInactive = false}) async {
    if (_cache == null) return await refresh(includeInactive: includeInactive);
    if (!includeInactive) return _cache!.where((s) => s.student.isActive).toList();
    return _cache!;
  }

  Future<StudentFull?> byId(String id) async {
    final r = await all();
    for (final s in r) {
      if (s.student.id == id) return s;
    }
    return null;
  }

  Map<String, Object?> computeIndicators(StudentFull s) {
    // Basic indicators: previousDebt, currentCycleStatus
    final now = DateTime.now();
    final billingType = s.student.billingType ?? 'monthly';
    DateTime cycleStart;
    DateTime cycleEnd;
    String cycleKey;
    if (billingType == 'monthly') {
      cycleStart = DateTime(now.year, now.month, 1);
      cycleEnd = DateTime(now.year, now.month + 1, 0);
      cycleKey = '${now.year.toString().padLeft(4, '0')}-${now.month.toString().padLeft(2, '0')}';
    } else if (billingType == 'yearly') {
      cycleStart = DateTime(now.year, 1, 1);
      cycleEnd = DateTime(now.year, 12, 31);
      cycleKey = now.year.toString();
    } else {
      // fallback to monthly for terms that don't have term mapping
      cycleStart = DateTime(now.year, now.month, 1);
      cycleEnd = DateTime(now.year, now.month + 1, 0);
      cycleKey = '${now.year.toString().padLeft(4, '0')}-${now.month.toString().padLeft(2, '0')}';
    }

    // previous debt = sum(bills before cycleStart) - sum(payments before cycleStart)
    double pastBills = 0.0;
    double pastPayments = 0.0;
    // Collect bill IDs that are truly in the past (entire cycle before current cycle)
    final pastBillIds = <String>{};
    for (final b in s.bills) {
      if (b.cycleEnd != null && b.cycleEnd!.isBefore(cycleStart)) {
        pastBills += b.totalAmount;
        pastBillIds.add(b.id);
      } else if (b.cycleEnd == null && b.createdAt != null && b.createdAt!.isBefore(cycleStart)) {
        pastBills += b.totalAmount;
        pastBillIds.add(b.id);
      }
    }
    // Sum payments that were applied to those past bills (regardless of payment date)
    for (final p in s.payments) {
      if (p.billId != null && pastBillIds.contains(p.billId)) pastPayments += p.amount;
    }
    final previousDebt = (pastBills - pastPayments).clamp(0.0, double.infinity);

    // current cycle bills
    final currentBills = s.bills.where((b) {
      if (b.monthYear != null) return b.monthYear == cycleKey;
      if (b.cycleStart != null && b.cycleEnd != null) {
        return !(b.cycleEnd!.isBefore(cycleStart) || b.cycleStart!.isAfter(cycleEnd));
      }
      return false;
    }).toList();

    String cycleStatus = 'missing';
    if (currentBills.isEmpty) {
      cycleStatus = 'missing';
    } else {
      final total = currentBills.fold<double>(0.0, (p, b) => p + b.totalAmount);
      final paid = currentBills.fold<double>(0.0, (p, b) => p + b.paidAmount);
      if (paid <= 0) {
        cycleStatus = 'unpaid';
      // ignore: curly_braces_in_flow_control_structures
      } else if (paid >= total) cycleStatus = 'paid';
      // ignore: curly_braces_in_flow_control_structures
      else cycleStatus = 'partial';
    }

    return {
      'cycleKey': cycleKey,
      'cycleStart': cycleStart.toIso8601String(),
      'cycleEnd': cycleEnd.toIso8601String(),
      'previousDebt': previousDebt,
      'currentCycleStatus': cycleStatus,
      'currentBillsCount': currentBills.length,
    };
  }

  StudentFull _withIndicators(StudentFull s) {
    // Currently computeIndicators(s) returns a map of computed values;
    // we don't mutate `StudentFull` (immutable), but it can be returned
    // alongside the StudentFull for UI purposes. For now we keep this
    // method to show where indicator enrichment would happen.
    computeIndicators(s);
    return s;
  }
}
// lib/services/auth_service.dart
import 'package:supabase_flutter/supabase_flutter.dart';
import 'package:flutter/services.dart';

class AuthService {
  final SupabaseClient supabase = Supabase.instance.client;
  
  // --- Profile Creation Helper for RLS ---
  
  /// Creates the RLS anchor row in the public.admin_profile table.
  /// This must be called immediately after a successful user registration.
  Future<void> _createAdminProfile(User user, String fullName, String schoolName) async {
    // 1. Get the authenticated user's UID (RLS MUST match this ID)
    final uid = user.id;

    // 2. Insert the admin profile row into the 'admin_profile' table.
    // The RLS policy requires user.id == id.
    await supabase.from('admin_profile').insert({
      'id': uid, // The UUID from auth.users
      'email': user.email,
      'full_name': fullName,
      'school_name': schoolName, 
      // 'last_synced_at' and 'created_at' will use PostgreSQL defaults
    });
  }

  // --- Session Management & Persistence ---
  
  /// Checks for an existing Supabase session.
  /// Returns true if the user is authenticated, false otherwise.
  Future<bool> getInitialAuthStatus() async {
    final session = supabase.auth.currentSession;
    return session != null;
  }

  // --- Auth Operations ---

  Future<void> signIn({required String email, required String password}) async {
    await supabase.auth.signInWithPassword(email: email, password: password);
    // After login, the RLS profile already exists (created during signup).
  }

  /// Registers a new user and immediately creates the necessary RLS-anchor 
  /// row in the 'admin_profile' table.
  Future<void> signUp({required String email, required String password, required String fullName, String schoolName = 'My School'}) async {
    // 1. Perform Supabase Auth (Creates the user, session starts)
    await supabase.auth.signUp(
      email: email,
      password: password,
      data: {'full_name': fullName}, // Optional: save name in auth metadata
    );
    
    // 2. Get the new user object and create the RLS anchor row.
    final user = supabase.auth.currentUser;
    if (user != null) {
      await _createAdminProfile(user, fullName, schoolName);
    } else {
      // Throw AuthException with a positional argument message (Fix for Analysis Error 4 & 5)
      throw const AuthException('User session not found after successful signup. Please try logging in.'); 
    }
  }

  // --- Logout/Shutdown Helper ---
  
  /// Clears the Supabase session and requests app termination.
  Future<void> signOutAndShutdown() async {
    await supabase.auth.signOut();
    await SystemChannels.platform.invokeMethod('SystemNavigator.pop');
  }
}import 'dart:async';
import 'dart:convert';

import 'package:fees_up/models/billing_config.dart';
import 'package:fees_up/models/student_full.dart'; // Ensure this model exists
import 'package:flutter/foundation.dart'; // For debugPrint
import 'package:intl/intl.dart';
import 'package:path/path.dart';
import 'package:sqflite/sqflite.dart';
import 'package:uuid/uuid.dart';

/// DatabaseService is the central data-access and financial engine for Fees Up.
///
/// FEATURES (v9):
/// - Full Student Billing & Payments (Income)
/// - School Expenses Tracking (Outflow)
/// - Campaign Management (Donations, Civics, Fundraisers)
/// - Academic Management (Teachers, Classes, Attendance)
/// - Robust Sync Queue for Offline-First
class DatabaseService {
  // Singleton pattern
  DatabaseService._internal();
  static final DatabaseService instance = DatabaseService._internal();

  // Database filename
  static const _dbName = 'fees_up.db';

  // VERSION CONTROL
  static const _dbVersion = 9;

  // Cached database instance
  Database? _db;
  Completer<Database>? _openCompleter;

  // Stream for UI reactivity
  final StreamController<Map<String, dynamic>> _changeController =
      StreamController<Map<String, dynamic>>.broadcast();

  Stream<Map<String, dynamic>> get changes => _changeController.stream;

  // Hydration Cache
  List<StudentFull>? _studentFullCache;
  final StreamController<List<StudentFull>> _studentFullController =
      StreamController<List<StudentFull>>.broadcast();

  Stream<List<StudentFull>> get studentFullStream =>
      _studentFullController.stream;

  /// Returns the opened database instance.
  Future<Database> get database async {
    if (_db != null) return _db!;
    return await _openDatabase();
  }

  Future<Database> _openDatabase() async {
    if (_db != null) return _db!;
    if (_openCompleter != null) return _openCompleter!.future;

    _openCompleter = Completer<Database>();
    try {
      final dbPath = await getDatabasesPath();
      final path = join(dbPath, _dbName);

      final db = await openDatabase(
        path,
        version: _dbVersion,
        onConfigure: _onConfigure,
        onCreate: _onCreate,
        onUpgrade: _onUpgrade,
      );

      _db = db;
      _openCompleter!.complete(db);
      return db;
    } catch (e, st) {
      debugPrint("FATAL DB ERROR: $e");
      if (!_openCompleter!.isCompleted) {
        _openCompleter!.completeError(e, st);
      }
      rethrow;
    } finally {
      _openCompleter = null;
    }
  }

  Future<void> _onConfigure(Database db) async {
    await db.execute('PRAGMA foreign_keys = ON');
  }

  // ---------------------------------------------------------------------------
  // 1. ON CREATE (Fresh Install v9)
  // ---------------------------------------------------------------------------
  Future<void> _onCreate(Database db, int version) async {
    final batch = db.batch();

    // --- Core Auth & Tenancy ---
    batch.execute('''
      CREATE TABLE metadata (
        key TEXT PRIMARY KEY,
        value TEXT
      )
    ''');

    batch.execute('''
      CREATE TABLE schools (
        id TEXT PRIMARY KEY,
        name TEXT NOT NULL,
        subscription_tier TEXT DEFAULT 'free',
        is_suspended INTEGER DEFAULT 0,
        created_at INTEGER
      )
    ''');

    batch.execute('''
      CREATE TABLE user_profiles (
        id TEXT PRIMARY KEY,
        email TEXT NOT NULL UNIQUE,
        full_name TEXT NOT NULL,
        role TEXT DEFAULT 'school_admin', 
        school_id TEXT,
        is_banned INTEGER DEFAULT 0,
        avatar_url TEXT,
        last_synced_at TEXT,
        created_at INTEGER,
        FOREIGN KEY (school_id) REFERENCES schools (id) ON DELETE CASCADE
      )
    ''');

    batch.execute('''
      CREATE TABLE sync_queue (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        table_name TEXT NOT NULL,
        operation TEXT NOT NULL, 
        payload TEXT,           
        created_at INTEGER NOT NULL,
        tries INTEGER DEFAULT 0,
        school_id TEXT
      )
    ''');

    // --- Students & Archives ---
    batch.execute('''
      CREATE TABLE students (
        id TEXT PRIMARY KEY,
        school_id TEXT NOT NULL,
        full_name TEXT NOT NULL,
        grade TEXT,
        parent_contact TEXT,
        registration_date TEXT,
        billing_date TEXT,
        billing_type TEXT DEFAULT 'monthly',
        is_active INTEGER DEFAULT 1,
        default_fee REAL,
        subjects TEXT, 
        admin_uid TEXT, 
        paid_total REAL DEFAULT 0,
        owed_total REAL DEFAULT 0,
        FOREIGN KEY (school_id) REFERENCES schools (id) ON DELETE CASCADE
      )
    ''');

    batch.execute('''
      CREATE TABLE student_archives (
        id TEXT PRIMARY KEY,
        school_id TEXT NOT NULL,
        full_name TEXT,
        reason TEXT,
        archived_at TEXT,
        original_data TEXT,
        FOREIGN KEY (school_id) REFERENCES schools (id) ON DELETE CASCADE
      )
    ''');

    // --- Financials (Bills & Tuition Payments) ---
    batch.execute('''
      CREATE TABLE bills (
        id TEXT PRIMARY KEY,
        school_id TEXT NOT NULL,
        student_id TEXT NOT NULL,
        term_id TEXT,
        bill_type TEXT DEFAULT 'monthly',
        title TEXT,
        total_amount REAL NOT NULL,
        paid_amount REAL DEFAULT 0.0,
        month_year TEXT,       
        billing_cycle_start TEXT,
        billing_cycle_end TEXT,
        cycle_interval TEXT DEFAULT 'monthly',
        is_closed INTEGER DEFAULT 0,
        created_at INTEGER,
        updated_at INTEGER,
        admin_uid TEXT,
        FOREIGN KEY (student_id) REFERENCES students (id) ON DELETE CASCADE,
        FOREIGN KEY (school_id) REFERENCES schools (id) ON DELETE CASCADE
      )
    ''');

    batch.execute(
      'CREATE UNIQUE INDEX IF NOT EXISTS idx_bills_student_month_year ON bills (student_id, month_year) WHERE month_year IS NOT NULL',
    );
    batch.execute(
      'CREATE UNIQUE INDEX IF NOT EXISTS idx_bills_student_term_id ON bills (student_id, term_id) WHERE term_id IS NOT NULL',
    );
    batch.execute(
      'CREATE INDEX IF NOT EXISTS idx_bills_student_id ON bills (student_id)',
    );

    batch.execute('''
      CREATE TABLE payments (
        id TEXT PRIMARY KEY,
        school_id TEXT NOT NULL,
        bill_id TEXT,
        student_id TEXT, 
        amount REAL NOT NULL,
        date_paid TEXT NOT NULL,
        method TEXT,
        category TEXT DEFAULT 'tuition', 
        payer_name TEXT, 
        reference_number TEXT, 
        admin_uid TEXT,
        created_at INTEGER,
        FOREIGN KEY (bill_id) REFERENCES bills (id) ON DELETE SET NULL,
        FOREIGN KEY (student_id) REFERENCES students (id) ON DELETE CASCADE,
        FOREIGN KEY (school_id) REFERENCES schools (id) ON DELETE CASCADE
      )
    ''');

    batch.execute('''
      CREATE TABLE expenses (
        id TEXT PRIMARY KEY,
        school_id TEXT NOT NULL,
        title TEXT NOT NULL,
        category TEXT, 
        amount REAL NOT NULL,
        date_incurred TEXT NOT NULL,
        recipient TEXT,
        description TEXT,
        admin_uid TEXT,
        created_at INTEGER,
        FOREIGN KEY (school_id) REFERENCES schools (id) ON DELETE CASCADE
      )
    ''');
    batch.execute(
      'CREATE INDEX IF NOT EXISTS idx_expenses_date ON expenses (date_incurred)',
    );

    // --- Campaigns (Fundraisers, Civics, Donations) ---
    batch.execute('''
      CREATE TABLE campaigns (
        id TEXT PRIMARY KEY,
        school_id TEXT NOT NULL,
        title TEXT NOT NULL,
        goal_amount REAL DEFAULT 0,
        description TEXT,
        start_date TEXT,
        end_date TEXT,
        is_active INTEGER DEFAULT 1,
        created_at INTEGER,
        FOREIGN KEY (school_id) REFERENCES schools (id) ON DELETE CASCADE
      )
    ''');

    batch.execute('''
      CREATE TABLE campaign_donations (
        id TEXT PRIMARY KEY,
        campaign_id TEXT NOT NULL,
        donor_type TEXT DEFAULT 'anonymous', -- 'student', 'teacher', 'external', 'anonymous'
        donor_id TEXT, -- ID of the student/teacher if applicable
        donor_name TEXT, -- Display name (e.g. 'John Doe' or 'Rotary Club')
        amount REAL NOT NULL,
        payment_method TEXT,
        date_received TEXT,
        notes TEXT,
        created_at INTEGER,
        FOREIGN KEY (campaign_id) REFERENCES campaigns (id) ON DELETE CASCADE
      )
    ''');

    // --- Academics ---
    batch.execute('''
      CREATE TABLE school_terms (
        id TEXT PRIMARY KEY,
        school_id TEXT NOT NULL,
        name TEXT,
        academic_year INTEGER,
        start_date TEXT,
        end_date TEXT,
        term_dates TEXT,
        term_number INTEGER,
        created_at INTEGER,
        FOREIGN KEY (school_id) REFERENCES schools (id) ON DELETE CASCADE
      )
    ''');

    batch.execute('''
      CREATE TABLE teachers (
        id TEXT PRIMARY KEY,
        school_id TEXT,
        full_name TEXT NOT NULL,
        email TEXT,
        phone TEXT,
        subjects_taught TEXT, 
        admin_uid TEXT,
        created_at INTEGER
      )
    ''');

    batch.execute('''
      CREATE TABLE classes (
        id TEXT PRIMARY KEY,
        school_id TEXT NOT NULL,
        name TEXT NOT NULL,
        grade TEXT,
        subject_code TEXT, 
        teacher_id TEXT,
        room_number TEXT,
        admin_uid TEXT,
        created_at INTEGER,
        FOREIGN KEY (teacher_id) REFERENCES teachers (id) ON DELETE SET NULL,
        FOREIGN KEY (school_id) REFERENCES schools (id) ON DELETE CASCADE
      )
    ''');

    batch.execute('''
      CREATE TABLE enrollments (
        id TEXT PRIMARY KEY,
        school_id TEXT NOT NULL,
        student_id TEXT NOT NULL,
        class_id TEXT NOT NULL,
        enrolled_at TEXT,
        admin_uid TEXT,
        FOREIGN KEY (student_id) REFERENCES students (id) ON DELETE CASCADE,
        FOREIGN KEY (class_id) REFERENCES classes (id) ON DELETE CASCADE,
        FOREIGN KEY (school_id) REFERENCES schools (id) ON DELETE CASCADE
      )
    ''');

    batch.execute('''
      CREATE TABLE attendance (
        id TEXT PRIMARY KEY,
        school_id TEXT NOT NULL,
        class_id TEXT, 
        student_id TEXT NOT NULL,
        date TEXT NOT NULL, 
        status TEXT DEFAULT 'present', 
        remarks TEXT,
        admin_uid TEXT,
        created_at INTEGER,
        FOREIGN KEY (student_id) REFERENCES students (id) ON DELETE CASCADE,
        FOREIGN KEY (class_id) REFERENCES classes (id) ON DELETE CASCADE,
        FOREIGN KEY (school_id) REFERENCES schools (id) ON DELETE CASCADE
      )
    ''');
    batch.execute(
      'CREATE UNIQUE INDEX IF NOT EXISTS idx_attendance_unique ON attendance (student_id, class_id, date)',
    );

    // --- Utilities ---
    batch.execute('''
      CREATE TABLE notifications (
        id TEXT PRIMARY KEY,
        user_id TEXT NOT NULL,
        school_id TEXT,
        title TEXT NOT NULL,
        body TEXT NOT NULL,
        type TEXT DEFAULT 'info',
        is_read INTEGER DEFAULT 0,
        created_at INTEGER,
        FOREIGN KEY (school_id) REFERENCES schools (id) ON DELETE CASCADE
      )
    ''');

    batch.execute('''
      CREATE TABLE billing_settings (
        id TEXT PRIMARY KEY, 
        config_json TEXT NOT NULL,
        updated_at INTEGER
      )
    ''');

    await batch.commit(noResult: true);
  }

  // ---------------------------------------------------------------------------
  // 2. ON UPGRADE
  // ---------------------------------------------------------------------------
  Future<void> _onUpgrade(Database db, int oldVersion, int newVersion) async {
    // v1 -> v6 Logic Handled in clean installs, keeping simple here for brevity
    // Major v7/v8 logic folded into v9 for cleaner upgrade path

    // v8 -> v9 (Campaigns Renaming & Donor Status)
    if (oldVersion < 9) {
      try {
        // Drop old "fundraisers" if they existed from v8 to ensure clean slate
        await db.execute('DROP TABLE IF EXISTS fundraiser_donations');
        await db.execute('DROP TABLE IF EXISTS fundraisers');

        // Create Campaigns Table
        await db.execute('''
          CREATE TABLE IF NOT EXISTS campaigns (
            id TEXT PRIMARY KEY,
            school_id TEXT NOT NULL,
            title TEXT NOT NULL,
            goal_amount REAL DEFAULT 0,
            description TEXT,
            start_date TEXT,
            end_date TEXT,
            is_active INTEGER DEFAULT 1,
            created_at INTEGER,
            FOREIGN KEY (school_id) REFERENCES schools (id) ON DELETE CASCADE
          )
        ''');

        // Create Campaign Donations Table with Donor Type
        await db.execute('''
          CREATE TABLE IF NOT EXISTS campaign_donations (
            id TEXT PRIMARY KEY,
            campaign_id TEXT NOT NULL,
            donor_type TEXT DEFAULT 'anonymous', -- 'student', 'teacher', 'external', 'anonymous'
            donor_id TEXT, 
            donor_name TEXT,
            amount REAL NOT NULL,
            payment_method TEXT,
            date_received TEXT,
            notes TEXT,
            created_at INTEGER,
            FOREIGN KEY (campaign_id) REFERENCES campaigns (id) ON DELETE CASCADE
          )
        ''');
      } catch (e) {
        debugPrint("Error migrating to v9: $e");
      }
    }
  }

  // ===========================================================================
  // CAMPAIGNS & DONATIONS (V9)
  // ===========================================================================

  Future<String> createCampaign(
    Map<String, dynamic> values, {
    bool queueForSync = true,
  }) async {
    try {
      final id = _generateId('CMP');
      values['id'] = id;
      values['created_at'] ??= DateTime.now().millisecondsSinceEpoch;

      await insert('campaigns', values, queueForSync: queueForSync);
      return id;
    } catch (e) {
      debugPrint("Error creating campaign: $e");
      rethrow;
    }
  }

  Future<String> recordCampaignDonation({
    required String campaignId,
    required double amount,
    required String donorType, // 'student', 'teacher', 'external', 'anonymous'
    String? donorId, // ID if student/teacher
    String? donorName, // Display name
    String paymentMethod = 'cash',
    String? notes,
    bool queueForSync = true,
  }) async {
    try {
      final id = _generateId('DON');
      final now = DateTime.now();

      final values = {
        'id': id,
        'campaign_id': campaignId,
        'donor_type': donorType,
        'donor_id': donorId,
        'donor_name':
            donorName ?? (donorType == 'anonymous' ? 'Anonymous' : 'Unknown'),
        'amount': amount,
        'payment_method': paymentMethod,
        'date_received': DateFormat('yyyy-MM-dd').format(now),
        'notes': notes,
        'created_at': now.millisecondsSinceEpoch,
      };

      await insert('campaign_donations', values, queueForSync: queueForSync);
      return id;
    } catch (e) {
      debugPrint("Error recording donation: $e");
      rethrow;
    }
  }

  Future<List<Map<String, dynamic>>> getActiveCampaigns() async {
    try {
      final db = await database;
      return await db.query(
        'campaigns',
        where: 'is_active = 1',
        orderBy: 'created_at DESC',
      );
    } catch (e) {
      debugPrint("Error fetching campaigns: $e");
      return [];
    }
  }

  // ===========================================================================
  // SYNC SERVICE INTEGRATION (FIXES THE MISSING METHODS)
  // ===========================================================================

  /// FIX: This method is required by SyncDataService.
  /// It acts as a wrapper for `getPendingSync` or direct query.
  Future<List<Map<String, Object?>>> getPendingSyncOperations({
    int limit = 50,
  }) async {
    try {
      final db = await database;
      return await db.query(
        'sync_queue',
        orderBy: 'created_at ASC',
        limit: limit,
      );
    } catch (e) {
      debugPrint("Error fetching sync queue: $e");
      return [];
    }
  }

  /// FIX: This method is required by SyncDataService.
  /// It allows batch confirmation/deletion of sync items.
  Future<void> confirmSyncList(List<int> syncIds) async {
    if (syncIds.isEmpty) return;
    try {
      final db = await database;
      await db.transaction((txn) async {
        for (final id in syncIds) {
          await txn.delete('sync_queue', where: 'id = ?', whereArgs: [id]);
        }
      });
      _emitChange({'action': 'sync_batch_complete', 'count': syncIds.length});
    } catch (e) {
      debugPrint("Error confirming sync list: $e");
      throw Exception("Failed to clear sync queue");
    }
  }

  // Legacy method kept for backward compatibility if needed
  Future<List<Map<String, Object?>>> getPendingSync({int limit = 100}) async {
    return await getPendingSyncOperations(limit: limit);
  }

  // Legacy method kept for backward compatibility
  Future<void> markSynced(int syncId) async {
    await confirmSyncList([syncId]);
  }

  // ===========================================================================
  // STUDENT MANAGEMENT
  // ===========================================================================

  Future<String> createStudent(
    Map<String, Object?> values, {
    bool queueForSync = false,
    bool createBackdatedBills = true,
  }) async {
    try {
      final db = await database;
      return await db
          .transaction((txn) async {
            final id = (values['id'] as String?) ?? _generateId('STU');
            values['id'] = id;

            await txn.insert(
              'students',
              values,
              conflictAlgorithm: ConflictAlgorithm.replace,
            );

            if (queueForSync) {
              final payloadJson = jsonEncode(values);
              await txn.insert('sync_queue', {
                'table_name': 'students',
                'operation': 'insert',
                'payload': payloadJson,
                'created_at': DateTime.now().millisecondsSinceEpoch,
                'tries': 0,
              });
            }
            return id;
          })
          .then((id) async {
            _emitChange({'action': 'create_student', 'id': id});
            await recalcStudentAggregates(id);
            if (createBackdatedBills) {
              try {
                await generateBackdatedBillsForStudent(id);
              } catch (e) {
                debugPrint('Backdating error: $e');
              }
            }
            return id;
          });
    } catch (e) {
      debugPrint("Create Student Error: $e");
      rethrow;
    }
  }

  Future<Map<String, Object?>?> getStudentById(String id) async {
    try {
      final db = await database;
      final rows = await db.query(
        'students',
        where: 'id = ?',
        whereArgs: [id],
        limit: 1,
      );
      if (rows.isEmpty) return null;
      return rows.first.cast<String, Object?>();
    } catch (e) {
      debugPrint("Error getting student: $e");
      return null;
    }
  }

  Future<void> recalcStudentAggregates(String studentId) async {
    try {
      final db = await database;
      final paidRows = await db.rawQuery(
        'SELECT IFNULL(SUM(amount),0) as paid FROM payments WHERE student_id = ?',
        [studentId],
      );
      final paid = (paidRows.first['paid'] as num?)?.toDouble() ?? 0.0;

      final billRows = await db.rawQuery(
        'SELECT IFNULL(SUM(total_amount),0) as total FROM bills WHERE student_id = ?',
        [studentId],
      );
      final total = (billRows.first['total'] as num?)?.toDouble() ?? 0.0;
      final owed = (total - paid).clamp(0.0, double.infinity);

      await db.update(
        'students',
        {'paid_total': paid, 'owed_total': owed},
        where: 'id = ?',
        whereArgs: [studentId],
      );
      _emitChange({
        'action': 'recalc_student',
        'student_id': studentId,
        'paid': paid,
        'owed': owed,
      });
    } catch (e) {
      debugPrint("Recalc Error: $e");
    }
  }

  // ===========================================================================
  // BILLING & PAYMENTS
  // ===========================================================================

  Future<String> createBillForStudent({
    required String studentId,
    required double totalAmount,
    String billType = 'monthly',
    String? monthYear,
    DateTime? cycleStart,
    DateTime? cycleEnd,
    String? adminUid,
    String? termId,
    bool queueForSync = false,
    DateTime? createdAt,
  }) async {
    try {
      final id = _generateId('BILL');
      final now = (createdAt ?? DateTime.now()).millisecondsSinceEpoch;

      final values = {
        'id': id,
        'student_id': studentId,
        'term_id': termId,
        'bill_type': billType,
        'total_amount': totalAmount,
        'paid_amount': 0.0,
        'month_year': monthYear,
        'billing_cycle_start': cycleStart?.toIso8601String(),
        'billing_cycle_end': cycleEnd?.toIso8601String(),
        'cycle_interval': billType,
        'is_closed': 0,
        'created_at': now,
        'updated_at': now,
        'admin_uid': adminUid,
      };

      await insert('bills', values, queueForSync: queueForSync);
      await recalcStudentAggregates(studentId);
      return id;
    } catch (e) {
      debugPrint("Error creating bill: $e");
      rethrow;
    }
  }

  Future<List<Map<String, Object?>>> getStudentBills(String studentId) async {
    try {
      final db = await database;
      return await db.query(
        'bills',
        where: 'student_id = ?',
        whereArgs: [studentId],
        orderBy: 'created_at DESC',
      );
    } catch (e) {
      debugPrint("Error getting bills: $e");
      return [];
    }
  }

  Future<String> recordPayment({
    String? id,
    required String billId,
    required String studentId,
    required double amount,
    required DateTime datePaid,
    String? method,
    String? adminUid,
    bool queueForSync = false,
  }) async {
    try {
      final db = await database;
      final pid = id ?? _generateId('PAY');
      final now = DateTime.now().millisecondsSinceEpoch;

      final values = {
        'id': pid,
        'bill_id': billId,
        'student_id': studentId,
        'amount': amount,
        'date_paid': datePaid.toIso8601String(),
        'method': method,
        'admin_uid': adminUid,
        'created_at': now,
      };

      await db.transaction((txn) async {
        await txn.insert(
          'payments',
          values,
          conflictAlgorithm: ConflictAlgorithm.replace,
        );

        // Update bill paid_amount
        await txn.rawUpdate(
          'UPDATE bills SET paid_amount = IFNULL(paid_amount, 0) + ? WHERE id = ?',
          [amount, billId],
        );

        // Auto-close bill
        final bill = await txn.query(
          'bills',
          where: 'id = ?',
          whereArgs: [billId],
          limit: 1,
        );
        if (bill.isNotEmpty) {
          final total = (bill.first['total_amount'] as num?)?.toDouble() ?? 0.0;
          final paid = (bill.first['paid_amount'] as num?)?.toDouble() ?? 0.0;
          if (paid >= total) {
            await txn.update(
              'bills',
              {'is_closed': 1, 'updated_at': now},
              where: 'id = ?',
              whereArgs: [billId],
            );
          }
        }

        if (queueForSync) {
          final payloadJson = jsonEncode(values);
          await txn.insert('sync_queue', {
            'table_name': 'payments',
            'operation': 'insert',
            'payload': payloadJson,
            'created_at': now,
            'tries': 0,
          });
        }
      });

      await recalcStudentAggregates(studentId);
      _emitChange({
        'action': 'record_payment',
        'id': pid,
        'student_id': studentId,
      });
      return pid;
    } catch (e) {
      debugPrint("Error recording payment: $e");
      rethrow;
    }
  }

  Future<int> generateMonthlyBills({DateTime? forDate}) async {
    final db = await database;
    final date = forDate ?? DateTime.now();
    final monthYear =
        '${date.year.toString().padLeft(4, '0')}-${date.month.toString().padLeft(2, '0')}';

    final students = await db.query(
      'students',
      where: 'is_active = 1 AND default_fee IS NOT NULL',
    );
    var created = 0;
    for (final s in students) {
      final sid = s['id'] as String;
      final billingType = (s['billing_type'] as String?) ?? 'monthly';
      if (billingType != 'monthly') continue;

      final exists = await _billExistsForPeriod(
        studentId: sid,
        monthYear: monthYear,
      );
      if (exists) continue;

      final fee = (s['default_fee'] as num?)?.toDouble() ?? 0.0;
      final firstOfMonth = DateTime(date.year, date.month, 1);
      final lastOfMonth = DateTime(date.year, date.month + 1, 0);

      await createBillForStudent(
        studentId: sid,
        totalAmount: fee,
        billType: 'monthly',
        monthYear: monthYear,
        cycleStart: firstOfMonth,
        cycleEnd: lastOfMonth,
        createdAt: firstOfMonth,
      );
      created++;
    }
    return created;
  }

  Future<int> generateTermlyBills({int? academicYear}) async {
    final db = await database;
    final now = DateTime.now();
    final year = academicYear ?? now.year;
    final terms = await getTermsForYear(year);
    var created = 0;

    for (final term in terms) {
      final termId = term['id'] as String;
      final termDatesJson = term['term_dates'] as String?;
      if (termDatesJson == null) continue;
      final Map<String, dynamic> datesMap =
          jsonDecode(termDatesJson) as Map<String, dynamic>;

      final students = await db.query(
        'students',
        where: 'is_active = 1 AND default_fee IS NOT NULL',
      );

      for (final entry in datesMap.entries) {
        final termNumStr = entry.key;
        final dates = entry.value as Map<String, dynamic>;
        final start = DateTime.parse(dates['start'] as String);
        final end = DateTime.parse(dates['end'] as String);

        for (final s in students) {
          final sid = s['id'] as String;
          final billingType = (s['billing_type'] as String?) ?? 'monthly';
          if (billingType != 'termly') continue;
          final compositeTermId = '$termId:$termNumStr';

          final exists = await _billExistsForPeriod(
            studentId: sid,
            termId: compositeTermId,
          );
          if (exists) continue;

          await createBillForStudent(
            studentId: sid,
            totalAmount: (s['default_fee'] as num?)?.toDouble() ?? 0.0,
            billType: 'termly',
            cycleStart: start,
            cycleEnd: end,
            adminUid: s['admin_uid'] as String?,
            termId: compositeTermId,
            queueForSync: false,
            createdAt: start,
          );
          created++;
        }
      }
    }
    return created;
  }

  Future<int> generateYearlyBills({int? year}) async {
    final db = await database;
    final now = DateTime.now();
    final y = year ?? now.year;
    final students = await db.query(
      'students',
      where: 'is_active = 1 AND default_fee IS NOT NULL',
    );
    var created = 0;
    for (final s in students) {
      final sid = s['id'] as String;
      final billingType = (s['billing_type'] as String?) ?? 'monthly';
      if (billingType != 'yearly') continue;

      final exists = await _billExistsForPeriod(studentId: sid, year: y);
      if (exists) continue;

      await createBillForStudent(
        studentId: sid,
        totalAmount: (s['default_fee'] as num?)?.toDouble() ?? 0.0,
        billType: 'yearly',
        cycleStart: DateTime(y, 1, 1),
        cycleEnd: DateTime(y, 12, 31),
        adminUid: s['admin_uid'] as String?,
        queueForSync: false,
        createdAt: DateTime(y, 1, 1),
      );
      created++;
    }
    return created;
  }

  Future<bool> _billExistsForPeriod({
    required String studentId,
    String? monthYear,
    String? termId,
    int? year,
  }) async {
    final db = await database;
    if (monthYear != null) {
      final rows = await db.query(
        'bills',
        where: 'student_id = ? AND month_year = ?',
        whereArgs: [studentId, monthYear],
        limit: 1,
      );
      return rows.isNotEmpty;
    }
    if (termId != null) {
      final rows = await db.query(
        'bills',
        where: 'student_id = ? AND term_id = ?',
        whereArgs: [studentId, termId],
        limit: 1,
      );
      return rows.isNotEmpty;
    }
    if (year != null) {
      final rows = await db.rawQuery(
        'SELECT 1 FROM bills WHERE student_id = ? AND strftime("%Y", datetime(created_at/1000, "unixepoch")) = ? LIMIT 1',
        [studentId, year.toString()],
      );
      return rows.isNotEmpty;
    }
    return false;
  }

  Future<int> generateBackdatedBillsForStudent(
    String studentId, {
    DateTime? fromDate,
    DateTime? toDate,
  }) async {
    final db = await database;
    final rows = await db.query(
      'students',
      where: 'id = ?',
      whereArgs: [studentId],
      limit: 1,
    );
    if (rows.isEmpty) return 0;
    final s = rows.first;
    final billingType = (s['billing_type'] as String?) ?? 'monthly';
    final fee = (s['default_fee'] as num?)?.toDouble();
    if (fee == null) return 0;

    DateTime start;
    if (fromDate != null) {
      start = fromDate;
    } else if (s['registration_date'] != null) {
      try {
        start = DateTime.parse(s['registration_date'] as String);
      } catch (_) {
        start = DateTime.now();
      }
    } else {
      return 0;
    }

    final end = toDate ?? DateTime.now();
    if (start.isAfter(end)) return 0;
    var created = 0;

    if (billingType == 'monthly') {
      var current = DateTime(start.year, start.month, 1);
      final last = DateTime(end.year, end.month, 1);
      while (!current.isAfter(last)) {
        final monthYear =
            '${current.year.toString().padLeft(4, '0')}-${current.month.toString().padLeft(2, '0')}';
        final exists = await _billExistsForPeriod(
          studentId: studentId,
          monthYear: monthYear,
        );
        if (!exists) {
          final firstOfMonth = DateTime(current.year, current.month, 1);
          final lastOfMonth = DateTime(current.year, current.month + 1, 0);
          await createBillForStudent(
            studentId: studentId,
            totalAmount: fee,
            billType: 'monthly',
            monthYear: monthYear,
            cycleStart: firstOfMonth,
            cycleEnd: lastOfMonth,
            adminUid: s['admin_uid'] as String?,
            queueForSync: false,
            createdAt: firstOfMonth,
          );
          created++;
        }
        current = DateTime(current.year, current.month + 1, 1);
      }
    }

    if (created > 0) await recalcStudentAggregates(studentId);
    return created;
  }

  Future<Map<String, int>> generateAllDueBills({
    DateTime? forDate,
    int? academicYear,
  }) async {
    final monthly = await generateMonthlyBills(forDate: forDate);
    final termly = await generateTermlyBills(academicYear: academicYear);
    final yearly = await generateYearlyBills(
      year: academicYear ?? DateTime.now().year,
    );
    return {'monthly': monthly, 'termly': termly, 'yearly': yearly};
  }

  // ===========================================================================
  // EXPENSES
  // ===========================================================================

  Future<int> recordExpense({
    required String title,
    required double amount,
    required DateTime date,
    String category = 'other',
    String? recipient,
    String? description,
    String? adminUid,
    bool queueForSync = false,
  }) async {
    final values = {
      'id': _generateId('EXP'),
      'title': title,
      'category': category,
      'amount': amount,
      'date_incurred': date.toIso8601String(),
      'recipient': recipient,
      'description': description,
      'admin_uid': adminUid,
      'created_at': DateTime.now().millisecondsSinceEpoch,
    };
    return await insert('expenses', values, queueForSync: queueForSync);
  }

  Future<List<Map<String, Object?>>> getExpenses({
    DateTime? startDate,
    DateTime? endDate,
  }) async {
    final db = await database;
    String where = '1=1';
    List<Object?> args = [];
    if (startDate != null) {
      where += ' AND date_incurred >= ?';
      args.add(startDate.toIso8601String());
    }
    if (endDate != null) {
      where += ' AND date_incurred <= ?';
      args.add(endDate.toIso8601String());
    }
    return await db.query(
      'expenses',
      where: where,
      whereArgs: args,
      orderBy: 'date_incurred DESC',
    );
  }

  Future<Map<String, double>> getFinancialHealth({
    DateTime? startDate,
    DateTime? endDate,
  }) async {
    final db = await database;
    String dateFilter = '';
    List<Object?> args = [];
    if (startDate != null && endDate != null) {
      dateFilter = ' WHERE date_paid >= ? AND date_paid <= ?';
      args = [startDate.toIso8601String(), endDate.toIso8601String()];
    }

    final incomeRows = await db.rawQuery(
      'SELECT IFNULL(SUM(amount),0) as total FROM payments $dateFilter',
      args,
    );
    final income = (incomeRows.first['total'] as num?)?.toDouble() ?? 0.0;

    String expDateFilter = '';
    if (startDate != null && endDate != null) {
      expDateFilter = ' WHERE date_incurred >= ? AND date_incurred <= ?';
    }
    final expRows = await db.rawQuery(
      'SELECT IFNULL(SUM(amount),0) as total FROM expenses $expDateFilter',
      args,
    );
    final expense = (expRows.first['total'] as num?)?.toDouble() ?? 0.0;

    return {
      'income': income,
      'expense': expense,
      'net_cash_flow': income - expense,
    };
  }

  // ===========================================================================
  // TEACHERS & CLASSES
  // ===========================================================================

  Future<String> createTeacher(
    Map<String, Object?> values, {
    bool queueForSync = false,
  }) async {
    final id = _generateId('TCH');
    values['id'] = id;
    await insert('teachers', values, queueForSync: queueForSync);
    return id;
  }

  Future<String> createClass(
    Map<String, Object?> values, {
    bool queueForSync = false,
  }) async {
    final id = _generateId('CLS');
    values['id'] = id;
    await insert('classes', values, queueForSync: queueForSync);
    return id;
  }

  Future<List<Map<String, Object?>>> getAllTeachers() async {
    final db = await database;
    return await db.query('teachers', orderBy: 'full_name ASC');
  }

  Future<List<Map<String, Object?>>> getAllClasses() async {
    final db = await database;
    return await db.rawQuery('''
      SELECT c.*, t.full_name as teacher_name 
      FROM classes c 
      LEFT JOIN teachers t ON c.teacher_id = t.id 
      ORDER BY c.name ASC
    ''');
  }

  Future<String> enrollStudentInClass({
    required String studentId,
    required String classId,
    String? adminUid,
  }) async {
    final db = await database;
    final existing = await db.query(
      'enrollments',
      where: 'student_id = ? AND class_id = ?',
      whereArgs: [studentId, classId],
    );
    if (existing.isNotEmpty) return existing.first['id'] as String;

    final values = {
      'id': _generateId('ENR'),
      'student_id': studentId,
      'class_id': classId,
      'enrolled_at': DateTime.now().toIso8601String(),
      'admin_uid': adminUid,
    };
    await insert('enrollments', values, queueForSync: true);
    return values['id'] as String;
  }

  Future<void> markAttendance({
    required String studentId,
    required String date,
    String? classId,
    String status = 'present',
    String? remarks,
    String? adminUid,
  }) async {
    final values = {
      'id': _generateId('ATT'),
      'student_id': studentId,
      'class_id': classId,
      'date': date,
      'status': status,
      'remarks': remarks,
      'admin_uid': adminUid,
      'created_at': DateTime.now().millisecondsSinceEpoch,
    };
    final db = await database;
    await db.insert(
      'attendance',
      values,
      conflictAlgorithm: ConflictAlgorithm.replace,
    );
    await addToSyncQueue('attendance', 'upsert', values);
    _emitChange({'action': 'mark_attendance', 'student_id': studentId});
  }

  Future<List<Map<String, Object?>>> getAttendanceForClass(
    String classId,
    String date,
  ) async {
    final db = await database;
    return await db.query(
      'attendance',
      where: 'class_id = ? AND date = ?',
      whereArgs: [classId, date],
    );
  }

  // ===========================================================================
  // ACADEMIC TERMS
  // ===========================================================================

  Future<String> createTerm({
    String? id,
    required String name,
    required int academicYear,
    required Map<int, Map<String, DateTime>> termDates,
    int? termNumber,
  }) async {
    final db = await database;
    final tid = id ?? _generateId('TERM');
    final mapped = <String, Map<String, String>>{};
    termDates.forEach((k, v) {
      mapped['$k'] = {
        'start': v['start']!.toIso8601String(),
        'end': v['end']!.toIso8601String(),
      };
    });
    await db.insert('school_terms', {
      'id': tid,
      'name': name,
      'academic_year': academicYear,
      'term_dates': jsonEncode(mapped),
      'term_number': termNumber,
      'created_at': DateTime.now().millisecondsSinceEpoch,
    }, conflictAlgorithm: ConflictAlgorithm.replace);
    return tid;
  }

  Future<List<Map<String, Object?>>> getTermsForYear(int year) async {
    final db = await database;
    return await db.query(
      'school_terms',
      where: 'academic_year = ?',
      whereArgs: [year],
      orderBy: 'term_number ASC',
    );
  }

  // ===========================================================================
  // GENERIC CRUD HELPERS (With Sync)
  // ===========================================================================

  Future<int> insert(
    String table,
    Map<String, Object?> values, {
    bool queueForSync = false,
  }) async {
    try {
      final db = await database;
      final id = await db.insert(
        table,
        values,
        conflictAlgorithm: ConflictAlgorithm.replace,
      );
      _emitChange({'action': 'insert', 'table': table, 'values': values});

      if (queueForSync) {
        await addToSyncQueue(table, 'insert', values);
      }
      return id;
    } catch (e) {
      debugPrint("DB Insert Error ($table): $e");
      rethrow;
    }
  }

  Future<int> update(
    String table,
    Map<String, Object?> values,
    String where,
    List<Object?> whereArgs, {
    bool queueForSync = false,
  }) async {
    try {
      final db = await database;
      final count = await db.update(
        table,
        values,
        where: where,
        whereArgs: whereArgs,
      );
      _emitChange({'action': 'update', 'table': table, 'values': values});

      if (queueForSync) {
        await addToSyncQueue(table, 'update', {
          'values': values,
          'where': where,
          'whereArgs': whereArgs,
        });
      }
      return count;
    } catch (e) {
      debugPrint("DB Update Error ($table): $e");
      rethrow;
    }
  }

  Future<int> delete(
    String table,
    String where,
    List<Object?> whereArgs, {
    bool queueForSync = false,
  }) async {
    try {
      final db = await database;
      final count = await db.delete(table, where: where, whereArgs: whereArgs);
      _emitChange({'action': 'delete', 'table': table, 'where': where});

      if (queueForSync) {
        await addToSyncQueue(table, 'delete', {
          'where': where,
          'whereArgs': whereArgs,
        });
      }
      return count;
    } catch (e) {
      debugPrint("DB Delete Error ($table): $e");
      rethrow;
    }
  }

  Future<int> addToSyncQueue(
    String tableName,
    String operation,
    Object? payload,
  ) async {
    try {
      final db = await database;
      final payloadJson = jsonEncode(payload);
      final now = DateTime.now().millisecondsSinceEpoch;
      final id = await db.insert('sync_queue', {
        'table_name': tableName,
        'operation': operation,
        'payload': payloadJson,
        'created_at': now,
        'tries': 0,
      });
      _emitChange({'action': 'sync_queue_add', 'id': id, 'table': tableName});
      return id;
    } catch (e) {
      debugPrint("Sync Queue Error: $e");
      return -1;
    }
  }

  Future<List<Map<String, Object?>>> query(
    String table, {
    List<String>? columns,
    String? where,
    List<Object?>? whereArgs,
    String? orderBy,
    int? limit,
    int? offset,
  }) async {
    final db = await database;
    return await db.query(
      table,
      columns: columns,
      where: where,
      whereArgs: whereArgs,
      orderBy: orderBy,
      limit: limit,
      offset: offset,
    );
  }

  Future<List<Map<String, Object?>>> rawQuery(
    String sql, [
    List<Object?>? args,
  ]) async {
    final db = await database;
    return await db.rawQuery(sql, args);
  }

  Future<int> rawUpdate(String sql, [List<Object?>? args]) async {
    final db = await database;
    return await db.rawUpdate(sql, args);
  }

  Future<int> rawDelete(String sql, [List<Object?>? args]) async {
    final db = await database;
    return await db.rawDelete(sql, args);
  }

  Future<int> rawInsert(String sql, [List<Object?>? args]) async {
    final db = await database;
    return await db.rawInsert(sql, args);
  }

  // ===========================================================================
  // HYDRATION & METADATA
  // ===========================================================================

  Future<List<StudentFull>> refreshStudentFullCache({
    bool includeInactive = false,
  }) async {
    try {
      final db = await database;
      final students = await db.query(
        'students',
        where: includeInactive ? null : 'is_active = 1',
      );
      final bills = await db.query('bills', orderBy: 'student_id, created_at');
      final payments = await db.query(
        'payments',
        orderBy: 'student_id, created_at',
      );

      final map = <String, StudentFull>{};
      for (final s in students) {
        final sm = StudentModel.fromMap(s);
        map[sm.id] = StudentFull(student: sm, bills: [], payments: []);
      }

      for (final b in bills) {
        final bm = BillModel.fromMap(b);
        if (map.containsKey(bm.studentId)) map[bm.studentId]!.bills.add(bm);
      }
      for (final p in payments) {
        final pm = PaymentModel.fromMap(p);
        if (map.containsKey(pm.studentId)) map[pm.studentId]!.payments.add(pm);
      }

      _studentFullCache = map.values.toList();
      _studentFullController.add(_studentFullCache!);
      return _studentFullCache!;
    } catch (e) {
      debugPrint("Cache Refresh Error: $e");
      return [];
    }
  }

  Future<List<StudentFull>> getAllStudentsWithFinancials({
    bool includeInactive = false,
  }) async {
    if (_studentFullCache == null) {
      return await refreshStudentFullCache(includeInactive: includeInactive);
    }
    if (!includeInactive) {
      return _studentFullCache!.where((s) => s.student.isActive).toList();
    }
    return _studentFullCache!;
  }

  Future<StudentFull?> getStudentFullById(String id) async {
    final all = await getAllStudentsWithFinancials(includeInactive: true);
    for (final s in all) {
      if (s.student.id == id) return s;
    }
    return null;
  }

  // --- Admin Logic ---

  String _generateAdminId() => _generateId('ADM');

  Future<String> createAdminProfile(Map<String, Object?> values) async {
    final db = await database;
    final id = (values['id'] as String?) ?? _generateAdminId();
    values['id'] = id;
    values['created_at'] = DateTime.now().millisecondsSinceEpoch;
    await db.insert(
      'admin_profile',
      values,
      conflictAlgorithm: ConflictAlgorithm.replace,
    );
    _emitChange({'action': 'create_admin', 'id': id});
    return id;
  }

  Future<Map<String, Object?>?> getAdminProfileById(String id) async {
    final db = await database;
    final rows = await db.query(
      'admin_profile',
      where: 'id = ?',
      whereArgs: [id],
      limit: 1,
    );
    if (rows.isEmpty) return null;
    return rows.first.cast<String, Object?>();
  }

  Future<String> ensureAdminExists(
    String uid, {
    Map<String, Object?>? defaults,
  }) async {
    final existing = await getAdminProfileById(uid);
    if (existing != null) return uid;

    final values = <String, Object?>{
      'id': uid,
      'email': defaults?['email'] ?? '$uid@local',
      'full_name': defaults?['full_name'] ?? 'Local Admin',
      'school_name': defaults?['school_name'] ?? 'Local School',
      'created_at': DateTime.now().millisecondsSinceEpoch,
    };
    await createAdminProfile(values);
    return uid;
  }

  Future<int> enforceAdminUidToAllTables(String adminUid) async {
    final db = await database;
    var total = 0;
    final tables = [
      'students',
      'bills',
      'payments',
      'teachers',
      'classes',
      'attendance',
      'expenses',
    ];
    for (final t in tables) {
      try {
        final updated = await db.rawUpdate(
          "UPDATE $t SET admin_uid = ? WHERE admin_uid IS NULL OR admin_uid = ''",
          [adminUid],
        );
        total += updated;
      } catch (_) {}
    }
    if (total > 0) {
      _emitChange({
        'action': 'enforce_admin_uid',
        'admin_uid': adminUid,
        'updated': total,
      });
    }
    return total;
  }

  Future<void> saveBillingConfig(BillingConfig config) async {
    final db = await database;
    await db.insert('billing_settings', {
      'id': 'current_config',
      'config_json': config.toJson(),
      'updated_at': DateTime.now().millisecondsSinceEpoch,
    }, conflictAlgorithm: ConflictAlgorithm.replace);
    _emitChange({'action': 'update_billing_config'});
  }

  Future<BillingConfig> getBillingConfig() async {
    final db = await database;
    try {
      final rows = await db.query(
        'billing_settings',
        where: 'id = ?',
        whereArgs: ['current_config'],
      );
      if (rows.isNotEmpty) {
        return BillingConfig.fromJson(rows.first['config_json'] as String);
      }
    } catch (_) {}
    return BillingConfig();
  }

  Future<void> setMetadata(String key, String value) async {
    final db = await database;
    await db.insert('metadata', {
      'key': key,
      'value': value,
    }, conflictAlgorithm: ConflictAlgorithm.replace);
  }

  Future<String?> getMetadata(String key) async {
    final db = await database;
    final rows = await db.query(
      'metadata',
      where: 'key = ?',
      whereArgs: [key],
      limit: 1,
    );
    return rows.isNotEmpty ? rows.first['value'] as String? : null;
  }

  String _generateId(String prefix) {
    return '${prefix}_${const Uuid().v4()}';
  }

  void _emitChange(Map<String, dynamic> event) {
    if (!_changeController.isClosed) {
      try {
        _changeController.add(event);
      } catch (_) {}
    }
  }

  Future<void> close() async {
    if (!_changeController.isClosed) await _changeController.close();
    if (_studentFullController.hasListener &&
        !_studentFullController.isClosed) {
      await _studentFullController.close();
    }
    if (_db != null) {
      await _db!.close();
      _db = null;
    }
  }
}
import 'dart:async';
import 'package:path/path.dart';
import 'package:sqflite/sqflite.dart';

/// A dedicated database service for App Preferences.
/// This is SEPARATE from the main 'fees_up.db' (School Data).
class SettingsDatabaseService {
  // Singleton
  SettingsDatabaseService._internal();
  static final SettingsDatabaseService instance = SettingsDatabaseService._internal();

  static const _dbName = 'app_settings.db'; // Distinct filename
  static const _dbVersion = 1;
  static const _tableName = 'user_preferences';

  Database? _db;

  Future<Database> get database async {
    if (_db != null) return _db!;
    _db = await _initDatabase();
    return _db!;
  }

  Future<Database> _initDatabase() async {
    final dbPath = await getDatabasesPath();
    final path = join(dbPath, _dbName);

    return await openDatabase(
      path,
      version: _dbVersion,
      onCreate: (db, version) async {
        // Key-Value store structure for maximum flexibility
        await db.execute('''
          CREATE TABLE $_tableName (
            key TEXT PRIMARY KEY,
            value TEXT,
            type TEXT -- 'bool', 'int', 'string', 'double'
          )
        ''');

        // Insert Defaults
        await db.insert(_tableName, {'key': 'biometric_enabled', 'value': 'false', 'type': 'bool'});
        await db.insert(_tableName, {'key': 'notifications_enabled', 'value': 'true', 'type': 'bool'});
        await db.insert(_tableName, {'key': 'language', 'value': 'English (US)', 'type': 'string'});
        await db.insert(_tableName, {'key': 'dark_mode', 'value': 'true', 'type': 'bool'});
      },
    );
  }

  // --- CRUD Operations ---

  Future<dynamic> getSetting(String key, {dynamic defaultValue}) async {
    final db = await database;
    final List<Map<String, dynamic>> maps = await db.query(
      _tableName,
      where: 'key = ?',
      whereArgs: [key],
    );

    if (maps.isEmpty) return defaultValue;

    final row = maps.first;
    final val = row['value'] as String;
    final type = row['type'] as String;

    // Type casting
    if (type == 'bool') return val == 'true';
    if (type == 'int') return int.tryParse(val) ?? defaultValue;
    if (type == 'double') return double.tryParse(val) ?? defaultValue;
    return val; // string
  }

  Future<void> setSetting(String key, dynamic value) async {
    final db = await database;
    String type = 'string';
    String stringVal = value.toString();

    if (value is bool) type = 'bool';
    if (value is int) type = 'int';
    if (value is double) type = 'double';

    await db.insert(
      _tableName,
      {'key': key, 'value': stringVal, 'type': type},
      conflictAlgorithm: ConflictAlgorithm.replace,
    );
  }
}import 'dart:async';
import 'dart:convert';
import 'dart:io';

import 'package:connectivity_plus/connectivity_plus.dart';
import 'package:flutter/foundation.dart';
import 'package:supabase_flutter/supabase_flutter.dart';
import '../services/database_service.dart';

/// Service responsible for two-way synchronization between Local SQLite and Supabase.
///
/// STRATEGY:
/// 1. Check Connectivity: Fail fast if offline.
/// 2. Push Local Changes: Upload pending items from `sync_queue` to Supabase.
/// 3. Pull Remote Changes: Download updates from Supabase based on `last_synced_at`.
/// 4. Conflict Resolution: "Last Write Wins", but with a data-completeness check.
class SyncDataService {
  // Singleton
  static final SyncDataService instance = SyncDataService._internal();
  SyncDataService._internal();

  final _supabase = Supabase.instance.client;
  bool _isSyncing = false;

  // Tables to sync (Order matters for foreign keys)
  final List<String> _tables = [
    'schools', // Parent
    'campaigns',
    'school_terms',
    'students',
    'teachers',
    'classes',
    'enrollments',
    'bills',
    'payments', // Income
    'expenses', // Outflow
    'attendance',
    'campaign_donations',
    'student_archives',
    'user_profiles',
  ];

  /// Main entry point to trigger a sync.
  /// Returns `true` if sync was successful, `false` if skipped or failed.
  Future<bool> triggerSmartSync() async {
    if (_isSyncing) {
      debugPrint("Sync already in progress. Skipping.");
      return false;
    }

    // 1. Check Connectivity
    if (!await _hasInternetConnection()) {
      debugPrint("No internet connection. Sync deferred.");
      return false;
    }

    _isSyncing = true;
    debugPrint("--- STARTING SMART SYNC ---");

    try {
      // 2. PUSH: Upload Local Changes
      await _pushLocalChanges();

      // 3. PULL: Download Remote Updates
      await _pullRemoteChanges();

      debugPrint("--- SYNC COMPLETED SUCCESSFULLY ---");
      return true;
    } catch (e, stack) {
      debugPrint("SYNC ERROR: $e");
      debugPrint(stack.toString());
      return false;
    } finally {
      _isSyncing = false;
    }
  }

  // ---------------------------------------------------------------------------
  // PUSH LOGIC (Local -> Cloud)
  // ---------------------------------------------------------------------------

  Future<void> _pushLocalChanges() async {
    final db = DatabaseService.instance;

    // Get pending operations from queue
    final pendingItems = await db.getPendingSyncOperations(limit: 50);
    if (pendingItems.isEmpty) {
      debugPrint("Push: No local changes to upload.");
      return;
    }

    debugPrint("Pushing ${pendingItems.length} local changes...");

    List<int> successfulIds = [];

    for (var item in pendingItems) {
      try {
        final id = item['id'] as int;
        final table = item['table_name'] as String;
        final op = item['operation'] as String; // 'insert', 'update', 'delete'
        final payloadJson = item['payload'] as String?;

        if (payloadJson == null) continue;
        final Map<String, dynamic> data = jsonDecode(payloadJson);

        // Sanitize data before sending
        final sanitizedData = _sanitizePayload(data);

        if (op == 'insert') {
          // Upsert ensures idempotency (if ID already exists on server, update it)
          await _supabase.from(table).upsert(sanitizedData).select();
        } else if (op == 'update') {
          if (sanitizedData.containsKey('id')) {
            await _supabase
                .from(table)
                .update(sanitizedData)
                .eq('id', sanitizedData['id']);
          }
        } else if (op == 'delete') {
          if (sanitizedData.containsKey('id')) {
            await _supabase
                .from(table)
                .delete()
                .eq('id', sanitizedData['id']);
          }
        }

        successfulIds.add(id);
      } catch (e) {
        debugPrint("Failed to push item ${item['id']}: $e");
        // We do NOT add to successfulIds, so it retries next time.
      }
    }

    // Clear processed queue items
    if (successfulIds.isNotEmpty) {
      await db.confirmSyncList(successfulIds);
      debugPrint("Push: Confirmed ${successfulIds.length} items.");
    }
  }

  Map<String, dynamic> _sanitizePayload(Map<String, dynamic> data) {
    // Remove fields that only exist locally or shouldn't be overwritten blindly
    final copy = Map<String, dynamic>.from(data);
    copy.remove('is_synced');
    copy.remove('tries');
    // Ensure we don't send null IDs for inserts if they are auto-generated on server
    // (Though in your architecture, UUIDs are usually generated locally)
    return copy;
  }

  // ---------------------------------------------------------------------------
  // PULL LOGIC (Cloud -> Local)
  // ---------------------------------------------------------------------------

  Future<void> _pullRemoteChanges() async {
    final db = DatabaseService.instance;

    // Get last sync timestamp
    final lastSyncStr = await db.getMetadata('last_remote_sync');
    final lastSync =
        lastSyncStr != null ? DateTime.parse(lastSyncStr) : DateTime(2000);

    // Capture server time now (approx) for next sync
    final syncStartTime = DateTime.now().toUtc();

    for (final table in _tables) {
      try {
        // Fetch rows created/updated after last sync
        // Note: This relies on 'created_at'. ideally your tables should have 'updated_at'.
        // If 'updated_at' exists, use .or('updated_at.gt.$time,created_at.gt.$time')
        final response = await _supabase
            .from(table)
            .select()
            .gt('created_at', lastSync.toIso8601String());

        final List<dynamic> rows = response;
        if (rows.isEmpty) continue;

        debugPrint("Pull: Found ${rows.length} updates for '$table'");

        for (var row in rows) {
          final remoteData = row as Map<String, dynamic>;
          await _mergeRemoteData(table, remoteData);
        }
      } catch (e) {
        debugPrint("Pull Error on table '$table': $e");
        // Continue to next table, don't abort entire sync
      }
    }

    // Update last sync time
    await db.setMetadata('last_remote_sync', syncStartTime.toIso8601String());
  }

  // ---------------------------------------------------------------------------
  // CONFLICT RESOLUTION
  // ---------------------------------------------------------------------------

  Future<void> _mergeRemoteData(
      String table, Map<String, dynamic> remoteData) async {
    final db = DatabaseService.instance;
    final id = remoteData['id'] as String;

    // 1. Check if record exists locally
    final localRows = await db.query(table, where: 'id = ?', whereArgs: [id]);

    if (localRows.isEmpty) {
      // Case A: New Record -> Insert
      await db.insert(table, remoteData, queueForSync: false);
    } else {
      // Case B: Conflict -> Check completeness
      final localData = localRows.first;

      if (_shouldOverwrite(localData, remoteData)) {
        await db.update(table, remoteData, 'id = ?', [id], queueForSync: false);
        debugPrint("  -> Overwrote local $table:$id with remote version");
      } else {
        debugPrint(
            "  -> Ignored remote $table:$id (Local version has better data)");
      }
    }
  }

  /// Decides if [remote] data is better than [local] data.
  /// Returns `true` if we should overwrite local data with remote.
  bool _shouldOverwrite(
      Map<String, dynamic> local, Map<String, dynamic> remote) {
    // 1. DATA INTEGRITY CHECK (Refortified)
    // We explicitly define fields that are critical. If the server sends a NULL
    // for these, but we have valid data locally, we reject the server update.
    // This happens if someone accidentally wipes a field on the dashboard.
    const criticalFields = [
      'full_name',
      'amount',
      'title',
      'total_amount',
      'donor_name',
      'payer_name'
    ];

    for (var key in criticalFields) {
      // Condition: Remote has the key, it is null, BUT Local is NOT null.
      if (remote.containsKey(key) &&
          remote[key] == null &&
          local[key] != null) {
        return false; // Reject remote: It's missing vital info we have.
      }
    }

    // 2. TIMESTAMPS (Optional Refinement)
    // If your schema supports 'updated_at', un-comment this to respect time:
    /*
    if (remote.containsKey('updated_at') && local.containsKey('updated_at')) {
      final remoteTime = DateTime.tryParse(remote['updated_at'].toString()) ?? DateTime(2000);
      final localTime = DateTime.tryParse(local['updated_at'].toString()) ?? DateTime(2000);
      if (localTime.isAfter(remoteTime)) {
        return false; // Local is newer
      }
    }
    */

    // 3. DEFAULT: TRUST SERVER
    // If no critical data is lost, we assume the Server is the 'Source of Truth'.
    return true;
  }

  // ---------------------------------------------------------------------------
  // UTILITIES
  // ---------------------------------------------------------------------------

  Future<bool> _hasInternetConnection() async {
    try {
      final connectivityResult = await Connectivity().checkConnectivity();
      if (connectivityResult.contains(ConnectivityResult.none)) {
        return false;
      }

      // Double check with a real lookup (DNS) to prevent "Connected but no Data" issues
      final result = await InternetAddress.lookup('google.com');
      return result.isNotEmpty && result[0].rawAddress.isNotEmpty;
    } catch (e) {
      return false;
    }
  }
}import 'dart:convert';

class TermConfig {
  String id;
  String name;
  String year;
  DateTime start;
  DateTime end;

  TermConfig({
    required this.id,
    required this.name,
    required this.year,
    required this.start,
    required this.end,
  });

  Map<String, dynamic> toMap() => {
    'id': id,
    'name': name,
    'year': year,
    'start': start.toIso8601String(),
    'end': end.toIso8601String(),
  };

  factory TermConfig.fromMap(Map<String, dynamic> map) => TermConfig(
    id: map['id'],
    name: map['name'],
    year: map['year'],
    start: DateTime.parse(map['start']),
    end: DateTime.parse(map['end']),
  );
}

class BillingConfig {
  String billingType;
  int cycleInterval;
  double defaultFee;
  List<TermConfig> terms;
  List<String> expenseCategories; // Mutable List
  bool autoLateFee;
  int graceDays;
  double lateFeeAmount;

  BillingConfig({
    this.billingType = 'Term-based',
    this.cycleInterval = 3,
    this.defaultFee = 0.0,
    List<TermConfig>? terms,
    List<String>? expenseCategories,
    this.autoLateFee = false,
    this.graceDays = 5,
    this.lateFeeAmount = 0.0,
  }) : // Create new mutable lists to prevent "Unsupported operation" crash
       terms = terms ?? [],
       expenseCategories =
           expenseCategories ??
           ['Salary', 'Maintenance', 'Supplies', 'Utilities'];

  String toJson() => jsonEncode({
    'billingType': billingType,
    'cycleInterval': cycleInterval,
    'defaultFee': defaultFee,
    'terms': terms.map((x) => x.toMap()).toList(),
    'expenseCategories': expenseCategories,
    'autoLateFee': autoLateFee,
    'graceDays': graceDays,
    'lateFeeAmount': lateFeeAmount,
  });

  factory BillingConfig.fromJson(String source) {
    final map = jsonDecode(source);
    return BillingConfig(
      billingType: map['billingType'] ?? 'Term-based',
      cycleInterval: map['cycleInterval'] ?? 3,
      defaultFee: (map['defaultFee'] as num?)?.toDouble() ?? 0.0,
      terms: (map['terms'] as List?)
          ?.map((x) => TermConfig.fromMap(x))
          .toList(),
      expenseCategories: List<String>.from(map['expenseCategories'] ?? []),
      autoLateFee: map['autoLateFee'] ?? false,
      graceDays: map['graceDays'] ?? 5,
      lateFeeAmount: (map['lateFeeAmount'] as num?)?.toDouble() ?? 0.0,
    );
  }
}// lib/models/student_full.dart

/// Lightweight student model used by hydration routines.
/// This mirrors the `students` SQL table but is optimized for in-memory use.
class StudentModel {
  final String id;
  final String? fullName;
  final String? grade;
  final String? parentContact;
  final DateTime? registrationDate;
  final String? billingType;
  final bool isActive;
  final double? defaultFee;
  final String? adminUid;

  final double paidTotal;
  final double owedTotal;

  // NEW FIELD: simple comma-separated subjects string
  final String? subjects;

  StudentModel({
    required this.id,
    this.fullName,
    this.grade,
    this.parentContact,
    this.registrationDate,
    this.billingType,
    this.isActive = true,
    this.defaultFee,
    this.adminUid,
    this.paidTotal = 0.0,
    this.owedTotal = 0.0,
    this.subjects,
  });

  factory StudentModel.fromMap(Map<String, Object?> m) {
    DateTime? reg;
    try {
      if (m['registration_date'] != null) {
        reg = DateTime.parse(m['registration_date'] as String);
      }
    } catch (_) {}

    return StudentModel(
      id: m['id'] as String,
      fullName: m['full_name'] as String?,
      grade: m['grade'] as String?,
      parentContact: m['parent_contact'] as String?,
      registrationDate: reg,
      billingType: m['billing_type'] as String?,
      isActive: (m['is_active'] as int? ?? 1) == 1,
      defaultFee: (m['default_fee'] as num?)?.toDouble(),
      adminUid: m['admin_uid'] as String?,
      paidTotal: (m['paid_total'] as num?)?.toDouble() ?? 0.0,
      owedTotal: (m['owed_total'] as num?)?.toDouble() ?? 0.0,
      subjects: m['subjects'] as String?, // new
    );
  }
}

/// Lightweight bill model used in the StudentFull composite.
class BillModel {
  final String id;
  final String studentId;
  final String? termId;
  final String billType;
  final double totalAmount;
  final double paidAmount;
  final String? monthYear;
  final DateTime? cycleStart;
  final DateTime? cycleEnd;
  final bool isClosed;
  final DateTime? createdAt;
  final DateTime? updatedAt;

  BillModel({
    required this.id,
    required this.studentId,
    this.termId,
    required this.billType,
    required this.totalAmount,
    this.paidAmount = 0.0,
    this.monthYear,
    this.cycleStart,
    this.cycleEnd,
    this.isClosed = false,
    this.createdAt,
    this.updatedAt,
  });

  factory BillModel.fromMap(Map<String, Object?> m) {
    DateTime? cs;
    DateTime? ce;
    DateTime? ca;
    DateTime? ua;

    try {
      if (m['billing_cycle_start'] != null) {
        cs = DateTime.parse(m['billing_cycle_start'] as String);
      }
      if (m['billing_cycle_end'] != null) {
        ce = DateTime.parse(m['billing_cycle_end'] as String);
      }
    } catch (_) {}

    try {
      if (m['created_at'] != null) {
        ca = DateTime.fromMillisecondsSinceEpoch((m['created_at'] as num).toInt());
      }
    } catch (_) {}

    try {
      if (m['updated_at'] != null) {
        ua = DateTime.fromMillisecondsSinceEpoch((m['updated_at'] as num).toInt());
      }
    } catch (_) {}

    return BillModel(
      id: m['id'] as String,
      studentId: m['student_id'] as String,
      termId: m['term_id'] as String?,
      billType: (m['bill_type'] as String?) ?? 'monthly',
      totalAmount: (m['total_amount'] as num).toDouble(),
      paidAmount: (m['paid_amount'] as num?)?.toDouble() ?? 0.0,
      monthYear: m['month_year'] as String?,
      cycleStart: cs,
      cycleEnd: ce,
      isClosed: (m['is_closed'] as int? ?? 0) == 1,
      createdAt: ca,
      updatedAt: ua,
    );
  }
}

/// Lightweight payment model.
class PaymentModel {
  final String id;
  final String? billId;
  final String studentId;
  final double amount;
  final DateTime? datePaid;
  final String? method;
  final DateTime? createdAt;

  PaymentModel({
    required this.id,
    this.billId,
    required this.studentId,
    required this.amount,
    this.datePaid,
    this.method,
    this.createdAt,
  });

  factory PaymentModel.fromMap(Map<String, Object?> m) {
    DateTime? dp;
    DateTime? ca;

    try {
      if (m['date_paid'] != null) {
        dp = DateTime.parse(m['date_paid'] as String);
      }
    } catch (_) {}

    try {
      if (m['created_at'] != null) {
        ca = DateTime.fromMillisecondsSinceEpoch((m['created_at'] as num).toInt());
      }
    } catch (_) {}

    return PaymentModel(
      id: m['id'] as String,
      billId: m['bill_id'] as String?,
      studentId: m['student_id'] as String,
      amount: (m['amount'] as num).toDouble(),
      datePaid: dp,
      method: m['method'] as String?,
      createdAt: ca,
    );
  }
}

/// Hydrated composite containing the StudentModel, its bills, and its payments.
class StudentFull {
  final StudentModel student;
  final List<BillModel> bills;
  final List<PaymentModel> payments;

  StudentFull({
    required this.student,
    this.bills = const [],
    this.payments = const [],
  });

  double get totalBilled => bills.fold(0.0, (p, b) => p + b.totalAmount);
  double get totalPaid => payments.fold(0.0, (p, pay) => p + pay.amount);
  double get owed => (totalBilled - totalPaid).clamp(0.0, double.infinity);
}

// lib/models/dashboard_summary.dart

class DashboardSummary {
  final int activeStudents;
  final int inactiveStudents;
  final double totalFeesBilled;
  final double totalFeesOwed;
  final double totalFeesPaid;

  DashboardSummary({
    required this.activeStudents,
    this.inactiveStudents = 0,
    this.totalFeesBilled = 0.0,
    this.totalFeesOwed = 0.0,
    this.totalFeesPaid = 0.0,
  });

  factory DashboardSummary.initial() => DashboardSummary(activeStudents: 0);
}// File: lib/models/subjects.dart

class ZimsecSubject {
  static const Map<int, String> _codeMap = {
    // --- FORM 1 - 4 (O-LEVEL) CORE ---
    // These are the "Must-Haves" for almost every student.
    4005: 'English Language',
    4004: 'Mathematics',
    4003: 'Combined Science', // Replaces Integrated Science
    4006: 'Heritage Studies',
    4007: 'Shona',
    4068: 'Ndebele',
    4001: 'Agriculture',

    // --- FORM 1 - 4 (O-LEVEL) POPULAR ELECTIVES ---
    // Commercials & Arts
    4049: 'Commerce',
    4037: 'Geography',
    4044: 'History',
    4047: 'Family & Religious Studies', // F.R.S (formerly Divinity/R.E)
    4048: 'Business Enterprise Skills',
    4051: 'Principles of Accounting',

    // Sciences & Tech
    4029: 'Computer Science',
    4025: 'Biology',
    4023: 'Physics',
    4024:
        'Chemistry', // Often listed as 5070/5071 in older systems, but 4024 in new curriculum maps
    4059: 'Wood Technology and Design',

    // --- FORM 5 - 6 (A-LEVEL) ---
    // Commercials
    6001: 'Accounting (A-Level)',
    6025: 'Business Studies',
    6073: 'Economics',

    // Arts / Humanities
    6022: 'Geography (A-Level)',
    6006: 'History (A-Level)',
    6003: 'Divinity',
    6009: 'Literature in English',
    6081: 'Heritage Studies (A-Level)',

    // Sciences
    6042: 'Pure Mathematics',
    6030: 'Biology (A-Level)',
    6031: 'Chemistry (A-Level)',
    6032: 'Physics (A-Level)',
    6046: 'Statistics',
    6008: 'Computer Science (A-Level)',
  };

  // This is the getter your Registration Page is looking for:
  static List<String> get allNames => _codeMap.values.toList();

  static String nameFromCode(int code) => _codeMap[code] ?? 'Unknown';
}

class EnrolledSubject {
  final String subjectName;
  final String studentId;

  EnrolledSubject({required this.subjectName, required this.studentId});

  Map<String, dynamic> toJson() => {
    'subjectName': subjectName,
    'studentId': studentId,
  };

  factory EnrolledSubject.fromJson(Map<String, dynamic> json) {
    return EnrolledSubject(
      subjectName: json['subjectName'],
      studentId: json['studentId'],
    );
  }
}// lib/pages/update_student_page.dart

import 'package:fees_up/models/student_full.dart';
import 'package:flutter/material.dart';
import 'package:intl/intl.dart';
import '../services/database_service.dart';
import '../utils/subject_selection_modal.dart';

class UpdateStudentPage extends StatefulWidget {
  final String studentId;
  final StudentFull? initialStudentData;

  const UpdateStudentPage({super.key, required this.studentId, this.initialStudentData});
  static const String routeName = '/update_student';

  @override
  State<UpdateStudentPage> createState() => _UpdateStudentPageState();
}

class _UpdateStudentPageState extends State<UpdateStudentPage> {
  final _formKey = GlobalKey<FormState>();
  
  // -- Controllers --
  final _nameController = TextEditingController();
  final _contactController = TextEditingController();
  final _feeController = TextEditingController();
  
  // -- State variables --
  String _selectedGrade = 'FORM 1';
  DateTime _registrationDate = DateTime.now();
  
  // Initialize to a safe default (next month), will be overwritten by DB fetch
  DateTime _nextBillingDate = DateTime.now().add(const Duration(days: 30));
  
  String _billingType = 'monthly'; 
  bool _isActive = true;
  List<String> _selectedSubjects = [];
  bool _isSaving = false;

  // Grade Options
  final List<String> _grades = [
    'ECD A', 'ECD B',
    'GRADE 1', 'GRADE 2', 'GRADE 3', 'GRADE 4', 'GRADE 5', 'GRADE 6', 'GRADE 7',
    'FORM 1', 'FORM 2', 'FORM 3', 'FORM 4', 'LOWER 6', 'UPPER 6'
  ];

  @override
  void initState() {
    super.initState();
    _loadInitialData();
    _fetchLatestBillingDate(); // Fetch the specific billing date field
  }
  
  void _loadInitialData() {
    final s = widget.initialStudentData?.student;
    
    if (s != null) {
      _nameController.text = s.fullName ?? '';
      _contactController.text = s.parentContact ?? '';
      _feeController.text = s.defaultFee?.toStringAsFixed(2) ?? '0.00';
      
      _selectedGrade = s.grade ?? _grades.first;
      _registrationDate = s.registrationDate ?? DateTime.now();
      _billingType = s.billingType ?? 'monthly';
      _isActive = s.isActive;
      _selectedSubjects = s.subjects?.split(',').where((x) => x.isNotEmpty).toList() ?? [];
    }
  }

  // Fetch the billing_date separately in case StudentModel isn't updated yet
  Future<void> _fetchLatestBillingDate() async {
    final db = DatabaseService.instance;
    final data = await db.getStudentById(widget.studentId);
    if (data != null && data['billing_date'] != null) {
      setState(() {
        _nextBillingDate = DateTime.parse(data['billing_date'] as String);
      });
    }
  }

  @override
  void dispose() {
    _nameController.dispose();
    _contactController.dispose();
    _feeController.dispose();
    super.dispose();
  }

  // --- Logic: Pick Registration Date ---
  Future<void> _pickDate() async {
    final picked = await showDatePicker(
      context: context,
      initialDate: _registrationDate,
      firstDate: DateTime(2000),
      lastDate: DateTime.now().add(const Duration(days: 365)),
    );
    if (picked != null) {
      setState(() => _registrationDate = picked);
    }
  }

  // --- Logic: Pick Next Billing Date ---
  Future<void> _pickBillingDate() async {
    final picked = await showDatePicker(
      context: context,
      initialDate: _nextBillingDate,
      firstDate: DateTime.now().subtract(const Duration(days: 365)), // Allow retroactive fixes
      lastDate: DateTime.now().add(const Duration(days: 365 * 2)),
      // DISABLE 29, 30, 31 to ensure consistent monthly billing cycles
      selectableDayPredicate: (DateTime val) => val.day <= 28,
    );
    if (picked != null) {
      setState(() => _nextBillingDate = picked);
    }
  }

  // --- Logic: Select Subjects ---
  void _openSubjectPicker() {
    showModalBottomSheet(
      context: context,
      isScrollControlled: true,
      backgroundColor: Colors.transparent,
      builder: (context) => SubjectSelectionModal(
        selectedSubjects: _selectedSubjects,
        onConfirmed: (List<String> newSelection) {
          setState(() => _selectedSubjects = newSelection);
        },
      ),
    );
  }

  // --- Logic: UPDATE Student ---
  Future<void> _updateStudent() async {
    if (!_formKey.currentState!.validate()) return;

    setState(() => _isSaving = true);

    try {
      final db = DatabaseService.instance;
      
      final defaultFee = double.tryParse(_feeController.text) ?? 0.0;

      // Data map containing fields to be updated
      final valuesToUpdate = {
        'full_name': _nameController.text.trim(),
        'parent_contact': _contactController.text.trim(),
        'grade': _selectedGrade,
        'registration_date': _registrationDate.toIso8601String(),
        'billing_date': _nextBillingDate.toIso8601String(), // Updated Billing Date
        'billing_type': _billingType,
        'default_fee': defaultFee,
        'is_active': _isActive ? 1 : 0,
        'subjects': _selectedSubjects.join(','), 
      };

      final updateCount = await db.update(
        'students', 
        valuesToUpdate, 
        'id = ?', 
        [widget.studentId]
      );

      if (mounted) {
        if (updateCount > 0) {
          ScaffoldMessenger.of(context).showSnackBar(
            const SnackBar(content: Text('Student profile updated successfully')),
          );
          Navigator.pop(context, true); 
        } else {
          ScaffoldMessenger.of(context).showSnackBar(
            const SnackBar(content: Text('No changes were saved.')),
          );
        }
      }
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('Error updating student: $e'), backgroundColor: Colors.red),
        );
      }
    } finally {
      if (mounted) setState(() => _isSaving = false);
    }
  }

  @override
  Widget build(BuildContext context) {
    // Theme helpers
    final theme = Theme.of(context);
    
    // Styles
    final sectionHeaderStyle = TextStyle(
      fontSize: 13.0, 
      fontWeight: FontWeight.w700, 
      color: theme.colorScheme.primary, 
      letterSpacing: 1.1,
    );
    
    // Standardized Input Decoration (Outlined Box)
    final inputDecoration = BoxDecoration(
      color: theme.colorScheme.surface,
      borderRadius: BorderRadius.circular(12.0),
      border: Border.all(
        color: theme.colorScheme.outlineVariant,
        width: 1.0,
      ),
    );

    return Scaffold(
      backgroundColor: theme.colorScheme.surface,
      appBar: AppBar(
        title: Text('Edit Student: ${widget.initialStudentData?.student.fullName ?? widget.studentId}'),
        centerTitle: true,
        backgroundColor: theme.colorScheme.surface,
        scrolledUnderElevation: 0,
        leading: IconButton(
          icon: const Icon(Icons.close),
          onPressed: () => Navigator.pop(context),
        ),
        actions: [
          TextButton(
            onPressed: _isSaving ? null : _updateStudent,
            child: Text(
              'SAVE',
              style: TextStyle(
                fontWeight: FontWeight.bold,
                color: _isSaving ? Colors.grey : theme.colorScheme.primary,
              ),
            ),
          )
        ],
      ),
      body: Center(
        child: ConstrainedBox(
          constraints: const BoxConstraints(maxWidth: 600),
          child: SingleChildScrollView(
            padding: const EdgeInsets.symmetric(horizontal: 20.0, vertical: 24.0),
            child: Form(
              key: _formKey,
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.stretch,
                children: [
                  // --- PERSONAL INFORMATION ---
                  Text("PERSONAL INFORMATION", style: sectionHeaderStyle),
                  const SizedBox(height: 12),
                  
                  _buildInputContainer(
                    decoration: inputDecoration,
                    child: TextFormField(
                      controller: _nameController,
                      style: TextStyle(color: theme.colorScheme.onSurface),
                      decoration: _inputDecor(hint: "e.g. John Smith", label: "Full Name"),
                      validator: (v) => v == null || v.isEmpty ? 'Name is required' : null,
                    ),
                  ),
                  const SizedBox(height: 12),
                  
                  _buildInputContainer(
                    decoration: inputDecoration,
                    child: TextFormField(
                      controller: _contactController,
                      style: TextStyle(color: theme.colorScheme.onSurface),
                      keyboardType: TextInputType.phone,
                      decoration: _inputDecor(
                        hint: "+263 77 123 4567", 
                        label: "Parent Contact",
                        icon: Icons.phone_outlined
                      ),
                    ),
                  ),

                  const SizedBox(height: 32),
                  
                  // --- ACADEMIC SECTION ---
                  Text("ACADEMIC & SUBJECTS", style: sectionHeaderStyle),
                  const SizedBox(height: 12),

                  // Grade Dropdown
                  Container(
                    padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 4),
                    decoration: inputDecoration,
                    child: DropdownButtonHideUnderline(
                      child: DropdownButton<String>(
                        value: _selectedGrade,
                        isExpanded: true,
                        dropdownColor: theme.colorScheme.surfaceContainer,
                        icon: Icon(Icons.arrow_drop_down, color: theme.colorScheme.onSurface),
                        items: _grades.map((g) => DropdownMenuItem(
                          value: g, 
                          child: Text(g, style: TextStyle(color: theme.colorScheme.onSurface))
                        )).toList(),
                        onChanged: (v) => setState(() => _selectedGrade = v!),
                      ),
                    ),
                  ),
                  const SizedBox(height: 12),

                  // Subject Selection Tile
                  GestureDetector(
                    onTap: _openSubjectPicker,
                    child: Container(
                      padding: const EdgeInsets.all(16),
                      decoration: inputDecoration,
                      child: Column(
                        crossAxisAlignment: CrossAxisAlignment.start,
                        children: [
                          Row(
                            mainAxisAlignment: MainAxisAlignment.spaceBetween,
                            children: [
                              Text("Enrolled Subjects", 
                                style: TextStyle(
                                  color: theme.colorScheme.onSurfaceVariant, 
                                  fontSize: 16
                                )
                              ),
                              Icon(Icons.add_circle_outline, color: theme.colorScheme.primary),
                            ],
                          ),
                          if (_selectedSubjects.isNotEmpty) ...[
                            const SizedBox(height: 12),
                            Wrap(
                              spacing: 8,
                              runSpacing: 8,
                              children: _selectedSubjects.map((s) => Chip(
                                label: Text(s, style: TextStyle(fontSize: 12, color: theme.colorScheme.onPrimaryContainer)),
                                backgroundColor: theme.colorScheme.primaryContainer,
                                shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(8), side: BorderSide.none),
                                labelPadding: const EdgeInsets.symmetric(horizontal: 2),
                                visualDensity: VisualDensity.compact,
                                onDeleted: () => setState(() => _selectedSubjects.remove(s)),
                                deleteIconColor: theme.colorScheme.onPrimaryContainer.withAlpha(128),
                              )).toList(),
                            )
                          ] else ...[
                            const SizedBox(height: 8),
                            Text("Tap to select core and elective subjects", 
                              style: TextStyle(color: theme.colorScheme.onSurface.withAlpha(102), fontSize: 13, fontStyle: FontStyle.italic)),
                          ]
                        ],
                      ),
                    ),
                  ),
                  const SizedBox(height: 12),

                  // Registration Date Picker
                  InkWell(
                    onTap: _pickDate,
                    borderRadius: BorderRadius.circular(12),
                    child: Container(
                      padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 16),
                      decoration: inputDecoration,
                      child: Row(
                        mainAxisAlignment: MainAxisAlignment.spaceBetween,
                        children: [
                          Text("Registration Date", style: TextStyle(color: theme.colorScheme.onSurface)),
                          Row(
                            children: [
                              Text(
                                DateFormat('MMM dd, yyyy').format(_registrationDate),
                                style: TextStyle(fontWeight: FontWeight.bold, color: theme.colorScheme.primary),
                              ),
                              const SizedBox(width: 8),
                              Icon(Icons.calendar_today, size: 18, color: theme.colorScheme.onSurface.withAlpha(153)),
                            ],
                          ),
                        ],
                      ),
                    ),
                  ),

                  const SizedBox(height: 32),

                  // --- FINANCIALS ---
                  Text("FINANCIALS", style: sectionHeaderStyle),
                  const SizedBox(height: 12),

                  // Billing Frequency
                  Container(
                    decoration: inputDecoration,
                    padding: const EdgeInsets.all(4),
                    child: Row(
                      children: ['termly', 'monthly', 'yearly'].map((type) {
                        final isSelected = _billingType == type;
                        return Expanded(
                          child: GestureDetector(
                            onTap: () => setState(() => _billingType = type),
                            child: AnimatedContainer(
                              duration: const Duration(milliseconds: 200),
                              padding: const EdgeInsets.symmetric(vertical: 12),
                              decoration: BoxDecoration(
                                color: isSelected ? theme.colorScheme.primary : Colors.transparent,
                                borderRadius: BorderRadius.circular(8),
                              ),
                              alignment: Alignment.center,
                              child: Text(
                                type.toUpperCase(),
                                style: TextStyle(
                                  fontWeight: FontWeight.bold,
                                  fontSize: 12,
                                  color: isSelected ? theme.colorScheme.onPrimary : theme.colorScheme.onSurface.withAlpha(153),
                                ),
                              ),
                            ),
                          ),
                        );
                      }).toList(),
                    ),
                  ),
                  const SizedBox(height: 12),

                  Row(
                    children: [
                      // Fee Amount
                      Expanded(
                        flex: 4,
                        child: _buildInputContainer(
                          decoration: inputDecoration,
                          child: TextFormField(
                            controller: _feeController,
                            style: TextStyle(color: theme.colorScheme.onSurface),
                            keyboardType: const TextInputType.numberWithOptions(decimal: true),
                            decoration: _inputDecor(label: "Recurring Fee", prefix: "\$ "),
                            validator: (v) {
                              if (v != null && v.isNotEmpty && double.tryParse(v) == null) return 'Invalid';
                              return null;
                            },
                          ),
                        ),
                      ),
                      const SizedBox(width: 12),
                      
                      // Next Billing Date (Updateable)
                      Expanded(
                        flex: 5,
                        child: GestureDetector(
                          onTap: _pickBillingDate,
                          child: Container(
                            height: 60, // Match Text Field Height roughly
                            padding: const EdgeInsets.symmetric(horizontal: 16),
                            decoration: inputDecoration,
                            child: Column(
                              mainAxisAlignment: MainAxisAlignment.center,
                              crossAxisAlignment: CrossAxisAlignment.start,
                              children: [
                                Text("Next Bill Date", 
                                  style: TextStyle(fontSize: 11, color: Colors.grey)
                                ),
                                const SizedBox(height: 2),
                                Row(
                                  children: [
                                    Expanded(
                                      child: Text(
                                        DateFormat('MMM dd, yyyy').format(_nextBillingDate),
                                        style: TextStyle(
                                          fontWeight: FontWeight.bold, 
                                          color: theme.colorScheme.onSurface,
                                          fontSize: 13
                                        ),
                                        overflow: TextOverflow.ellipsis,
                                      ),
                                    ),
                                    Icon(Icons.event_repeat, size: 16, color: theme.colorScheme.primary),
                                  ],
                                ),
                              ],
                            ),
                          ),
                        ),
                      ),
                    ],
                  ),
                  
                  const SizedBox(height: 6),
                  Padding(
                    padding: const EdgeInsets.only(left: 4),
                    child: Text(
                      "* Restricted to days 1-28 to prevent cycle errors.",
                      style: TextStyle(fontSize: 11, color: theme.colorScheme.onSurface.withAlpha(128)),
                    ),
                  ),

                  const SizedBox(height: 32),

                  // --- STATUS ---
                  Text("SYSTEM STATUS", style: sectionHeaderStyle),
                  const SizedBox(height: 12),

                  Container(
                    decoration: inputDecoration,
                    child: SwitchListTile(
                      title: Text('Active Student', style: TextStyle(color: theme.colorScheme.onSurface, fontWeight: FontWeight.w500)),
                      subtitle: Text('Currently enrolled in classes', style: TextStyle(color: theme.colorScheme.onSurface.withAlpha(153), fontSize: 12)),
                      value: _isActive,
                      onChanged: (v) => setState(() => _isActive = v),
                      activeThumbColor: theme.colorScheme.primary,
                      contentPadding: const EdgeInsets.symmetric(horizontal: 16, vertical: 0),
                    ),
                  ),

                  const SizedBox(height: 40),

                  // SAVE BUTTON
                  SizedBox(
                    height: 56,
                    child: ElevatedButton(
                      onPressed: _isSaving ? null : _updateStudent,
                      style: ElevatedButton.styleFrom(
                        backgroundColor: theme.colorScheme.primary,
                        foregroundColor: theme.colorScheme.onPrimary,
                        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
                        elevation: 0,
                      ),
                      child: _isSaving 
                        ? SizedBox(width: 24, height: 24, child: CircularProgressIndicator(color: theme.colorScheme.onPrimary, strokeWidth: 2))
                        : const Text("SAVE CHANGES", style: TextStyle(fontSize: 16, fontWeight: FontWeight.bold, letterSpacing: 1.0)),
                    ),
                  ),
                  const SizedBox(height: 24),
                ],
              ),
            ),
          ),
        ),
      ),
    );
  }

  // --- UI Helpers ---
  Widget _buildInputContainer({required BoxDecoration decoration, required Widget child}) {
    return Container(decoration: decoration, child: child);
  }

  InputDecoration _inputDecor({required String label, String? hint, String? prefix, IconData? icon}) {
    return InputDecoration(
      labelText: label,
      hintText: hint,
      prefixText: prefix,
      suffixIcon: icon != null ? Icon(icon, color: Colors.grey) : null,
      border: InputBorder.none,
      contentPadding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
      labelStyle: const TextStyle(color: Colors.grey),
      hintStyle: TextStyle(color: Colors.grey.withAlpha(128)),
    );
  }
}// lib/pages/classes_view.dart

import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:flutter_riverpod/legacy.dart';
import 'package:sqflite/sqflite.dart';
import '../services/database_service.dart';

// -----------------------------------------------------------------------------
// MODELS
// -----------------------------------------------------------------------------
class ClassSummary {
  final String id;
  final String name;
  final String? grade;
  final int studentCount;
  final String roomNumber;
  final String teacherName;
  final String? teacherId;

  ClassSummary({
    required this.id,
    required this.name,
    this.grade,
    required this.studentCount,
    this.roomNumber = 'TBA',
    this.teacherName = 'No Teacher',
    this.teacherId,
  });
}

class TeacherSimple {
  final String id;
  final String name;
  TeacherSimple({required this.id, required this.name});
}

class StudentSimple {
  final String id;
  final String name;
  final String? grade;
  StudentSimple({required this.id, required this.name, this.grade});
}

// -----------------------------------------------------------------------------
// PROVIDERS
// -----------------------------------------------------------------------------

final teachersProvider = FutureProvider.autoDispose<List<TeacherSimple>>((
  ref,
) async {
  final db = DatabaseService.instance;
  final data = await db.getAllTeachers();
  return data
      .map(
        (e) => TeacherSimple(
          id: e['id'] as String,
          name: e['full_name'] as String,
        ),
      )
      .toList();
});

final classListProvider = FutureProvider.autoDispose<List<ClassSummary>>((
  ref,
) async {
  final db = DatabaseService.instance;
  final classesData = await db.getAllClasses();
  final List<ClassSummary> result = [];

  for (final row in classesData) {
    final classId = row['id'] as String;
    final countRows = await db.rawQuery(
      'SELECT COUNT(*) as c FROM enrollments WHERE class_id = ?',
      [classId],
    );
    final count = Sqflite.firstIntValue(countRows) ?? 0;

    result.add(
      ClassSummary(
        id: classId,
        name: row['name'] as String,
        grade: row['grade'] as String?,
        studentCount: count,
        roomNumber: (row['room_number'] as String?) ?? 'TBA',
        teacherName: (row['teacher_name'] as String?) ?? 'Unassigned',
        teacherId: row['teacher_id'] as String?,
      ),
    );
  }
  result.sort((a, b) => a.name.compareTo(b.name));
  return result;
});

final studentSearchProvider = FutureProvider.autoDispose
    .family<List<StudentSimple>, String>((ref, query) async {
      final db = DatabaseService.instance;
      final sanitizedQuery = '%${query.toLowerCase()}%';
      final rows = await db.rawQuery(
        '''SELECT id, full_name, grade FROM students 
       WHERE lower(full_name) LIKE ? AND is_active = 1 
       LIMIT 20''',
        [sanitizedQuery],
      );
      return rows
          .map(
            (r) => StudentSimple(
              id: r['id'] as String,
              name: r['full_name'] as String,
              grade: r['grade'] as String?,
            ),
          )
          .toList();
    });

final classSearchProvider = StateProvider.autoDispose<String>((ref) => '');

// -----------------------------------------------------------------------------
// CONSTANTS
// -----------------------------------------------------------------------------
const List<String> kAllGrades = [
  'ECD A',
  'ECD B',
  'Grade 1',
  'Grade 2',
  'Grade 3',
  'Grade 4',
  'Grade 5',
  'Grade 6',
  'Grade 7',
  'Form 1',
  'Form 2',
  'Form 3',
  'Form 4',
  'Lower 6',
  'Upper 6',
];

// -----------------------------------------------------------------------------
// UI: CLASSES VIEW (LIST)
// -----------------------------------------------------------------------------
class ClassesView extends ConsumerWidget {
  const ClassesView({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final colorScheme = Theme.of(context).colorScheme;
    final classesAsync = ref.watch(classListProvider);
    final searchQuery = ref.watch(classSearchProvider).toLowerCase();

    return Scaffold(
      backgroundColor: colorScheme.surface,
      body: CustomScrollView(
        slivers: [
          SliverAppBar(
            pinned: true,
            expandedHeight: 110.0,
            backgroundColor: colorScheme.surface,
            surfaceTintColor: Colors.transparent,
            leading: Padding(
              padding: const EdgeInsets.all(8.0),
              child: CircleAvatar(
                backgroundColor: colorScheme.surfaceContainerHighest,
                child: Icon(Icons.class_, color: colorScheme.primary),
              ),
            ),
            title: Text(
              'Manage Classes',
              style: TextStyle(
                fontWeight: FontWeight.bold,
                color: colorScheme.onSurface,
              ),
            ),
            actions: [
              Padding(
                padding: const EdgeInsets.only(right: 16.0),
                child: IconButton.filled(
                  icon: const Icon(Icons.add),
                  onPressed: () => _showAddClassModal(context, ref),
                  style: IconButton.styleFrom(
                    backgroundColor: colorScheme.primary,
                    foregroundColor: colorScheme.onPrimary,
                  ),
                ),
              ),
            ],
            bottom: PreferredSize(
              preferredSize: const Size.fromHeight(60),
              child: Padding(
                padding: const EdgeInsets.fromLTRB(16, 0, 16, 12),
                child: SearchBar(
                  hintText: 'Search class...',
                  hintStyle: WidgetStateProperty.all(
                    TextStyle(color: colorScheme.onSurfaceVariant),
                  ),
                  textStyle: WidgetStateProperty.all(
                    TextStyle(color: colorScheme.onSurface),
                  ),
                  leading: Icon(
                    Icons.search,
                    color: colorScheme.onSurfaceVariant,
                  ),
                  elevation: WidgetStateProperty.all(0),
                  backgroundColor: WidgetStateProperty.all(
                    colorScheme.surfaceContainerHighest,
                  ),
                  onChanged: (val) =>
                      ref.read(classSearchProvider.notifier).state = val,
                  shape: WidgetStateProperty.all(
                    RoundedRectangleBorder(
                      borderRadius: BorderRadius.circular(12),
                      side: BorderSide.none,
                    ),
                  ),
                ),
              ),
            ),
          ),
          classesAsync.when(
            loading: () => const SliverFillRemaining(
              child: Center(child: CircularProgressIndicator()),
            ),
            error: (e, s) =>
                SliverFillRemaining(child: Center(child: Text('Error: $e'))),
            data: (allClasses) {
              final filtered = allClasses
                  .where((c) => c.name.toLowerCase().contains(searchQuery))
                  .toList();

              if (allClasses.isEmpty) {
                return SliverFillRemaining(
                  child: _EmptyState(
                    onAction: () => _showAddClassModal(context, ref),
                  ),
                );
              }

              return SliverList(
                delegate: SliverChildBuilderDelegate(
                  (context, index) => _ClassCard(
                    classInfo: filtered[index],
                    onTap: () =>
                        _navigateToUpdate(context, ref, filtered[index]),
                  ),
                  childCount: filtered.length,
                ),
              );
            },
          ),
          const SliverToBoxAdapter(child: SizedBox(height: 80)),
        ],
      ),
    );
  }

  void _showAddClassModal(BuildContext context, WidgetRef ref) {
    showModalBottomSheet(
      context: context,
      isScrollControlled: true,
      backgroundColor: Colors.transparent,
      builder: (ctx) => _AddClassSheet(ref: ref),
    );
  }

  void _navigateToUpdate(
    BuildContext context,
    WidgetRef ref,
    ClassSummary summary,
  ) {
    Navigator.of(context)
        .push(
          MaterialPageRoute(
            builder: (_) => UpdateClassPage(classSummary: summary),
          ),
        )
        .then((_) => ref.invalidate(classListProvider));
  }
}

// -----------------------------------------------------------------------------
// COMPONENT: Shared Form Content (Styled like RegisterStudentPage)
// -----------------------------------------------------------------------------
class _ClassFormContent extends StatefulWidget {
  final TextEditingController nameCtrl;
  final TextEditingController roomCtrl;
  final TextEditingController? capacityCtrl;
  final TextEditingController? notesCtrl;
  final String? selectedGrade;
  final String? selectedTeacherId;
  final List<StudentSimple> selectedStudents;
  final ValueChanged<String?> onGradeChanged;
  final ValueChanged<String?> onTeacherChanged;
  final VoidCallback onAddStudent;
  final ValueChanged<String> onRemoveStudent;

  const _ClassFormContent({
    required this.nameCtrl,
    required this.roomCtrl,
    this.capacityCtrl,
    this.notesCtrl,
    required this.selectedGrade,
    required this.selectedTeacherId,
    required this.selectedStudents,
    required this.onGradeChanged,
    required this.onTeacherChanged,
    required this.onAddStudent,
    required this.onRemoveStudent,
  });

  @override
  State<_ClassFormContent> createState() => _ClassFormContentState();
}

class _ClassFormContentState extends State<_ClassFormContent> {
  Future<void> _quickCreateTeacher(WidgetRef ref) async {
    final nameCtrl = TextEditingController();
    final createdId = await showDialog<String>(
      context: context,
      builder: (ctx) => AlertDialog(
        backgroundColor: Theme.of(ctx).colorScheme.surface,
        title: const Text("Add New Teacher"),
        content: TextField(
          controller: nameCtrl,
          autofocus: true,
          decoration: const InputDecoration(
            labelText: "Full Name",
            hintText: "e.g. Mr. Chidume",
          ),
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(ctx),
            child: const Text("Cancel"),
          ),
          TextButton(
            onPressed: () async {
              if (nameCtrl.text.isNotEmpty) {
                final id = await DatabaseService.instance.createTeacher({
                  'full_name': nameCtrl.text.trim(),
                });
                if (ctx.mounted) Navigator.pop(ctx, id);
              }
            },
            child: const Text("Save"),
          ),
        ],
      ),
    );
    if (createdId != null) {
      ref.invalidate(teachersProvider);
      widget.onTeacherChanged(createdId);
    }
  }

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;

    // -- UNIFORM STYLE DECORATION (Same as RegisterStudentPage) --
    final standardBoxDecoration = BoxDecoration(
      color: theme.colorScheme.surface,
      borderRadius: BorderRadius.circular(12.0),
      border: Border.all(color: theme.colorScheme.outlineVariant, width: 1.0),
    );

    return Consumer(
      builder: (context, ref, _) {
        final teachersAsync = ref.watch(teachersProvider);

        return Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            const _SectionHeader(title: "CLASS DETAILS"),

            _buildTextField(
              controller: widget.nameCtrl,
              label: "Class Name",
              hint: "e.g. Form 4 East",
              decoration: standardBoxDecoration,
              icon: Icons.menu_book_outlined,
            ),
            const SizedBox(height: 12),

            Container(
              padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 4),
              decoration: standardBoxDecoration,
              child: DropdownButtonHideUnderline(
                child: DropdownButton<String>(
                  value: widget.selectedGrade,
                  isExpanded: true,
                  hint: Text(
                    "Select Grade Level",
                    style: TextStyle(color: colorScheme.onSurfaceVariant),
                  ),
                  items: kAllGrades
                      .map((g) => DropdownMenuItem(value: g, child: Text(g)))
                      .toList(),
                  onChanged: widget.onGradeChanged,
                ),
              ),
            ),
            const SizedBox(height: 24),

            const _SectionHeader(title: "ACADEMIC STAFF"),

            teachersAsync.when(
              loading: () => const LinearProgressIndicator(minHeight: 2),
              error: (_, __) => const Text(
                "Error loading teachers",
                style: TextStyle(color: Colors.red),
              ),
              data: (teachers) {
                if (teachers.isEmpty) {
                  return InkWell(
                    onTap: () => _quickCreateTeacher(ref),
                    borderRadius: BorderRadius.circular(12),
                    child: Container(
                      padding: const EdgeInsets.all(16),
                      decoration: standardBoxDecoration,
                      child: Row(
                        mainAxisAlignment: MainAxisAlignment.center,
                        children: [
                          Icon(Icons.add, color: colorScheme.primary),
                          const SizedBox(width: 8),
                          Text(
                            "Add First Teacher",
                            style: TextStyle(
                              color: colorScheme.primary,
                              fontWeight: FontWeight.bold,
                            ),
                          ),
                        ],
                      ),
                    ),
                  );
                }

                return Row(
                  children: [
                    Expanded(
                      child: Container(
                        padding: const EdgeInsets.symmetric(
                          horizontal: 16,
                          vertical: 4,
                        ),
                        decoration: standardBoxDecoration,
                        child: DropdownButtonHideUnderline(
                          child: DropdownButton<String>(
                            value: widget.selectedTeacherId,
                            isExpanded: true,
                            hint: Text(
                              "Select Teacher",
                              style: TextStyle(
                                color: colorScheme.onSurfaceVariant,
                              ),
                            ),
                            items: teachers
                                .map(
                                  (t) => DropdownMenuItem(
                                    value: t.id,
                                    child: Text(t.name),
                                  ),
                                )
                                .toList(),
                            onChanged: widget.onTeacherChanged,
                          ),
                        ),
                      ),
                    ),
                    const SizedBox(width: 8),
                    Container(
                      decoration: BoxDecoration(
                        color: colorScheme.primaryContainer,
                        borderRadius: BorderRadius.circular(12),
                      ),
                      child: IconButton(
                        onPressed: () => _quickCreateTeacher(ref),
                        icon: Icon(
                          Icons.add,
                          color: colorScheme.onPrimaryContainer,
                        ),
                        tooltip: "Quick Add Teacher",
                      ),
                    ),
                  ],
                );
              },
            ),

            const SizedBox(height: 12),

            Row(
              children: [
                Expanded(
                  child: _buildTextField(
                    controller: widget.roomCtrl,
                    label: "Room No.",
                    hint: "e.g. 302",
                    decoration: standardBoxDecoration,
                    icon: Icons.meeting_room_outlined,
                  ),
                ),
                if (widget.capacityCtrl != null) ...[
                  const SizedBox(width: 12),
                  Expanded(
                    child: _buildTextField(
                      controller: widget.capacityCtrl!,
                      label: "Capacity",
                      hint: "30",
                      decoration: standardBoxDecoration,
                      isNumber: true,
                    ),
                  ),
                ],
              ],
            ),

            const SizedBox(height: 24),

            Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                const _SectionHeader(title: "STUDENTS"),
                Text(
                  "${widget.selectedStudents.length} Assigned",
                  style: TextStyle(
                    fontSize: 12,
                    color: colorScheme.onSurfaceVariant,
                  ),
                ),
              ],
            ),

            // Student Search Button (Styled like Input)
            GestureDetector(
              onTap: widget.onAddStudent,
              child: Container(
                padding: const EdgeInsets.symmetric(
                  horizontal: 16,
                  vertical: 12,
                ),
                decoration: standardBoxDecoration,
                child: Row(
                  children: [
                    Icon(
                      Icons.person_search,
                      color: colorScheme.onSurfaceVariant,
                    ),
                    const SizedBox(width: 12),
                    Text(
                      "Search to enroll student...",
                      style: TextStyle(
                        color: colorScheme.onSurfaceVariant,
                        fontSize: 16,
                      ),
                    ),
                    const Spacer(),
                    Icon(Icons.add_circle_outline, color: colorScheme.primary),
                  ],
                ),
              ),
            ),

            const SizedBox(height: 12),

            if (widget.selectedStudents.isNotEmpty)
              Wrap(
                spacing: 8,
                runSpacing: 8,
                children: widget.selectedStudents
                    .map((s) => _buildStudentChip(context, s))
                    .toList(),
              ),

            if (widget.notesCtrl != null) ...[
              const SizedBox(height: 24),
              const _SectionHeader(title: "NOTES"),
              Container(
                decoration: standardBoxDecoration,
                child: TextField(
                  controller: widget.notesCtrl,
                  maxLines: 3,
                  decoration: const InputDecoration(
                    hintText: "Special requirements...",
                    border: InputBorder.none,
                    contentPadding: EdgeInsets.all(16),
                  ),
                ),
              ),
            ],
          ],
        );
      },
    );
  }

  // --- Helper Methods (Matching RegisterStudentPage) ---

  Widget _buildTextField({
    required TextEditingController controller,
    required String label,
    required BoxDecoration decoration,
    String? hint,
    IconData? icon,
    bool isNumber = false,
  }) {
    return Container(
      decoration: decoration,
      child: TextField(
        controller: controller,
        keyboardType: isNumber ? TextInputType.number : TextInputType.text,
        decoration: InputDecoration(
          labelText: label,
          hintText: hint,
          suffixIcon: icon != null
              ? Icon(icon, color: Colors.grey, size: 20)
              : null,
          border: InputBorder.none,
          contentPadding: const EdgeInsets.symmetric(
            horizontal: 16,
            vertical: 12,
          ),
        ),
      ),
    );
  }

  Widget _buildStudentChip(BuildContext context, StudentSimple student) {
    final theme = Theme.of(context);
    final initials = student.name.isNotEmpty
        ? student.name[0].toUpperCase()
        : "?";

    return Chip(
      avatar: CircleAvatar(
        backgroundColor: theme.colorScheme.primary,
        child: Text(
          initials,
          style: TextStyle(fontSize: 10, color: theme.colorScheme.onPrimary),
        ),
      ),
      label: Text(student.name, style: const TextStyle(fontSize: 12)),
      backgroundColor: theme.colorScheme.surfaceContainerHighest,
      deleteIcon: const Icon(Icons.close, size: 16),
      onDeleted: () => widget.onRemoveStudent(student.id),
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(20),
        side: BorderSide.none,
      ),
    );
  }
}

// -----------------------------------------------------------------------------
// PAGE: Update Class (Refactored Layout)
// -----------------------------------------------------------------------------
class UpdateClassPage extends ConsumerStatefulWidget {
  final ClassSummary classSummary;
  const UpdateClassPage({super.key, required this.classSummary});

  @override
  ConsumerState<UpdateClassPage> createState() => _UpdateClassPageState();
}

class _UpdateClassPageState extends ConsumerState<UpdateClassPage> {
  late TextEditingController _nameCtrl;
  late TextEditingController _roomCtrl;
  String? _selectedGrade;
  String? _selectedTeacherId;
  final List<StudentSimple> _selectedStudents = [];
  bool _isSaving = false;

  @override
  void initState() {
    super.initState();
    _nameCtrl = TextEditingController(text: widget.classSummary.name);
    _roomCtrl = TextEditingController(text: widget.classSummary.roomNumber);
    _selectedGrade = widget.classSummary.grade;
    _selectedTeacherId = widget.classSummary.teacherId;
    if (_selectedGrade != null && !kAllGrades.contains(_selectedGrade)) {
      _selectedGrade = null;
    }
  }

  void _showStudentSearchDialog() {
    showDialog(
      context: context,
      builder: (context) => _StudentSearchDialog(
        onSelect: (student) {
          if (!_selectedStudents.any((s) => s.id == student.id)) {
            setState(() => _selectedStudents.add(student));
          }
        },
      ),
    );
  }

  Future<void> _save() async {
    if (_nameCtrl.text.isEmpty) return;
    setState(() => _isSaving = true);
    final db = DatabaseService.instance;
    try {
      final existing = await db.query(
        'classes',
        where: 'name = ? AND id != ?',
        whereArgs: [_nameCtrl.text.trim(), widget.classSummary.id],
      );
      if (existing.isNotEmpty) {
        if (mounted) {
          ScaffoldMessenger.of(
            context,
          ).showSnackBar(const SnackBar(content: Text("Class name exists!")));
        }
        setState(() => _isSaving = false);
        return;
      }

      await db.update(
        'classes',
        {
          'name': _nameCtrl.text.trim(),
          'room_number': _roomCtrl.text.trim(),
          'grade': _selectedGrade,
          'teacher_id': _selectedTeacherId,
        },
        'id = ?',
        [widget.classSummary.id],
        queueForSync: true,
      );

      for (var s in _selectedStudents) {
        await db.enrollStudentInClass(
          studentId: s.id,
          classId: widget.classSummary.id,
        );
      }
      if (mounted) Navigator.pop(context);
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(
          context,
        ).showSnackBar(SnackBar(content: Text("Error: $e")));
      }
    } finally {
      if (mounted) setState(() => _isSaving = false);
    }
  }

  Future<void> _deleteClass() async {
    final confirm = await showDialog<bool>(
      context: context,
      builder: (ctx) => AlertDialog(
        title: const Text("Delete Class?"),
        content: const Text("This will unenroll all students."),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(ctx, false),
            child: const Text("Cancel"),
          ),
          TextButton(
            onPressed: () => Navigator.pop(ctx, true),
            child: const Text("Delete", style: TextStyle(color: Colors.red)),
          ),
        ],
      ),
    );
    if (confirm == true) {
      await DatabaseService.instance.delete('classes', 'id = ?', [
        widget.classSummary.id,
      ], queueForSync: true);
      if (mounted) Navigator.pop(context);
    }
  }

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    return Scaffold(
      backgroundColor: theme.colorScheme.surface,
      appBar: AppBar(
        title: const Text("Edit Class"),
        centerTitle: true,
        actions: [
          IconButton(
            onPressed: _deleteClass,
            icon: Icon(Icons.delete_outline, color: theme.colorScheme.error),
          ),
        ],
      ),
      body: Center(
        child: ConstrainedBox(
          constraints: const BoxConstraints(maxWidth: 600),
          child: SingleChildScrollView(
            padding: const EdgeInsets.all(20),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.stretch,
              children: [
                _ClassFormContent(
                  nameCtrl: _nameCtrl,
                  roomCtrl: _roomCtrl,
                  selectedGrade: _selectedGrade,
                  selectedTeacherId: _selectedTeacherId,
                  selectedStudents: _selectedStudents,
                  onGradeChanged: (v) => setState(() => _selectedGrade = v),
                  onTeacherChanged: (v) =>
                      setState(() => _selectedTeacherId = v),
                  onAddStudent: _showStudentSearchDialog,
                  onRemoveStudent: (id) => setState(
                    () => _selectedStudents.removeWhere((s) => s.id == id),
                  ),
                ),
                const SizedBox(height: 32),
                SizedBox(
                  height: 56,
                  child: ElevatedButton(
                    onPressed: _isSaving ? null : _save,
                    style: ElevatedButton.styleFrom(
                      backgroundColor: theme.colorScheme.primary,
                      foregroundColor: theme.colorScheme.onPrimary,
                      shape: RoundedRectangleBorder(
                        borderRadius: BorderRadius.circular(12),
                      ),
                    ),
                    child: _isSaving
                        ? SizedBox(
                            width: 24,
                            height: 24,
                            child: CircularProgressIndicator(
                              color: theme.colorScheme.onPrimary,
                            ),
                          )
                        : const Text(
                            "SAVE CHANGES",
                            style: TextStyle(
                              fontWeight: FontWeight.bold,
                              fontSize: 16,
                            ),
                          ),
                  ),
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }
}

// -----------------------------------------------------------------------------
// WIDGET: Add Class Sheet (Updated Layout)
// -----------------------------------------------------------------------------
class _AddClassSheet extends StatefulWidget {
  final WidgetRef ref;
  const _AddClassSheet({required this.ref});

  @override
  State<_AddClassSheet> createState() => _AddClassSheetState();
}

class _AddClassSheetState extends State<_AddClassSheet> {
  final _nameCtrl = TextEditingController();
  final _roomCtrl = TextEditingController();
  final _capacityCtrl = TextEditingController();
  final _notesCtrl = TextEditingController();

  String? _selectedGrade;
  String? _selectedTeacherId;
  final List<StudentSimple> _selectedStudents = [];
  bool _isSaving = false;

  void _showStudentSearchDialog() {
    showDialog(
      context: context,
      builder: (context) => _StudentSearchDialog(
        onSelect: (student) {
          if (!_selectedStudents.any((s) => s.id == student.id)) {
            setState(() => _selectedStudents.add(student));
          }
        },
      ),
    );
  }

  Future<void> _save() async {
    if (_nameCtrl.text.isEmpty) return;
    setState(() => _isSaving = true);
    final db = DatabaseService.instance;
    try {
      final existing = await db.query(
        'classes',
        where: 'name = ?',
        whereArgs: [_nameCtrl.text.trim()],
      );
      if (existing.isNotEmpty) {
        if (mounted) {
          ScaffoldMessenger.of(
            context,
          ).showSnackBar(const SnackBar(content: Text("Class name exists!")));
        }
        setState(() => _isSaving = false);
        return;
      }
      final classId = await db.createClass({
        'name': _nameCtrl.text.trim(),
        'room_number': _roomCtrl.text.trim(),
        'teacher_id': _selectedTeacherId,
        'grade': _selectedGrade,
      }, queueForSync: true);

      for (var s in _selectedStudents) {
        await db.enrollStudentInClass(studentId: s.id, classId: classId);
      }
      if (mounted) {
        Navigator.pop(context);
        widget.ref.invalidate(classListProvider);
      }
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(
          context,
        ).showSnackBar(SnackBar(content: Text("Error: $e")));
      }
    } finally {
      if (mounted) setState(() => _isSaving = false);
    }
  }

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    return Container(
      padding: EdgeInsets.only(
        bottom: MediaQuery.of(context).viewInsets.bottom + 20,
        left: 20,
        right: 20,
        top: 20,
      ),
      decoration: BoxDecoration(
        color: theme.colorScheme.surface,
        borderRadius: const BorderRadius.vertical(top: Radius.circular(20)),
      ),
      child: SingleChildScrollView(
        child: Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.stretch,
          children: [
            Row(
              children: [
                IconButton(
                  icon: const Icon(Icons.arrow_back),
                  onPressed: () => Navigator.pop(context),
                ),
                const SizedBox(width: 8),
                Text(
                  "Add New Class",
                  style: TextStyle(
                    fontSize: 20,
                    fontWeight: FontWeight.bold,
                    color: theme.colorScheme.onSurface,
                  ),
                ),
              ],
            ),
            const SizedBox(height: 20),
            _ClassFormContent(
              nameCtrl: _nameCtrl,
              roomCtrl: _roomCtrl,
              capacityCtrl: _capacityCtrl,
              notesCtrl: _notesCtrl,
              selectedGrade: _selectedGrade,
              selectedTeacherId: _selectedTeacherId,
              selectedStudents: _selectedStudents,
              onGradeChanged: (v) => setState(() => _selectedGrade = v),
              onTeacherChanged: (v) => setState(() => _selectedTeacherId = v),
              onAddStudent: _showStudentSearchDialog,
              onRemoveStudent: (id) => setState(
                () => _selectedStudents.removeWhere((s) => s.id == id),
              ),
            ),
            const SizedBox(height: 30),
            SizedBox(
              height: 50,
              child: ElevatedButton(
                onPressed: _isSaving ? null : _save,
                style: ElevatedButton.styleFrom(
                  backgroundColor: theme.colorScheme.primary,
                  foregroundColor: theme.colorScheme.onPrimary,
                  shape: RoundedRectangleBorder(
                    borderRadius: BorderRadius.circular(12),
                  ),
                ),
                child: _isSaving
                    ? const CircularProgressIndicator()
                    : const Text(
                        "Save Class",
                        style: TextStyle(fontWeight: FontWeight.bold),
                      ),
              ),
            ),
          ],
        ),
      ),
    );
  }
}

// -----------------------------------------------------------------------------
// WIDGET: Helpers
// -----------------------------------------------------------------------------
class _SectionHeader extends StatelessWidget {
  final String title;
  const _SectionHeader({required this.title});
  @override
  Widget build(BuildContext context) {
    return Padding(
      padding: const EdgeInsets.only(bottom: 8.0, left: 4),
      child: Text(
        title,
        style: TextStyle(
          color: Theme.of(context).colorScheme.primary,
          fontWeight: FontWeight.bold,
          letterSpacing: 1.2,
          fontSize: 12,
        ),
      ),
    );
  }
}

class _StudentSearchDialog extends ConsumerStatefulWidget {
  final Function(StudentSimple) onSelect;
  const _StudentSearchDialog({required this.onSelect});
  @override
  ConsumerState<_StudentSearchDialog> createState() =>
      _StudentSearchDialogState();
}

class _StudentSearchDialogState extends ConsumerState<_StudentSearchDialog> {
  String _query = '';
  @override
  Widget build(BuildContext context) {
    final searchAsync = ref.watch(studentSearchProvider(_query));
    final theme = Theme.of(context);
    return Dialog(
      backgroundColor: theme.colorScheme.surface,
      surfaceTintColor: Colors.transparent,
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
      child: Container(
        padding: const EdgeInsets.all(16),
        constraints: const BoxConstraints(maxHeight: 500),
        child: Column(
          children: [
            TextField(
              autofocus: true,
              decoration: InputDecoration(
                hintText: "Search student...",
                prefixIcon: const Icon(Icons.search),
                border: OutlineInputBorder(
                  borderRadius: BorderRadius.circular(12),
                ),
                contentPadding: const EdgeInsets.symmetric(vertical: 12),
              ),
              onChanged: (val) => setState(() => _query = val),
            ),
            const SizedBox(height: 12),
            Expanded(
              child: searchAsync.when(
                loading: () => const Center(child: CircularProgressIndicator()),
                error: (e, s) => const Center(child: Text("Error searching")),
                data: (students) {
                  if (students.isEmpty) {
                    return const Center(child: Text("No students found"));
                  }
                  return ListView.separated(
                    itemCount: students.length,
                    separatorBuilder: (_, __) => Divider(
                      height: 1,
                      color: theme.colorScheme.outlineVariant.withAlpha(50),
                    ),
                    itemBuilder: (ctx, i) {
                      final s = students[i];
                      return ListTile(
                        leading: CircleAvatar(child: Text(s.name[0])),
                        title: Text(
                          s.name,
                          style: const TextStyle(fontWeight: FontWeight.bold),
                        ),
                        subtitle: Text(s.grade ?? 'No grade'),
                        onTap: () {
                          widget.onSelect(s);
                          Navigator.pop(context);
                        },
                      );
                    },
                  );
                },
              ),
            ),
          ],
        ),
      ),
    );
  }
}

class _ClassCard extends StatelessWidget {
  final ClassSummary classInfo;
  final VoidCallback onTap;
  const _ClassCard({required this.classInfo, required this.onTap});

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;
    final visual = _getGradeVisuals(classInfo.grade);

    return Container(
      margin: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
      decoration: BoxDecoration(
        color: colorScheme.surfaceContainerLow,
        borderRadius: BorderRadius.circular(16),
        border: Border.all(color: colorScheme.outlineVariant.withAlpha(50)),
      ),
      child: Material(
        color: Colors.transparent,
        child: InkWell(
          onTap: onTap,
          borderRadius: BorderRadius.circular(16),
          child: Padding(
            padding: const EdgeInsets.all(16),
            child: Row(
              children: [
                Container(
                  width: 56,
                  height: 56,
                  decoration: BoxDecoration(
                    color: visual.color.withAlpha(30),
                    borderRadius: BorderRadius.circular(12),
                  ),
                  child: Center(
                    child: Text(
                      _getGradeShort(classInfo.grade),
                      style: TextStyle(
                        fontWeight: FontWeight.w900,
                        color: visual.color,
                        fontSize: 18,
                      ),
                    ),
                  ),
                ),
                const SizedBox(width: 16),
                Expanded(
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Text(
                        classInfo.name,
                        style: TextStyle(
                          fontSize: 16,
                          fontWeight: FontWeight.bold,
                          color: colorScheme.onSurface,
                        ),
                        maxLines: 1,
                        overflow: TextOverflow.ellipsis,
                      ),
                      const SizedBox(height: 4),
                      Row(
                        children: [
                          Icon(
                            Icons.meeting_room_outlined,
                            size: 14,
                            color: colorScheme.onSurfaceVariant,
                          ),
                          const SizedBox(width: 4),
                          Text(
                            classInfo.roomNumber,
                            style: TextStyle(
                              fontSize: 12,
                              color: colorScheme.onSurfaceVariant,
                            ),
                          ),
                          const SizedBox(width: 8),
                          Expanded(
                            child: Text(
                              classInfo.teacherName,
                              style: TextStyle(
                                fontSize: 12,
                                color: colorScheme.onSurfaceVariant,
                              ),
                              maxLines: 1,
                              overflow: TextOverflow.ellipsis,
                            ),
                          ),
                        ],
                      ),
                    ],
                  ),
                ),
                Container(
                  padding: const EdgeInsets.symmetric(
                    horizontal: 10,
                    vertical: 4,
                  ),
                  decoration: BoxDecoration(
                    color: colorScheme.primary.withAlpha(30),
                    borderRadius: BorderRadius.circular(20),
                  ),
                  child: Row(
                    children: [
                      Icon(Icons.people, size: 14, color: colorScheme.primary),
                      const SizedBox(width: 4),
                      Text(
                        '${classInfo.studentCount}',
                        style: TextStyle(
                          fontSize: 12,
                          fontWeight: FontWeight.bold,
                          color: colorScheme.primary,
                        ),
                      ),
                    ],
                  ),
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }
}

class _EmptyState extends StatelessWidget {
  final VoidCallback onAction;
  const _EmptyState({required this.onAction});
  @override
  Widget build(BuildContext context) {
    return Center(
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          Icon(
            Icons.class_outlined,
            size: 64,
            color: Theme.of(context).colorScheme.outlineVariant,
          ),
          const SizedBox(height: 16),
          const Text(
            "No Classes Yet",
            style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold),
          ),
          const SizedBox(height: 24),
          ElevatedButton(
            onPressed: onAction,
            child: const Text("Create Class"),
          ),
        ],
      ),
    );
  }
}

class _GradeVisual {
  final Color color;
  _GradeVisual(this.color);
}

String _getGradeShort(String? grade) {
  if (grade == null) return "?";
  if (grade.toLowerCase().contains("form")) return grade.split(" ").last;
  if (grade.toLowerCase().contains("grade")) return "G${grade.split(" ").last}";
  if (grade.toLowerCase().contains("ecd")) return "E${grade.split(" ").last}";
  if (grade.toLowerCase().contains("lower")) return "L6";
  if (grade.toLowerCase().contains("upper")) return "U6";
  return grade[0].toUpperCase();
}

_GradeVisual _getGradeVisuals(String? gradeName) {
  final lower = (gradeName ?? "").toLowerCase();
  if (lower.contains('ecd')) return _GradeVisual(Colors.teal);
  if (lower.contains('grade 1') || lower.contains('grade 2')) {
    return _GradeVisual(Colors.orange);
  }
  if (lower.contains('grade 3') || lower.contains('grade 4')) {
    return _GradeVisual(Colors.yellow);
  }
  if (lower.contains('grade 5') ||
      lower.contains('grade 6') ||
      lower.contains('grade 7')) {
    return _GradeVisual(Colors.pink);
  }
  if (lower.contains('form 1')) return _GradeVisual(Colors.blue);
  if (lower.contains('form 2')) return _GradeVisual(Colors.indigo);
  if (lower.contains('form 3')) return _GradeVisual(Colors.purple);
  if (lower.contains('form 4')) return _GradeVisual(Colors.deepPurple);
  if (lower.contains('lower 6')) return _GradeVisual(Colors.cyan);
  if (lower.contains('upper 6')) return _GradeVisual(Colors.red);
  return _GradeVisual(Colors.grey);
}
// lib/pages/auth_page.dart

import 'package:flutter/material.dart';
// Note: flutter_riverpod is needed if you use ref.read() for the AuthController
// import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:supabase_flutter/supabase_flutter.dart';

// Assuming you have a separate file for this service:
// import '../services/auth_service.dart'; // Your helper service

enum AuthView { signIn, signUp }

// Change to ConsumerStatefulWidget if you intend to use Riverpod ref in the build method
class AuthPage extends StatefulWidget {
  const AuthPage({super.key});

  static const String routeName = '/auth';

  @override
  State<AuthPage> createState() => _AuthPageState();
}

// Assuming AuthService is accessible (either imported or passed via provider)
// For demonstration, we assume AuthService is available as in the previous code.
class AuthService {
  final SupabaseClient supabase = Supabase.instance.client;
  Future<void> signIn({required String email, required String password}) async {
    // Placeholder for actual sign in logic
    await Future.delayed(const Duration(milliseconds: 500));
    // throw AuthException(message: 'Invalid credentials placeholder');
  }

  Future<void> signUp({
    required String email,
    required String password,
    String? fullName,
  }) async {
    // Placeholder for actual sign up logic
    await Future.delayed(const Duration(milliseconds: 500));
  }
}

class _AuthPageState extends State<AuthPage> {
  // Replace with ref.read(authServiceProvider) if using Riverpod
  final AuthService _authService = AuthService();

  AuthView _currentView = AuthView.signIn;

  final _formKey = GlobalKey<FormState>();
  final _emailController = TextEditingController();
  final _passwordController = TextEditingController();
  final _confirmPasswordController = TextEditingController();
  final _fullNameController = TextEditingController();

  bool _isLoading = false;

  void _toggleView() {
    setState(() {
      _currentView = _currentView == AuthView.signIn
          ? AuthView.signUp
          : AuthView.signIn;
      _formKey.currentState?.reset(); // Clear form fields
    });
  }

  Future<void> _handleAuth() async {
    if (!_formKey.currentState!.validate()) return;
    setState(() => _isLoading = true);

    try {
      if (_currentView == AuthView.signIn) {
        await _authService.signIn(
          email: _emailController.text,
          password: _passwordController.text,
        );
      } else {
        await _authService.signUp(
          email: _emailController.text,
          password: _passwordController.text,
          // Passing full name for saving in user metadata later
          fullName: _fullNameController.text.isNotEmpty
              ? _fullNameController.text
              : null,
        );
      }
      // On success, state listener in main.dart handles navigation
    } on AuthException catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(
          context,
        ).showSnackBar(SnackBar(content: Text(e.message)));
      }
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('An unexpected error occurred: $e')),
        );
      }
    }

    if (mounted) setState(() => _isLoading = false);
  }

  @override
  void dispose() {
    _emailController.dispose();
    _passwordController.dispose();
    _confirmPasswordController.dispose();
    _fullNameController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    bool isSignIn = _currentView == AuthView.signIn;

    return Scaffold(
      appBar: AppBar(
        // Back button on Login (optional)
        leading: isSignIn ? const BackButton() : null,
        title: const Text('Admin Portal'),
      ),
      body: Center(
        child: SingleChildScrollView(
          padding: const EdgeInsets.all(24.0),
          child: Form(
            key: _formKey,
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.stretch,
              children: [
                // Header (Graduation cap and Text)
                const Icon(Icons.school, size: 80, color: Colors.blue),
                const SizedBox(height: 16),
                Text(
                  isSignIn ? 'Welcome back' : 'Create Account',
                  style: Theme.of(context).textTheme.headlineLarge?.copyWith(
                    fontWeight: FontWeight.bold,
                  ),
                  textAlign: TextAlign.center,
                ),
                Text(
                  isSignIn
                      ? 'Please sign in to access student data securely.'
                      : 'Register as a school administrator to manage student data securely.',
                  textAlign: TextAlign.center,
                  style: Theme.of(context).textTheme.bodyMedium,
                ),
                const SizedBox(height: 32),

                // Full Name field (Only on Sign Up)
                if (!isSignIn)
                  Padding(
                    padding: const EdgeInsets.only(bottom: 16.0),
                    child: TextFormField(
                      controller: _fullNameController,
                      decoration: const InputDecoration(
                        labelText: 'Full Name',
                        prefixIcon: Icon(Icons.person),
                      ),
                      validator: (value) => value == null || value.isEmpty
                          ? 'Enter your full name'
                          : null,
                    ),
                  ),

                // Email/Username Field
                Padding(
                  padding: const EdgeInsets.only(bottom: 16.0),
                  child: TextFormField(
                    controller: _emailController,
                    keyboardType: TextInputType.emailAddress,
                    decoration: const InputDecoration(
                      labelText: 'Email or Username',
                      prefixIcon: Icon(Icons.email),
                    ),
                    validator: (value) => value == null || !value.contains('@')
                        ? 'Enter a valid email'
                        : null,
                  ),
                ),

                // Password Field
                Padding(
                  padding: const EdgeInsets.only(bottom: 16.0),
                  child: TextFormField(
                    controller: _passwordController,
                    obscureText: true,
                    decoration: InputDecoration(
                      labelText: 'Password',
                      prefixIcon: const Icon(Icons.lock),
                      suffixIcon: IconButton(
                        icon: const Icon(Icons.visibility_off),
                        onPressed: () {
                          /* Toggle visibility logic here */
                        },
                      ),
                    ),
                    validator: (value) => value == null || value.length < 8
                        ? 'Must be at least 8 characters.'
                        : null,
                  ),
                ),

                // Confirm Password (Only on Sign Up)
                if (!isSignIn)
                  Padding(
                    padding: const EdgeInsets.only(bottom: 24.0),
                    child: TextFormField(
                      controller: _confirmPasswordController,
                      obscureText: true,
                      decoration: const InputDecoration(
                        labelText: 'Confirm Password',
                        prefixIcon: Icon(Icons.lock_reset),
                      ),
                      validator: (value) {
                        if (value != _passwordController.text) {
                          return 'Passwords do not match.';
                        }
                        return value == null || value.isEmpty
                            ? 'Confirm your password'
                            : null;
                      },
                    ),
                  ),

                // Forgot Password (Only on Sign In)
                if (isSignIn)
                  Align(
                    alignment: Alignment.centerRight,
                    child: TextButton(
                      onPressed: () {},
                      child: const Text('Forgot Password?'),
                    ),
                  ),

                // Log In / Create Account Button
                const SizedBox(height: 8),
                _isLoading
                    ? const Center(child: CircularProgressIndicator())
                    : ElevatedButton(
                        onPressed: _handleAuth,
                        style: ElevatedButton.styleFrom(
                          minimumSize: const Size.fromHeight(50),
                          shape: RoundedRectangleBorder(
                            borderRadius: BorderRadius.circular(8),
                          ),
                          backgroundColor: Colors.blue,
                          foregroundColor: Colors.white,
                        ),
                        child: Text(
                          isSignIn ? 'Log In' : 'Create Account ',
                          style: const TextStyle(
                            fontSize: 18,
                            fontWeight: FontWeight.bold,
                          ),
                        ),
                      ),

                const SizedBox(height: 32),

                // Footer: Sign Up / Log In switch (FIXED OVERFLOW HERE)
                Padding(
                  padding: const EdgeInsets.symmetric(
                    horizontal: 8.0,
                  ), // Added horizontal padding for safety
                  child: Row(
                    mainAxisAlignment: MainAxisAlignment.center,
                    children: [
                      // Wrap the potentially long text in Flexible to prevent overflow
                      Flexible(
                        child: Text(
                          isSignIn
                              ? "Don't have an administrator account?"
                              : "Already have an account?",
                        ),
                      ),
                      TextButton(
                        onPressed: _toggleView,
                        child: Text(isSignIn ? 'Sign Up' : 'Log In'),
                      ),
                    ],
                  ),
                ),

                const SizedBox(height: 16),
                const Center(child: Text(' Secure Connection')),
              ],
            ),
          ),
        ),
      ),
    );
  }
}
// lib/pages/home_screen.dart // Fixed import
import 'package:fees_up/pages/classes_view.dart';
import 'package:fees_up/pages/finances_page.dart';
import 'package:fees_up/pages/register_student_page.dart';
import 'package:fees_up/pages/settings_page.dart';
import 'package:fees_up/pages/student_ledger_page.dart';
import 'package:flutter/material.dart';
import 'package:flutter/services.dart'; // For SystemNavigator
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:flutter_riverpod/legacy.dart';
// import 'package:flutter_riverpod/legacy.dart'; // Removed legacy if not needed, but kept if you use it elsewhere.

// --- Providers & Models ---
import '../providers/dashboard_provider.dart';
import '../providers/auth_provider.dart';
import '../providers/student_provider.dart';
import '../models/dashboard_summary.dart';
import '../models/student_full.dart';

// -----------------------------------------------------------
// STATE MANAGEMENT
// -----------------------------------------------------------

final selectedGradeProvider = StateProvider.autoDispose<String>((ref) => 'All');
final selectedTabIndexProvider = StateProvider.autoDispose<int>((ref) => 0);
final searchQueryProvider = StateProvider.autoDispose<String>((ref) => '');

// -----------------------------------------------------------
// MAIN HOME SCREEN (DASHBOARD)
// -----------------------------------------------------------

class HomeScreen extends ConsumerWidget {
  const HomeScreen({super.key});
  static const String routeName = '/home';

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final selectedIndex = ref.watch(selectedTabIndexProvider);

    Widget currentBody;
    
    // Switch for Navigation Tabs
    if (selectedIndex == 0) {
      currentBody = const _DashboardView();
    } else if (selectedIndex == 1) {
      currentBody = const ClassesView();
    } else if (selectedIndex == 2) {
      currentBody = const FinancesPage();
    } else {
      // Placeholder for Settings (Index 3)
      currentBody = SettingsPage();
    }

    return Scaffold(
      body: currentBody,
      bottomNavigationBar: BottomNavigationBar(
        currentIndex: selectedIndex,
        onTap: (index) {
          ref.read(selectedTabIndexProvider.notifier).state = index;
        },
        selectedItemColor: Theme.of(context).colorScheme.primary,
        unselectedItemColor: Colors.white54,
        type: BottomNavigationBarType.fixed,
        items: const [
          BottomNavigationBarItem(
            icon: Icon(Icons.dashboard),
            label: 'Dashboard',
          ),
          BottomNavigationBarItem(
            icon: Icon(Icons.school), 
            label: 'Classes'
          ),
          BottomNavigationBarItem(
            icon: Icon(Icons.account_balance_wallet),
            label: 'Finances',
          ),
          BottomNavigationBarItem(
            icon: Icon(Icons.settings),
            label: 'Settings',
          ),
        ],
      ),
    );
  }
}

// -----------------------------------------------------------
// CORE DASHBOARD VIEW
// -----------------------------------------------------------

class _DashboardView extends ConsumerWidget {
  const _DashboardView();

  // Helper to group students by their grade/form
  Map<String, List<StudentFull>> _groupStudentsByGrade(
    List<StudentFull> filteredStudents,
  ) {
    final Map<String, List<StudentFull>> grouped = {};
    for (final s in filteredStudents) {
      final grade = s.student.grade != null && s.student.grade!.isNotEmpty
          ? s.student.grade!
          : 'Unassigned';

      if (!grouped.containsKey(grade)) {
        grouped[grade] = [];
      }
      grouped[grade]!.add(s);
    }
    return grouped;
  }

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    // 1. Watch Data
    final summaryAsync = ref.watch(dashboardSummaryProvider);
    final studentListAsync = ref.watch(studentListStreamProvider);

    // 2. Watch Filters
    final selectedGrade = ref.watch(selectedGradeProvider);
    final searchQuery = ref.watch(searchQueryProvider).toLowerCase();

    return CustomScrollView(
      slivers: [
        SliverAppBar(
          title: const Text('Fees Up Dashboard'),
          floating: true,
          pinned: true,
          actions: [
            // Logout Button (Clears session)
            IconButton(
              icon: const Icon(Icons.logout),
              tooltip: 'Logout',
              onPressed: () async {
                await ref.read(authControllerProvider.notifier).signOut();
              },
            ),
            // Quit App Button (Closes window)
            IconButton(
              icon: const Icon(Icons.power_settings_new),
              tooltip: 'Quit App',
              onPressed: () {
                SystemChannels.platform.invokeMethod('SystemNavigator.pop');
              },
            ),
            const SizedBox(width: 16),
          ],
        ),

        SliverPadding(
          padding: const EdgeInsets.symmetric(horizontal: 16.0, vertical: 24.0),
          sliver: studentListAsync.when(
            loading: () => const SliverFillRemaining(
              child: Center(child: CircularProgressIndicator()),
            ),
            error: (e, s) => SliverFillRemaining(
              child: Center(
                child: Text(
                  'Error: $e',
                  style: const TextStyle(color: Colors.red),
                ),
              ),
            ),
            data: (allStudents) {
              // --- 3. FILTERING LOGIC ---
              // Filter by Search Query First
              final searchedStudents = allStudents.where((s) {
                final name = (s.student.fullName ?? '').toLowerCase();
                final id = s.student.id.toLowerCase();
                return name.contains(searchQuery) || id.contains(searchQuery);
              }).toList();

              // Group the filtered results
              final groupedStudents = _groupStudentsByGrade(searchedStudents);

              // Determine available grades based on ALL data (so chips don't disappear while searching)
              final allGradesGrouped = _groupStudentsByGrade(allStudents);
              final availableGrades = [
                'All',
                ...allGradesGrouped.keys.toList()..sort(),
              ];

              // Filter by Grade Chip
              final visibleGrades = selectedGrade == 'All'
                  ? groupedStudents.keys.toList()
                  : [selectedGrade];

              visibleGrades.sort();

              return SliverList(
                delegate: SliverChildListDelegate([
                  // -- Summary Cards (Rowed & Shrinked) --
                  _buildSummaryMetrics(context, summaryAsync),

                  const SizedBox(height: 24),

                  // -- Header & Search --
                  Text(
                    'Student Directory',
                    style: Theme.of(context).textTheme.headlineSmall?.copyWith(
                      fontWeight: FontWeight.bold,
                    ),
                  ),
                  const SizedBox(height: 12),
                  const _SearchBarAndAddButton(),
                  const SizedBox(height: 12),

                  // -- Dynamic Filter Chips --
                  _GradeFilterChips(availableGrades: availableGrades),
                  const SizedBox(height: 16),

                  // -- List Content --
                  if (searchedStudents.isEmpty)
                    const _EmptyListWidget()
                  else
                    ...visibleGrades.map((grade) {
                      final students = groupedStudents[grade] ?? [];
                      if (students.isEmpty) return const SizedBox.shrink();

                      return _GradeExpansionTile(
                        gradeTitle: grade,
                        students: students,
                      );
                    }),

                  // Add bottom padding
                  const SizedBox(height: 80),
                ]),
              );
            },
          ),
        ),
      ],
    );
  }

  Widget _buildSummaryMetrics(
    BuildContext context,
    AsyncValue<DashboardSummary> summaryAsync,
  ) {
    return summaryAsync.when(
      loading: () => const SizedBox(
        height: 100,
        child: Center(child: CircularProgressIndicator()),
      ),
      error: (_, _) => const SizedBox.shrink(),
      data: (summary) => Row(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          // Active Students
          Expanded(
            child: DashboardCard(
              title: 'Active',
              value: summary.activeStudents.toString(),
              color: Colors.blue.shade400,
              icon: Icons.person,
            ),
          ),
          const SizedBox(width: 8), // Small gap
          // Total Owed
          Expanded(
            child: DashboardCard(
              title: 'Owed',
              value: '\$${summary.totalFeesOwed.toStringAsFixed(0)}',
              color: Colors.red.shade400,
              icon: Icons.money_off,
            ),
          ),
          const SizedBox(width: 8), // Small gap
          // Total Paid
          Expanded(
            child: DashboardCard(
              title: 'Paid',
              value: '\$${summary.totalFeesPaid.toStringAsFixed(0)}',
              color: Colors.green.shade400,
              icon: Icons.check_circle,
            ),
          ),
        ],
      ),
    );
  }
}

// -----------------------------------------------------------
// DIRECTORY COMPONENTS
// -----------------------------------------------------------

class _SearchBarAndAddButton extends ConsumerWidget {
  const _SearchBarAndAddButton();

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    return Row(
      children: [
        Expanded(
          child: TextField(
            onChanged: (value) {
              ref.read(searchQueryProvider.notifier).state = value;
            },
            decoration: InputDecoration(
              hintText: 'Search by name or ID...',
              prefixIcon: const Icon(Icons.search),
              border: OutlineInputBorder(
                borderRadius: BorderRadius.circular(8),
              ),
              contentPadding: const EdgeInsets.symmetric(
                vertical: 0,
                horizontal: 10,
              ),
            ),
          ),
        ),
        const SizedBox(width: 8),
        SizedBox(
          height: 48,
          width: 48,
          child: FloatingActionButton(
            heroTag: 'add_student',
            elevation: 2,
            onPressed: () async {
              // 1. Wait for result from RegisterStudentPage
              await Navigator.of(context).push(
                MaterialPageRoute(
                  builder: (context) => const RegisterStudentPage(),
                ),
              );

              // 2. Refresh Data Providers
              // This forces the dashboard summary and student list to reload from DB
              ref.invalidate(dashboardSummaryProvider);
              ref.invalidate(studentListStreamProvider);
            },
            backgroundColor: Theme.of(context).colorScheme.primary,
            child: const Icon(Icons.add, color: Colors.white),
          ),
        ),
      ],
    );
  }
}

class _GradeFilterChips extends ConsumerWidget {
  final List<String> availableGrades;
  const _GradeFilterChips({required this.availableGrades});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final selectedGrade = ref.watch(selectedGradeProvider);

    return SingleChildScrollView(
      scrollDirection: Axis.horizontal,
      child: Row(
        children: availableGrades.map((grade) {
          final isSelected = selectedGrade == grade;
          return Padding(
            padding: const EdgeInsets.only(right: 8.0),
            child: ChoiceChip(
              label: Text(grade),
              selected: isSelected,
              onSelected: (selected) {
                if (selected) {
                  ref.read(selectedGradeProvider.notifier).state = grade;
                }
              },
              selectedColor: Theme.of(context).colorScheme.primary,
              labelStyle: TextStyle(
                color: isSelected ? Colors.white : Colors.white70,
                fontWeight: isSelected ? FontWeight.bold : FontWeight.normal,
              ),
            ),
          );
        }).toList(),
      ),
    );
  }
}

class _GradeExpansionTile extends StatelessWidget {
  final String gradeTitle;
  final List<StudentFull> students;

  const _GradeExpansionTile({required this.gradeTitle, required this.students});

  @override
  Widget build(BuildContext context) {
    return Card(
      margin: const EdgeInsets.only(bottom: 12.0),
      color: Theme.of(
        context,
      ).colorScheme.surfaceContainerHighest.withAlpha(50),
      elevation: 0,
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(8)),
      child: ExpansionTile(
        tilePadding: const EdgeInsets.symmetric(horizontal: 12.0),
        title: Text(
          gradeTitle,
          style: Theme.of(
            context,
          ).textTheme.titleMedium?.copyWith(fontWeight: FontWeight.bold),
        ),
        initiallyExpanded: true,
        children: students.map((student) {
          return InkWell(
            onTap: () {
              // Navigate to Ledger
              Navigator.of(context).push(
                MaterialPageRoute(
                  builder: (context) =>
                      StudentLedgerPage(studentId: student.student.id),
                ),
              );
            },
            child: _StudentListItem(studentFull: student),
          );
        }).toList(),
      ),
    );
  }
}

class _StudentListItem extends StatelessWidget {
  final StudentFull studentFull;

  const _StudentListItem({required this.studentFull});

  @override
  Widget build(BuildContext context) {
    final student = studentFull.student;
    // Tolerance of 0.01 for floating point errors
    final isOwed = studentFull.owed > 0.01;

    final statusColor = isOwed
        ? Theme.of(context).colorScheme.error
        : Theme.of(context).colorScheme.secondary;
    final statusText = isOwed ? 'Owed' : 'Paid';
    final balanceText = isOwed
        ? '-\$${studentFull.owed.toStringAsFixed(2)}'
        : '\$0.00';

    return Padding(
      padding: const EdgeInsets.symmetric(horizontal: 12.0, vertical: 8.0),
      child: Row(
        children: [
          CircleAvatar(
            radius: 18,
            backgroundColor: statusColor.withAlpha(51),
            child: Text(
              (student.fullName != null && student.fullName!.isNotEmpty)
                  ? student.fullName![0].toUpperCase()
                  : '?',
              style: TextStyle(color: statusColor, fontWeight: FontWeight.bold),
            ),
          ),
          const SizedBox(width: 12),
          Expanded(
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  student.fullName ?? 'Unknown Name',
                  style: Theme.of(
                    context,
                  ).textTheme.bodyLarge?.copyWith(fontWeight: FontWeight.w600),
                ),
                Text(
                  student.grade ?? 'No Grade',
                  style: Theme.of(
                    context,
                  ).textTheme.bodySmall?.copyWith(color: Colors.white54),
                ),
              ],
            ),
          ),
          Column(
            crossAxisAlignment: CrossAxisAlignment.end,
            children: [
              Text(
                statusText,
                style: TextStyle(
                  color: statusColor,
                  fontSize: 10,
                  fontWeight: FontWeight.bold,
                ),
              ),
              Text(
                balanceText,
                style: TextStyle(
                  color: statusColor,
                  fontWeight: FontWeight.bold,
                  fontSize: 14,
                ),
              ),
            ],
          ),
        ],
      ),
    );
  }
}

class _EmptyListWidget extends StatelessWidget {
  const _EmptyListWidget();

  @override
  Widget build(BuildContext context) {
    return Container(
      padding: const EdgeInsets.all(32.0),
      decoration: BoxDecoration(
        color: Theme.of(context).colorScheme.surface.withAlpha(20),
        borderRadius: BorderRadius.circular(12),
        border: Border.all(color: Colors.white10),
      ),
      child: Column(
        children: [
          const Icon(Icons.search_off, size: 48, color: Colors.white24),
          const SizedBox(height: 12),
          Text(
            'No matching students',
            style: Theme.of(context).textTheme.titleMedium,
          ),
          const SizedBox(height: 4),
          Text(
            'Try adjusting your search or add a new student.',
            textAlign: TextAlign.center,
            style: Theme.of(
              context,
            ).textTheme.bodySmall?.copyWith(color: Colors.white54),
          ),
        ],
      ),
    );
  }
}

// 5. Reusable Card Widget (Compact Version)
class DashboardCard extends StatelessWidget {
  final String title;
  final String value;
  final Color color;
  final IconData icon;

  const DashboardCard({
    super.key,
    required this.title,
    required this.value,
    required this.color,
    required this.icon,
  });

  @override
  Widget build(BuildContext context) {
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 12.0, vertical: 12.0),
      decoration: BoxDecoration(
        color: Theme.of(context).colorScheme.surface,
        borderRadius: BorderRadius.circular(12),
        border: Border.all(color: Colors.white10),
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Row(
            children: [
              Icon(icon, color: color, size: 20),
              const SizedBox(width: 6),
              Expanded(
                child: Text(
                  title,
                  overflow: TextOverflow.ellipsis,
                  style: Theme.of(context).textTheme.bodyMedium?.copyWith(
                    color: Colors.white70,
                    fontSize: 12,
                  ),
                ),
              ),
            ],
          ),
          const SizedBox(height: 8),
          Text(
            value,
            maxLines: 1,
            overflow: TextOverflow.ellipsis,
            style: Theme.of(context).textTheme.titleLarge?.copyWith(
              fontWeight: FontWeight.bold,
              color: Colors.white,
              fontSize: 18,
            ),
          ),
        ],
      ),
    );
  }
}// lib/pages/student_ledger_page.dart

import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:intl/intl.dart';

// Fix 1: Ambiguous Import Resolution (Applies prefix 'update' to UpdateStudentPage)
import '../pages/update_student_page.dart' as update; 

// --- Services & Models ---
import '../services/database_service.dart';
import '../models/student_full.dart'; // Primary import for StudentFull model

// -----------------------------------------------------------------------------
// PROVIDER
// -----------------------------------------------------------------------------
final studentLedgerProvider = FutureProvider.autoDispose
    .family<StudentFull?, String>((ref, studentId) async {
      final db = DatabaseService.instance;
      await db.refreshStudentFullCache(includeInactive: true);
      // StudentFull type is correctly imported here
      return await db.getStudentFullById(studentId); 
    });

// -----------------------------------------------------------------------------
// HELPER MODEL (LedgerItem remains unchanged)
// -----------------------------------------------------------------------------
class LedgerItem {
  final String id;
  final DateTime date;
  final String title;
  final String subtitle;
  final double amount;
  final bool isCredit;

  LedgerItem({
    required this.id,
    required this.date,
    required this.title,
    required this.subtitle,
    required this.amount,
    required this.isCredit,
  });
}

// -----------------------------------------------------------------------------
// UI: STUDENT LEDGER PAGE
// -----------------------------------------------------------------------------
class StudentLedgerPage extends ConsumerWidget {
  final String studentId;

  const StudentLedgerPage({super.key, required this.studentId});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final studentAsync = ref.watch(studentLedgerProvider(studentId));
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;

    return Scaffold(
      backgroundColor: colorScheme.surface,
      body: studentAsync.when(
        loading: () => const Center(child: CircularProgressIndicator()),
        error: (e, s) => Center(child: Text('Error: $e')),
        data: (StudentFull? studentFull) { 
          if (studentFull == null) {
            return const Center(child: Text("Student not found"));
          }

          // --- PREPARE DATA ---
          final List<LedgerItem> transactions = [];

          for (var b in studentFull.bills) { 
            transactions.add(
              LedgerItem(
                id: b.id,
                date: b.createdAt ?? DateTime.now(),
                title: b.billType == 'monthly' ? 'Monthly Fee' : 'Term Fee',
                subtitle: b.monthYear ?? 'Standard Charge',
                amount: b.totalAmount,
                isCredit: false,
              ),
            );
          }
          for (var p in studentFull.payments) { 
            transactions.add(
              LedgerItem(
                id: p.id,
                date: p.datePaid ?? DateTime.now(),
                title: 'Payment Received',
                subtitle: p.method ?? 'Cash',
                amount: p.amount,
                isCredit: true,
              ),
            );
          }
          transactions.sort((a, b) => b.date.compareTo(a.date));

          // Parse Subjects
          List<String> subjectList = [];
          if (studentFull.student.subjects != null &&
              studentFull.student.subjects!.isNotEmpty) {
            subjectList = studentFull.student.subjects!.split(',');
          }

          return CustomScrollView(
            slivers: [
              // --- 1. App Bar ---
              SliverAppBar(
                pinned: true,
                title: Text(studentFull.student.fullName ?? 'Student Profile'),
                backgroundColor: colorScheme.surface,
                foregroundColor: colorScheme.onSurface,
                elevation: 0,
                actions: [
                  IconButton(
                    icon: const Icon(Icons.edit_outlined),
                    onPressed: () async {
                      // Navigate to UpdateStudentPage using the prefixed name
                      final result = await Navigator.of(context).push(
                        MaterialPageRoute(
                          builder: (context) => update.UpdateStudentPage(
                            studentId: studentId,
                            initialStudentData: studentFull,
                          ),
                        ),
                      );
                      if (result == true) {
                        ref.invalidate(studentLedgerProvider(studentId));
                      }
                    },
                  ),
                ],
              ),

              // --- 2. Profile Header ---
              SliverToBoxAdapter(
                child: _buildProfileHeader(context, studentFull),
              ),

              // --- 3. Enrolled Subjects ---
              if (subjectList.isNotEmpty)
                SliverToBoxAdapter(
                  child: _buildSubjectsSection(context, subjectList),
                ),

              // --- 4. Financial Stats ---
              SliverToBoxAdapter(
                child: _buildFinancialStats(context, studentFull),
              ),

              // --- 5. Personal Details ---
              SliverToBoxAdapter(
                child: _buildPersonalDetails(context, studentFull),
              ),

              // --- 6. Ledger Title ---
              SliverToBoxAdapter(
                child: Padding(
                  padding: const EdgeInsets.fromLTRB(16, 24, 16, 8),
                  child: Text(
                    "Transaction History",
                    style: theme.textTheme.titleMedium?.copyWith(
                      fontWeight: FontWeight.bold,
                    ),
                  ),
                ),
              ),

              // --- 7. Transaction List ---
              if (transactions.isEmpty)
                SliverToBoxAdapter(
                  child: Padding(
                    padding: const EdgeInsets.all(32.0),
                    child: Center(
                      child: Text(
                        "No transactions recorded.",
                        style: TextStyle(color: colorScheme.onSurfaceVariant),
                      ),
                    ),
                  ),
                )
              else
                SliverList(
                  delegate: SliverChildBuilderDelegate(
                    (context, index) =>
                        _buildTransactionTile(context, transactions[index]),
                    childCount: transactions.length,
                  ),
                ),

              const SliverToBoxAdapter(child: SizedBox(height: 100)),
            ],
          );
        },
      ),

      // --- Bottom Action Bar ---
      bottomNavigationBar: Container(
        padding: const EdgeInsets.all(16),
        decoration: BoxDecoration(
          color: colorScheme.surfaceContainer,
          boxShadow: [
            BoxShadow(
              color: Colors.black.withAlpha(13),
              blurRadius: 10,
              offset: const Offset(0, -4),
            ),
          ],
        ),
        child: Row(
          children: [
            Expanded(
              child: OutlinedButton.icon(
                onPressed: () => _showAddBillModal(context, ref, studentId),
                icon: Icon(
                  Icons.remove_circle_outline,
                  color: colorScheme.error,
                ),
                label: Text(
                  "Add Charge",
                  style: TextStyle(color: colorScheme.error),
                ),
                style: OutlinedButton.styleFrom(
                  padding: const EdgeInsets.symmetric(vertical: 16),
                  side: BorderSide(color: colorScheme.error),
                  shape: RoundedRectangleBorder(
                    borderRadius: BorderRadius.circular(12),
                  ),
                ),
              ),
            ),
            const SizedBox(width: 12),
            Expanded(
              child: ElevatedButton.icon(
                onPressed: () => _showAddPaymentModal(context, ref, studentId),
                // Fix 3: Undefined 'icons' changed to 'Icons'
                icon: Icon(Icons.add_card, color: colorScheme.onPrimary), 
                label: Text(
                  "Add Payment",
                  style: TextStyle(
                    color: colorScheme.onPrimary,
                    fontWeight: FontWeight.bold,
                  ),
                ),
                style: ElevatedButton.styleFrom(
                  backgroundColor: colorScheme.primary,
                  padding: const EdgeInsets.symmetric(vertical: 16),
                  shape: RoundedRectangleBorder(
                    borderRadius: BorderRadius.circular(12),
                  ),
                  elevation: 2,
                ),
              ),
            ),
          ],
        ),
      ),
    );
  }

  // --- WIDGETS ---

  Widget _buildProfileHeader(BuildContext context, StudentFull s) {
    final colorScheme = Theme.of(context).colorScheme;
    return Container(
      color: colorScheme.surface,
      padding: const EdgeInsets.only(bottom: 16, top: 10),
      child: Column(
        children: [
          Container(
            padding: const EdgeInsets.all(4),
            decoration: BoxDecoration(
              shape: BoxShape.circle,
              border: Border.all(color: colorScheme.primaryContainer, width: 3),
            ),
            child: CircleAvatar(
              radius: 40,
              backgroundColor: colorScheme.primaryContainer,
              child: Text(
                s.student.fullName?[0].toUpperCase() ?? '?',
                style: TextStyle(
                  fontSize: 32,
                  fontWeight: FontWeight.bold,
                  color: colorScheme.primary,
                ),
              ),
            ),
          ),
          const SizedBox(height: 12),
          Text(
            s.student.fullName ?? 'Unknown',
            style: TextStyle(
              fontSize: 22,
              fontWeight: FontWeight.bold,
              color: colorScheme.onSurface,
            ),
          ),
          const SizedBox(height: 4),
          Text(
            '${s.student.grade ?? 'Unassigned'}  ${s.student.billingType?.toUpperCase() ?? 'MONTHLY'}',
            style: TextStyle(
              fontSize: 14,
              color: colorScheme.onSurfaceVariant,
              fontWeight: FontWeight.w500,
            ),
          ),
          const SizedBox(height: 16),
          // Status Chip
          Container(
            padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 6),
            decoration: BoxDecoration(
              // FIX 12: Replaced withOpacity (0.1) -> withAlpha(25) [~10% of 255]
              color: s.student.isActive ? Colors.green.withAlpha(25) : colorScheme.errorContainer,
              borderRadius: BorderRadius.circular(20),
              border: Border.all(
                // FIX 13: Replaced withOpacity (0.3) -> withAlpha(76)
                color: s.student.isActive ? Colors.green.withAlpha(76) : colorScheme.error.withAlpha(76),
              ),
            ),
            child: Row(
              mainAxisSize: MainAxisSize.min,
              children: [
                Icon(
                  s.student.isActive ? Icons.check_circle : Icons.cancel,
                  size: 16,
                  color: s.student.isActive ? Colors.green : colorScheme.error,
                ),
                const SizedBox(width: 6),
                Text(
                  s.student.isActive ? 'ACTIVE STUDENT' : 'INACTIVE',
                  style: TextStyle(
                    fontSize: 11,
                    fontWeight: FontWeight.bold,
                    color: s.student.isActive ? Colors.green : colorScheme.error,
                  ),
                ),
              ],
            ),
          ),
        ],
      ),
    );
  }

  // NEW: Subjects Section
  Widget _buildSubjectsSection(BuildContext context, List<String> subjects) {
    final colorScheme = Theme.of(context).colorScheme;
    return Padding(
      padding: const EdgeInsets.symmetric(horizontal: 16.0, vertical: 8.0),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Text(
            "Enrolled Subjects",
            style: TextStyle(
              fontSize: 12,
              fontWeight: FontWeight.bold,
              color: colorScheme.onSurfaceVariant,
            ),
          ),
          const SizedBox(height: 8),
          Wrap(
            spacing: 8,
            runSpacing: 8,
            children: subjects
                .map(
                  (sub) => Chip(
                    label: Text(
                      sub,
                      style: TextStyle(
                        fontSize: 11,
                        color: colorScheme.onSecondaryContainer,
                      ),
                    ),
                    backgroundColor: colorScheme.secondaryContainer,
                    side: BorderSide.none,
                    visualDensity: VisualDensity.compact,
                    padding: EdgeInsets.zero,
                  ),
                )
                .toList(),
          ),
        ],
      ),
    );
  }

  Widget _buildFinancialStats(BuildContext context, StudentFull s) {
    final colorScheme = Theme.of(context).colorScheme;
    return Padding(
      padding: const EdgeInsets.all(16.0),
      child: Row(
        children: [
          Expanded(
            child: _statCard(
              context,
              "Billed",
              s.totalBilled,
              colorScheme.onSurface,
              colorScheme.surfaceContainerLow,
            ),
          ),
          const SizedBox(width: 8),
          Expanded(
            child: _statCard(
              context,
              "Paid",
              s.totalPaid,
              Colors.green,
              colorScheme.surfaceContainerLow,
            ),
          ),
          const SizedBox(width: 8),
          Expanded(
            child: _statCard(
              context,
              "Owed",
              s.owed,
              colorScheme.error,
              // FIX 14: Replaced withOpacity(0.2) -> withAlpha(51)
              colorScheme.errorContainer.withAlpha(51),
            ),
          ),
        ],
      ),
    );
  }

  Widget _statCard(
    BuildContext context,
    String label,
    double amount,
    Color textColor,
    Color bgColor,
  ) {
    final colorScheme = Theme.of(context).colorScheme;
    return Container(
      padding: const EdgeInsets.all(12),
      decoration: BoxDecoration(
        color: bgColor,
        borderRadius: BorderRadius.circular(12),
        // FIX 15: Replaced withOpacity(0.5) -> withAlpha(128)
        border: Border.all(color: colorScheme.outlineVariant.withAlpha(128)),
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Text(
            label.toUpperCase(),
            style: TextStyle(
              fontSize: 10,
              fontWeight: FontWeight.bold,
              color: colorScheme.onSurfaceVariant,
              letterSpacing: 0.5,
            ),
          ),
          const SizedBox(height: 4),
          Text(
            '\$${amount.toStringAsFixed(0)}',
            style: TextStyle(
              fontSize: 18,
              fontWeight: FontWeight.bold,
              color: textColor,
            ),
            overflow: TextOverflow.ellipsis,
          ),
        ],
      ),
    );
  }

  Widget _buildPersonalDetails(BuildContext context, StudentFull s) {
    final colorScheme = Theme.of(context).colorScheme;
    return Padding(
      padding: const EdgeInsets.symmetric(horizontal: 16.0),
      child: Card(
        color: colorScheme.surfaceContainerLow,
        elevation: 0,
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(12),
          // FIX 16: Replaced withOpacity(0.5) -> withAlpha(128)
          side: BorderSide(color: colorScheme.outlineVariant.withAlpha(128)),
        ),
        child: Column(
          children: [
            _detailRow(
              context,
              Icons.person_outline,
              "Parent / Guardian",
              s.student.parentContact ?? "No Name",
            ),
            Divider(
              height: 1,
              indent: 50,
              // FIX 17: Replaced withOpacity(0.5) -> withAlpha(128)
              color: colorScheme.outlineVariant.withAlpha(128),
            ),
            _detailRow(
              context,
              Icons.phone_outlined,
              "Contact Number",
              s.student.parentContact ?? "No Number",
            ),
            Divider(
              height: 1,
              indent: 50,
              // FIX 18: Replaced withOpacity(0.5) -> withAlpha(128)
              color: colorScheme.outlineVariant.withAlpha(128),
            ),
            _detailRow(
              context,
              Icons.calendar_today_outlined,
              "Registered",
              s.student.registrationDate != null
                  ? DateFormat(
                      'MMM dd, yyyy',
                    ).format(s.student.registrationDate!)
                  : 'Unknown',
            ),
          ],
        ),
      ),
    );
  }

  Widget _detailRow(
    BuildContext context,
    IconData icon,
    String label,
    String value,
  ) {
    final colorScheme = Theme.of(context).colorScheme;
    return Padding(
      padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
      child: Row(
        children: [
          Container(
            padding: const EdgeInsets.all(8),
            decoration: BoxDecoration(
              color: colorScheme.surface,
              shape: BoxShape.circle,
            ),
            child: Icon(icon, size: 18, color: colorScheme.primary),
          ),
          const SizedBox(width: 16),
          Expanded(
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  label,
                  style: TextStyle(
                    fontSize: 12,
                    color: colorScheme.onSurfaceVariant,
                  ),
                ),
                Text(
                  value,
                  style: TextStyle(
                    fontSize: 14,
                    fontWeight: FontWeight.w500,
                    color: colorScheme.onSurface,
                  ),
                ),
              ],
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildTransactionTile(BuildContext context, LedgerItem item) {
    final colorScheme = Theme.of(context).colorScheme;
    return Container(
      margin: const EdgeInsets.symmetric(horizontal: 16, vertical: 6),
      padding: const EdgeInsets.all(16),
      decoration: BoxDecoration(
        color: colorScheme.surfaceContainerLow,
        borderRadius: BorderRadius.circular(12),
        // FIX 19: Replaced withOpacity(0.5) -> withAlpha(128)
        border: Border.all(color: colorScheme.outlineVariant.withAlpha(128)),
      ),
      child: Row(
        children: [
          Container(
            padding: const EdgeInsets.all(10),
            decoration: BoxDecoration(
              // FIX 20: Replaced withOpacity(0.1) -> withAlpha(25)
              color: item.isCredit ? Colors.green.withAlpha(25) : colorScheme.error.withAlpha(25),
              borderRadius: BorderRadius.circular(10),
            ),
            child: Icon(
              item.isCredit ? Icons.arrow_downward : Icons.arrow_upward,
              color: item.isCredit ? Colors.green : colorScheme.error,
              size: 20,
            ),
          ),
          const SizedBox(width: 16),
          Expanded(
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  item.title,
                  style: TextStyle(
                    fontWeight: FontWeight.bold,
                    fontSize: 15,
                    color: colorScheme.onSurface,
                  ),
                ),
                Text(
                  DateFormat('MMM dd, yyyy').format(item.date),
                  style: TextStyle(
                    color: colorScheme.onSurfaceVariant,
                    fontSize: 12,
                  ),
                ),
              ],
            ),
          ),
          Column(
            crossAxisAlignment: CrossAxisAlignment.end,
            children: [
              Text(
                '${item.isCredit ? '+' : '-'}\$${item.amount.toStringAsFixed(2)}',
                style: TextStyle(
                  fontWeight: FontWeight.bold,
                  fontSize: 16,
                  color: item.isCredit ? Colors.green : colorScheme.onSurface,
                ),
              ),
              if (!item.isCredit)
                Text(
                  item.subtitle,
                  style: TextStyle(
                    fontSize: 11,
                    color: colorScheme.onSurfaceVariant,
                  ),
                ),
            ],
          ),
        ],
      ),
    );
  }

  // --- ACTIONS (MODALS) ---
  // Modals are updated to use Theme colors for backgrounds and text.

  void _showAddPaymentModal(
    BuildContext context,
    WidgetRef ref,
    String studentId,
  ) {
    final amountController = TextEditingController();
    final theme = Theme.of(context);

    showModalBottomSheet(
      context: context,
      isScrollControlled: true,
      backgroundColor: Colors.transparent,
      builder: (ctx) => Container(
        padding: EdgeInsets.only(
          bottom: MediaQuery.of(ctx).viewInsets.bottom,
          left: 20,
          right: 20,
          top: 20,
        ),
        decoration: BoxDecoration(
          color: theme.colorScheme.surface,
          borderRadius: const BorderRadius.vertical(top: Radius.circular(20)),
        ),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.stretch,
          children: [
            Text(
              "Record Payment",
              style: TextStyle(
                fontSize: 20,
                fontWeight: FontWeight.bold,
                color: theme.colorScheme.onSurface,
              ),
            ),
            const SizedBox(height: 20),
            TextField(
              controller: amountController,
              keyboardType: const TextInputType.numberWithOptions(
                decimal: true,
              ),
              autofocus: true,
              style: TextStyle(color: theme.colorScheme.onSurface),
              decoration: InputDecoration(
                labelText: "Amount",
                prefixText: "\$ ",
                border: OutlineInputBorder(
                  borderRadius: BorderRadius.circular(12),
                ),
              ),
            ),
            const SizedBox(height: 20),
            ElevatedButton(
              onPressed: () async {
                final amount = double.tryParse(amountController.text);
                if (amount != null && amount > 0) {
                  final db = DatabaseService.instance;
                  final bills = await db.getStudentBills(studentId);
                  String? billId;
                  if (bills.isNotEmpty) {
                    billId = bills.first['id'] as String;
                  }

                  if (billId != null) {
                    await db.recordPayment(
                      billId: billId,
                      studentId: studentId,
                      amount: amount,
                      datePaid: DateTime.now(),
                      method: 'Cash',
                    );
                    if (context.mounted) {
                      Navigator.pop(context);
                      ref.invalidate(studentLedgerProvider(studentId));
                    }
                  } else {
                    if (context.mounted) {
                      ScaffoldMessenger.of(context).showSnackBar(
                        const SnackBar(
                          content: Text("No bill to pay against!"),
                        ),
                      );
                    }
                  }
                }
              },
              style: ElevatedButton.styleFrom(
                backgroundColor: theme.colorScheme.primary,
                foregroundColor: theme.colorScheme.onPrimary,
                padding: const EdgeInsets.symmetric(vertical: 16),
                shape: RoundedRectangleBorder(
                  borderRadius: BorderRadius.circular(12),
                ),
              ),
              child: const Text("Confirm Payment"),
            ),
            const SizedBox(height: 30),
          ],
        ),
      ),
    );
  }

  void _showAddBillModal(
    BuildContext context,
    WidgetRef ref,
    String studentId,
  ) {
    final amountController = TextEditingController();
    final descController = TextEditingController();
    final theme = Theme.of(context);

    showModalBottomSheet(
      context: context,
      isScrollControlled: true,
      backgroundColor: Colors.transparent,
      builder: (ctx) => Container(
        padding: EdgeInsets.only(
          bottom: MediaQuery.of(ctx).viewInsets.bottom,
          left: 20,
          right: 20,
          top: 20,
        ),
        decoration: BoxDecoration(
          color: theme.colorScheme.surface,
          borderRadius: const BorderRadius.vertical(top: Radius.circular(20)),
        ),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.stretch,
          children: [
            Text(
              "Add Manual Charge",
              style: TextStyle(
                fontSize: 20,
                fontWeight: FontWeight.bold,
                color: theme.colorScheme.onSurface,
              ),
            ),
            const SizedBox(height: 20),
            TextField(
              controller: descController,
              style: TextStyle(color: theme.colorScheme.onSurface),
              decoration: InputDecoration(
                labelText: "Description (e.g. Uniform)",
                border: OutlineInputBorder(
                  borderRadius: BorderRadius.circular(12),
                ),
              ),
            ),
            const SizedBox(height: 12),
            TextField(
              controller: amountController,
              keyboardType: const TextInputType.numberWithOptions(
                decimal: true,
              ),
              style: TextStyle(color: theme.colorScheme.onSurface),
              decoration: InputDecoration(
                labelText: "Amount",
                prefixText: "\$ ",
                border: OutlineInputBorder(
                  borderRadius: BorderRadius.circular(12),
                ),
              ),
            ),
            const SizedBox(height: 20),
            ElevatedButton(
              onPressed: () async {
                final amount = double.tryParse(amountController.text);
                if (amount != null && amount > 0) {
                  final db = DatabaseService.instance;
                  await db.createBillForStudent(
                    studentId: studentId,
                    totalAmount: amount,
                    billType: 'custom',
                    monthYear: descController.text.isNotEmpty
                        ? descController.text
                        : 'Manual Charge',
                    createdAt: DateTime.now(),
                  );
                  if (context.mounted) {
                    Navigator.pop(context);
                    ref.invalidate(studentLedgerProvider(studentId));
                  }
                }
              },
              style: ElevatedButton.styleFrom(
                backgroundColor: theme.colorScheme.error,
                foregroundColor: theme.colorScheme.onError,
                padding: const EdgeInsets.symmetric(vertical: 16),
                shape: RoundedRectangleBorder(
                  borderRadius: BorderRadius.circular(12),
                ),
              ),
              child: const Text("Create Charge"),
            ),
            const SizedBox(height: 30),
          ],
        ),
      ),
    );
  }
}import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:intl/intl.dart';
import '../models/billing_config.dart';
import '../services/database_service.dart';

class BillingSettingsPage extends ConsumerStatefulWidget {
  const BillingSettingsPage({super.key});

  @override
  ConsumerState<BillingSettingsPage> createState() => _BillingSettingsPageState();
}

class _BillingSettingsPageState extends ConsumerState<BillingSettingsPage> {
  // -- State --
  BillingConfig _config = BillingConfig(); 
  bool _isLoading = true;

  // -- Controllers --
  final _defaultFeeCtrl = TextEditingController();
  final _cycleCtrl = TextEditingController();
  final _lateFeeAmountCtrl = TextEditingController();
  final _graceDaysCtrl = TextEditingController();

  @override
  void initState() {
    super.initState();
    _loadConfig();
  }

  Future<void> _loadConfig() async {
    // Fetch from SQLite
    final config = await DatabaseService.instance.getBillingConfig();
    
    if (mounted) {
      setState(() {
        _config = config;
        // Sync controllers
        _defaultFeeCtrl.text = _config.defaultFee.toStringAsFixed(2);
        _cycleCtrl.text = _config.cycleInterval.toString();
        _lateFeeAmountCtrl.text = _config.lateFeeAmount.toStringAsFixed(2);
        _graceDaysCtrl.text = _config.graceDays.toString();
        _isLoading = false;
      });
    }
  }

  @override
  void dispose() {
    _defaultFeeCtrl.dispose();
    _cycleCtrl.dispose();
    _lateFeeAmountCtrl.dispose();
    _graceDaysCtrl.dispose();
    super.dispose();
  }

  // --- Actions ---

  Future<void> _saveConfiguration() async {
    setState(() => _isLoading = true);

    // 1. Update Config Object from Controllers
    _config.defaultFee = double.tryParse(_defaultFeeCtrl.text) ?? 0.0;
    _config.cycleInterval = int.tryParse(_cycleCtrl.text) ?? 3;
    _config.lateFeeAmount = double.tryParse(_lateFeeAmountCtrl.text) ?? 0.0;
    _config.graceDays = int.tryParse(_graceDaysCtrl.text) ?? 5;

    try {
      // 2. Persist to DB
      await DatabaseService.instance.saveBillingConfig(_config);
      
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(content: Text("Configuration Saved Successfully")),
        );
        Navigator.pop(context);
      }
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text("Error saving: $e"), backgroundColor: Colors.red),
        );
      }
    } finally {
      if (mounted) setState(() => _isLoading = false);
    }
  }

  void _addExpenseCategory(String category) {
    if (category.isNotEmpty && !_config.expenseCategories.contains(category)) {
      setState(() {
        // Because BillingConfig now initializes this as a mutable list, .add() works
        _config.expenseCategories.add(category);
      });
    }
  }

  Future<void> _showAddCategoryDialog() async {
    final ctrl = TextEditingController();
    await showDialog(
      context: context,
      builder: (ctx) => AlertDialog(
        backgroundColor: const Color(0xff1c2a35),
        title: const Text("New Category", style: TextStyle(color: Colors.white)),
        content: TextField(
          controller: ctrl,
          style: const TextStyle(color: Colors.white),
          decoration: const InputDecoration(
            hintText: "e.g. Transport",
            hintStyle: TextStyle(color: Colors.white54),
            enabledBorder: UnderlineInputBorder(borderSide: BorderSide(color: Colors.white24)),
          ),
        ),
        actions: [
          TextButton(onPressed: () => Navigator.pop(ctx), child: const Text("Cancel")),
          TextButton(
            onPressed: () {
              _addExpenseCategory(ctrl.text.trim());
              Navigator.pop(ctx);
            },
            child: const Text("Add"),
          ),
        ],
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    // Custom Theme Colors
    const cardColor = Color(0xff1c2a35);
    const bgColor = Color(0xff121b22);
    const blueAccent = Color(0xff3498db);

    final inputDecoration = BoxDecoration(
      color: Colors.black.withAlpha(50),
      borderRadius: BorderRadius.circular(8),
      border: Border.all(color: Colors.white.withAlpha(20)),
    );

    if (_isLoading) {
      return const Scaffold(
        backgroundColor: bgColor,
        body: Center(child: CircularProgressIndicator()),
      );
    }

    return Scaffold(
      backgroundColor: bgColor,
      appBar: AppBar(
        backgroundColor: bgColor,
        iconTheme: const IconThemeData(color: Colors.white),
        title: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            const Text("Billing Settings", style: TextStyle(color: Colors.white, fontWeight: FontWeight.bold, fontSize: 18)),
            Text("Financial Configuration", style: TextStyle(color: Colors.white.withAlpha(150), fontSize: 12)),
          ],
        ),
      ),
      body: SingleChildScrollView(
        padding: const EdgeInsets.all(20),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            const _SectionHeader(title: "GENERAL PARAMETERS"),
            
            // --- GENERAL CARD ---
            Container(
              padding: const EdgeInsets.all(20),
              decoration: BoxDecoration(
                color: cardColor,
                borderRadius: BorderRadius.circular(16),
                border: Border.all(color: Colors.white.withAlpha(10)),
              ),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Row(
                    children: [
                      Expanded(
                        flex: 3,
                        child: Column(
                          crossAxisAlignment: CrossAxisAlignment.start,
                          children: [
                            const _Label("Billing Type"),
                            Container(
                              padding: const EdgeInsets.symmetric(horizontal: 12),
                              decoration: inputDecoration,
                              child: DropdownButtonHideUnderline(
                                child: DropdownButton<String>(
                                  value: _config.billingType,
                                  dropdownColor: cardColor,
                                  isExpanded: true,
                                  icon: const Icon(Icons.keyboard_arrow_down, color: Colors.white70),
                                  style: const TextStyle(color: Colors.white, fontWeight: FontWeight.bold),
                                  items: ['Monthly', 'Term-based'].map((e) => DropdownMenuItem(value: e, child: Text(e))).toList(),
                                  onChanged: (v) => setState(() => _config.billingType = v!),
                                ),
                              ),
                            ),
                          ],
                        ),
                      ),
                      const SizedBox(width: 16),
                      Expanded(
                        flex: 2,
                        child: Column(
                          crossAxisAlignment: CrossAxisAlignment.start,
                          children: [
                            const _Label("Cycle Interval"),
                            Container(
                              decoration: inputDecoration,
                              child: TextField(
                                controller: _cycleCtrl,
                                style: const TextStyle(color: Colors.white, fontWeight: FontWeight.bold),
                                keyboardType: TextInputType.number,
                                textAlign: TextAlign.center,
                                decoration: const InputDecoration(
                                  border: InputBorder.none,
                                  suffixText: "MTHS",
                                  suffixStyle: TextStyle(fontSize: 10, color: Colors.white54),
                                  contentPadding: EdgeInsets.symmetric(horizontal: 12, vertical: 14),
                                ),
                              ),
                            ),
                          ],
                        ),
                      ),
                    ],
                  ),
                  const SizedBox(height: 20),
                  const _Label("Default Student Fee"),
                  Container(
                    decoration: inputDecoration,
                    child: TextField(
                      controller: _defaultFeeCtrl,
                      style: const TextStyle(color: Colors.white, fontSize: 18, fontWeight: FontWeight.bold),
                      keyboardType: const TextInputType.numberWithOptions(decimal: true),
                      decoration: const InputDecoration(
                        prefixIcon: Icon(Icons.attach_money, color: Colors.white54),
                        border: InputBorder.none,
                        contentPadding: EdgeInsets.symmetric(vertical: 14),
                      ),
                    ),
                  ),
                  const SizedBox(height: 8),
                  Text(
                    "Applied automatically to new enrollments",
                    style: TextStyle(color: Colors.white.withAlpha(100), fontSize: 11),
                  ),
                ],
              ),
            ),

            const SizedBox(height: 32),

            // --- TERMS SECTION ---
            Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                const _SectionHeader(title: "ACADEMIC TERMS"),
                TextButton.icon(
                  onPressed: () {
                    // TODO: Open Add Term Modal
                  },
                  icon: const Icon(Icons.add, size: 16),
                  label: const Text("Add Term"),
                  style: TextButton.styleFrom(foregroundColor: blueAccent),
                )
              ],
            ),
            
            ..._config.terms.asMap().entries.map((entry) {
              final index = entry.key + 1;
              final term = entry.value;
              return Container(
                margin: const EdgeInsets.only(bottom: 12),
                padding: const EdgeInsets.all(16),
                decoration: BoxDecoration(
                  color: cardColor,
                  borderRadius: BorderRadius.circular(16),
                  border: Border.all(color: Colors.white.withAlpha(10)),
                ),
                child: Column(
                  children: [
                    Row(
                      mainAxisAlignment: MainAxisAlignment.spaceBetween,
                      children: [
                        Row(
                          children: [
                            Container(
                              padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
                              decoration: BoxDecoration(
                                border: Border.all(color: Colors.white.withAlpha(50)),
                                borderRadius: BorderRadius.circular(6),
                              ),
                              child: Text(
                                index.toString().padLeft(2, '0'), 
                                style: const TextStyle(color: Colors.white, fontWeight: FontWeight.bold, fontSize: 12)
                              ),
                            ),
                            const SizedBox(width: 12),
                            Column(
                              crossAxisAlignment: CrossAxisAlignment.start,
                              children: [
                                Text(term.name, style: const TextStyle(color: Colors.white, fontWeight: FontWeight.bold, fontSize: 16)),
                                Text(term.year, style: TextStyle(color: Colors.white.withAlpha(150), fontSize: 12)),
                              ],
                            ),
                          ],
                        ),
                        IconButton(
                          onPressed: () {}, 
                          icon: const Icon(Icons.edit, size: 18, color: Colors.white54)
                        ),
                      ],
                    ),
                    const SizedBox(height: 16),
                    Row(
                      children: [
                        Expanded(child: _DateBox(label: "START DATE", date: term.start)),
                        const SizedBox(width: 12),
                        Expanded(child: _DateBox(label: "END DATE", date: term.end)),
                      ],
                    )
                  ],
                ),
              );
            }),

            const SizedBox(height: 32),

            const _SectionHeader(title: "EXPENSE CATEGORIES"),
            Container(
              width: double.infinity,
              padding: const EdgeInsets.all(20),
              decoration: BoxDecoration(
                color: cardColor,
                borderRadius: BorderRadius.circular(16),
                border: Border.all(color: Colors.white.withAlpha(10)),
              ),
              child: Wrap(
                spacing: 8,
                runSpacing: 12,
                children: [
                  ..._config.expenseCategories.map((cat) => Chip(
                    label: Text(cat),
                    backgroundColor: blueAccent.withAlpha(40),
                    labelStyle: TextStyle(color: blueAccent.withAlpha(255), fontWeight: FontWeight.w600),
                    side: BorderSide(color: blueAccent.withAlpha(100)),
                    deleteIcon: Icon(Icons.close, size: 14, color: blueAccent.withAlpha(200)),
                    onDeleted: () => setState(() => _config.expenseCategories.remove(cat)),
                    shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(8)),
                  )),
                  
                  ActionChip(
                    label: const Text("+ New Category"),
                    backgroundColor: Colors.transparent,
                    side: BorderSide(color: Colors.white.withAlpha(50), style: BorderStyle.solid),
                    labelStyle: TextStyle(color: Colors.white.withAlpha(150)),
                    onPressed: _showAddCategoryDialog,
                    shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(8)),
                  ),
                ],
              ),
            ),

            const SizedBox(height: 32),

            const _SectionHeader(title: "LATE FEE POLICY"),
            Container(
              padding: const EdgeInsets.all(20),
              decoration: BoxDecoration(
                color: cardColor,
                borderRadius: BorderRadius.circular(16),
                border: Border.all(color: Colors.white.withAlpha(10)),
              ),
              child: Column(
                children: [
                  Row(
                    mainAxisAlignment: MainAxisAlignment.spaceBetween,
                    children: [
                      Column(
                        crossAxisAlignment: CrossAxisAlignment.start,
                        children: [
                          const Text("Auto-apply Late Fees", style: TextStyle(color: Colors.white, fontWeight: FontWeight.bold, fontSize: 15)),
                          const SizedBox(height: 4),
                          Text("Charge after grace period", style: TextStyle(color: Colors.white.withAlpha(150), fontSize: 12)),
                        ],
                      ),
                      Switch(
                        value: _config.autoLateFee, 
                        onChanged: (v) => setState(() => _config.autoLateFee = v),
                        activeColor: blueAccent,
                        activeTrackColor: blueAccent.withAlpha(100),
                        inactiveTrackColor: Colors.grey.withAlpha(50),
                      ),
                    ],
                  ),
                  if (_config.autoLateFee) ...[
                    const SizedBox(height: 20),
                    Row(
                      children: [
                        Expanded(
                          child: Column(
                            crossAxisAlignment: CrossAxisAlignment.start,
                            children: [
                              const _Label("Grace Days"),
                              Container(
                                decoration: inputDecoration,
                                child: TextField(
                                  controller: _graceDaysCtrl,
                                  style: const TextStyle(color: Colors.white),
                                  keyboardType: TextInputType.number,
                                  decoration: const InputDecoration(
                                    border: InputBorder.none,
                                    contentPadding: EdgeInsets.symmetric(horizontal: 16, vertical: 14),
                                  ),
                                ),
                              ),
                            ],
                          ),
                        ),
                        const SizedBox(width: 16),
                        Expanded(
                          child: Column(
                            crossAxisAlignment: CrossAxisAlignment.start,
                            children: [
                              const _Label("Fee Amount"),
                              Container(
                                decoration: inputDecoration,
                                child: TextField(
                                  controller: _lateFeeAmountCtrl,
                                  style: const TextStyle(color: Colors.white),
                                  keyboardType: const TextInputType.numberWithOptions(decimal: true),
                                  decoration: const InputDecoration(
                                    prefixIcon: Icon(Icons.attach_money, size: 16, color: Colors.white54),
                                    border: InputBorder.none,
                                    contentPadding: EdgeInsets.symmetric(vertical: 14),
                                  ),
                                ),
                              ),
                            ],
                          ),
                        ),
                      ],
                    ),
                  ],
                ],
              ),
            ),

            const SizedBox(height: 40),

            SizedBox(
              width: double.infinity,
              height: 56,
              child: ElevatedButton.icon(
                onPressed: _saveConfiguration,
                style: ElevatedButton.styleFrom(
                  backgroundColor: blueAccent,
                  foregroundColor: Colors.white,
                  shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
                  elevation: 4,
                ),
                icon: const Icon(Icons.save),
                label: const Text("Save Configuration", style: TextStyle(fontSize: 16, fontWeight: FontWeight.bold)),
              ),
            ),
            const SizedBox(height: 16),
            Center(
              child: TextButton(
                onPressed: () => Navigator.pop(context),
                child: Text("Cancel", style: TextStyle(color: Colors.white.withAlpha(150))),
              ),
            ),
            const SizedBox(height: 40),
          ],
        ),
      ),
    );
  }
}

// --- Local Widgets ---

class _SectionHeader extends StatelessWidget {
  final String title;
  const _SectionHeader({required this.title});

  @override
  Widget build(BuildContext context) {
    return Padding(
      padding: const EdgeInsets.only(bottom: 12, left: 4),
      child: Text(
        title,
        style: TextStyle(
          color: Colors.white.withAlpha(150),
          fontWeight: FontWeight.bold,
          fontSize: 12,
          letterSpacing: 1.2,
        ),
      ),
    );
  }
}

class _Label extends StatelessWidget {
  final String text;
  const _Label(this.text);

  @override
  Widget build(BuildContext context) {
    return Padding(
      padding: const EdgeInsets.only(bottom: 8, left: 2),
      child: Text(
        text,
        style: TextStyle(color: Colors.white.withAlpha(180), fontSize: 12, fontWeight: FontWeight.w600),
      ),
    );
  }
}

class _DateBox extends StatelessWidget {
  final String label;
  final DateTime date;

  const _DateBox({required this.label, required this.date});

  @override
  Widget build(BuildContext context) {
    return Container(
      padding: const EdgeInsets.all(12),
      decoration: BoxDecoration(
        color: Colors.black.withAlpha(50),
        borderRadius: BorderRadius.circular(8),
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Text(label, style: TextStyle(color: Colors.white.withAlpha(100), fontSize: 10, fontWeight: FontWeight.bold, letterSpacing: 1.0)),
          const SizedBox(height: 4),
          Text(
            DateFormat('MMM dd, yyyy').format(date),
            style: const TextStyle(color: Colors.white, fontFamily: 'Monospace', fontSize: 13),
          ),
        ],
      ),
    );
  }
}import 'package:flutter/material.dart';
import 'package:intl/intl.dart';
import '../services/database_service.dart';
import 'student_ledger_page.dart'; // Ensure this import exists for navigation

class FinancialListsPage extends StatelessWidget {
  final int initialIndex;

  const FinancialListsPage({super.key, this.initialIndex = 0});

  @override
  Widget build(BuildContext context) {
    return DefaultTabController(
      length: 2,
      initialIndex: initialIndex,
      child: Scaffold(
        backgroundColor: const Color(0xff121b22),
        appBar: AppBar(
          backgroundColor: const Color(0xff121b22),
          iconTheme: const IconThemeData(color: Colors.white),
          title: const Text(
            "Accounts Receivable",
            style: TextStyle(color: Colors.white, fontWeight: FontWeight.bold),
          ),
          bottom: const TabBar(
            indicatorColor: Color(0xff3498db),
            labelColor: Color(0xff3498db),
            unselectedLabelColor: Colors.grey,
            tabs: [
              Tab(text: "Outstanding Balances"),
              Tab(text: "Open Invoices"),
            ],
          ),
        ),
        body: const TabBarView(
          children: [
            _OutstandingBalancesView(),
            _OpenInvoicesView(),
          ],
        ),
      ),
    );
  }
}

// -----------------------------------------------------------------------------
// TAB 1: OUTSTANDING BALANCES (Student Centric)
// Shows students who owe money > 0
// -----------------------------------------------------------------------------
class _OutstandingBalancesView extends StatefulWidget {
  const _OutstandingBalancesView();

  @override
  State<_OutstandingBalancesView> createState() => _OutstandingBalancesViewState();
}

class _OutstandingBalancesViewState extends State<_OutstandingBalancesView> {
  List<Map<String, dynamic>> _students = [];
  bool _isLoading = true;

  @override
  void initState() {
    super.initState();
    _fetchDebtors();
  }

  Future<void> _fetchDebtors() async {
    final db = await DatabaseService.instance.database;
    // Query students where owed_total > 0
    final result = await db.query(
      'students',
      where: 'owed_total > 0',
      orderBy: 'owed_total DESC', // Highest debt first
    );
    
    if (mounted) {
      setState(() {
        _students = result;
        _isLoading = false;
      });
    }
  }

  @override
  Widget build(BuildContext context) {
    if (_isLoading) return const Center(child: CircularProgressIndicator());
    
    if (_students.isEmpty) {
      return const _EmptyState(
        icon: Icons.check_circle_outline,
        title: "All Clear!",
        subtitle: "No students currently owe money.",
      );
    }

    return ListView.builder(
      padding: const EdgeInsets.all(16),
      itemCount: _students.length,
      itemBuilder: (context, index) {
        final student = _students[index];
        final owed = (student['owed_total'] as num).toDouble();
        
        return Card(
          color: const Color(0xff1c2a35),
          margin: const EdgeInsets.only(bottom: 12),
          shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
          child: ListTile(
            contentPadding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
            leading: CircleAvatar(
              backgroundColor: const Color(0xffef5350).withAlpha(30),
              child: const Icon(Icons.person, color: Color(0xffef5350)),
            ),
            title: Text(
              student['full_name'],
              style: const TextStyle(color: Colors.white, fontWeight: FontWeight.bold),
            ),
            subtitle: Text(
              student['grade'] ?? 'No Grade',
              style: const TextStyle(color: Colors.grey),
            ),
            trailing: Column(
              mainAxisAlignment: MainAxisAlignment.center,
              crossAxisAlignment: CrossAxisAlignment.end,
              children: [
                Text(
                  "\$${owed.toStringAsFixed(2)}",
                  style: const TextStyle(
                    color: Color(0xffef5350),
                    fontSize: 16,
                    fontWeight: FontWeight.bold
                  ),
                ),
                const Text("OVERDUE", style: TextStyle(color: Colors.grey, fontSize: 10)),
              ],
            ),
            onTap: () {
              // Navigate to Student Ledger to take action
               Navigator.of(context).push(
                MaterialPageRoute(
                  builder: (context) => StudentLedgerPage(studentId: student['id']),
                ),
              );
            },
          ),
        );
      },
    );
  }
}

// -----------------------------------------------------------------------------
// TAB 2: OPEN INVOICES (Bill Centric)
// Shows specific bills that are not fully paid
// -----------------------------------------------------------------------------
class _OpenInvoicesView extends StatefulWidget {
  const _OpenInvoicesView();

  @override
  State<_OpenInvoicesView> createState() => _OpenInvoicesViewState();
}

class _OpenInvoicesViewState extends State<_OpenInvoicesView> {
  List<Map<String, dynamic>> _invoices = [];
  bool _isLoading = true;

  @override
  void initState() {
    super.initState();
    _fetchInvoices();
  }

  Future<void> _fetchInvoices() async {
    final db = await DatabaseService.instance.database;
    // Query bills where paid_amount < total_amount
    // We join with students to get the name
    final result = await db.rawQuery('''
      SELECT 
        bills.*, 
        students.full_name as student_name 
      FROM bills
      INNER JOIN students ON bills.student_id = students.id
      WHERE bills.paid_amount < bills.total_amount
      ORDER BY bills.created_at DESC
    ''');

    if (mounted) {
      setState(() {
        _invoices = result;
        _isLoading = false;
      });
    }
  }

  @override
  Widget build(BuildContext context) {
    if (_isLoading) return const Center(child: CircularProgressIndicator());

    if (_invoices.isEmpty) {
      return const _EmptyState(
        icon: Icons.receipt_long,
        title: "No Open Invoices",
        subtitle: "All generated bills have been fully paid.",
      );
    }

    return ListView.builder(
      padding: const EdgeInsets.all(16),
      itemCount: _invoices.length,
      itemBuilder: (context, index) {
        final bill = _invoices[index];
        final total = (bill['total_amount'] as num).toDouble();
        final paid = (bill['paid_amount'] as num).toDouble();
        final balance = total - paid;
        
        // Safety check for date
        String dateStr = "Unknown Date";
        if (bill['created_at'] != null) {
          final date = DateTime.fromMillisecondsSinceEpoch(bill['created_at'] as int);
          dateStr = DateFormat('MMM dd, yyyy').format(date);
        }

        return Card(
          color: const Color(0xff1c2a35),
          margin: const EdgeInsets.only(bottom: 12),
          shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
          child: Padding(
            padding: const EdgeInsets.all(16.0),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Row(
                  mainAxisAlignment: MainAxisAlignment.spaceBetween,
                  children: [
                    Text(
                      bill['title'] ?? 'Tuition Fee',
                      style: const TextStyle(color: Colors.white, fontWeight: FontWeight.bold, fontSize: 16),
                    ),
                    Container(
                      padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
                      decoration: BoxDecoration(
                        color: const Color(0xff42a5f5).withAlpha(30),
                        borderRadius: BorderRadius.circular(8),
                      ),
                      child: Text(
                        "Inv #${bill['id'].toString().substring(0,4)}",
                        style: const TextStyle(color: Color(0xff42a5f5), fontSize: 12, fontWeight: FontWeight.bold),
                      ),
                    ),
                  ],
                ),
                const SizedBox(height: 4),
                Text(
                  "Billed to: ${bill['student_name']}",
                  style: const TextStyle(color: Colors.grey, fontSize: 14),
                ),
                const SizedBox(height: 12),
                const Divider(color: Colors.white10),
                const SizedBox(height: 8),
                Row(
                  mainAxisAlignment: MainAxisAlignment.spaceBetween,
                  children: [
                    Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        Text("Issued: $dateStr", style: const TextStyle(color: Colors.white54, fontSize: 12)),
                        const SizedBox(height: 4),
                        Text(
                          "Total: \$${total.toStringAsFixed(2)}",
                          style: const TextStyle(color: Colors.white70),
                        ),
                      ],
                    ),
                    Column(
                      crossAxisAlignment: CrossAxisAlignment.end,
                      children: [
                        const Text("Balance Due", style: TextStyle(color: Colors.white54, fontSize: 12)),
                        const SizedBox(height: 4),
                        Text(
                          "\$${balance.toStringAsFixed(2)}",
                          style: const TextStyle(color: Color(0xffef5350), fontSize: 18, fontWeight: FontWeight.bold),
                        ),
                      ],
                    ),
                  ],
                ),
              ],
            ),
          ),
        );
      },
    );
  }
}

// -----------------------------------------------------------------------------
// HELPER: Empty State
// -----------------------------------------------------------------------------
class _EmptyState extends StatelessWidget {
  final IconData icon;
  final String title;
  final String subtitle;

  const _EmptyState({required this.icon, required this.title, required this.subtitle});

  @override
  Widget build(BuildContext context) {
    return Center(
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          Icon(icon, size: 80, color: Colors.white24),
          const SizedBox(height: 16),
          Text(title, style: const TextStyle(color: Colors.white, fontSize: 20, fontWeight: FontWeight.bold)),
          const SizedBox(height: 8),
          Text(subtitle, style: const TextStyle(color: Colors.white54)),
        ],
      ),
    );
  }
}// lib/pages/register_student_page.dart

import 'package:flutter/material.dart';
import 'package:intl/intl.dart';
import 'package:supabase_flutter/supabase_flutter.dart';
import '../services/database_service.dart';
import '../utils/subject_selection_modal.dart';

class RegisterStudentPage extends StatefulWidget {
  const RegisterStudentPage({super.key});
  static const String routeName = '/register_student';

  @override
  State<RegisterStudentPage> createState() => _RegisterStudentPageState();
}

class _RegisterStudentPageState extends State<RegisterStudentPage> {
  final _formKey = GlobalKey<FormState>();
  
  // -- Controllers --
  final _nameController = TextEditingController();
  final _contactController = TextEditingController();
  final _feeController = TextEditingController();
  final _initialPayController = TextEditingController();

  // -- State --
  String _selectedGrade = 'FORM 1';
  String _billingType = 'monthly'; 
  bool _isActive = true;
  bool _isSaving = false;
  List<String> _selectedSubjects = [];

  // Dates
  DateTime _registrationDate = DateTime.now();
  // Default next billing to 1 month from now (adjusted for safe days)
  late DateTime _nextBillingDate;

  // Grade Options
  final List<String> _grades = [
    'ECD A', 'ECD B', 
    'GRADE 1', 'GRADE 2', 'GRADE 3', 'GRADE 4', 'GRADE 5', 'GRADE 6', 'GRADE 7',
    'FORM 1', 'FORM 2', 'FORM 3', 'FORM 4', 'LOWER 6', 'UPPER 6'
  ];

  @override
  void initState() {
    super.initState();
    // Initialize next billing date to next month, ensuring day <= 28
    final now = DateTime.now();
    int safeDay = now.day > 28 ? 1 : now.day;
    int nextMonth = now.month == 12 ? 1 : now.month + 1;
    int nextYear = now.month == 12 ? now.year + 1 : now.year;
    _nextBillingDate = DateTime(nextYear, nextMonth, safeDay);
  }

  // --- Logic: Date Pickers ---

  Future<void> _pickRegistrationDate() async {
    final picked = await showDatePicker(
      context: context,
      initialDate: _registrationDate,
      firstDate: DateTime(2000),
      lastDate: DateTime.now().add(const Duration(days: 365)),
    );
    if (picked != null) {
      setState(() => _registrationDate = picked);
    }
  }

  Future<void> _pickBillingDate() async {
    final picked = await showDatePicker(
      context: context,
      initialDate: _nextBillingDate,
      firstDate: DateTime.now(),
      lastDate: DateTime.now().add(const Duration(days: 365 * 2)),
      // DISABLE 29, 30, 31 to ensure consistent monthly billing cycles
      selectableDayPredicate: (DateTime val) => val.day <= 28,
    );
    if (picked != null) {
      setState(() => _nextBillingDate = picked);
    }
  }

  // --- Logic: Save Student ---
  Future<void> _registerStudent() async {
    if (!_formKey.currentState!.validate()) return;

    // 1. Get Admin UID from Supabase
    final user = Supabase.instance.client.auth.currentUser;
    if (user == null) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('Error: You must be logged in to register students.')),
      );
      return;
    }

    setState(() => _isSaving = true);

    try {
      final db = DatabaseService.instance;
      
      final defaultFee = double.tryParse(_feeController.text) ?? 0.0;
      final initialPay = double.tryParse(_initialPayController.text) ?? 0.0;

      // 2. Prepare Data Map
      final studentData = {
        'full_name': _nameController.text.trim(),
        'parent_contact': _contactController.text.trim(),
        'grade': _selectedGrade,
        'registration_date': _registrationDate.toIso8601String(),
        'billing_date': _nextBillingDate.toIso8601String(), // NEW FIELD
        'billing_type': _billingType,
        'default_fee': defaultFee,
        'is_active': _isActive ? 1 : 0,
        'subjects': _selectedSubjects.join(','),
        'admin_uid': user.id, // AUTH ID
      };

      // 3. Insert Student
      final studentId = await db.createStudent(
        studentData, 
        createBackdatedBills: false 
      );

      // 4. Generate the "Initial Bill" (Current Period)
      // We label this bill based on the registration date
      await db.createBillForStudent(
        studentId: studentId,
        totalAmount: defaultFee,
        billType: _billingType,
        createdAt: _registrationDate, // Bill date is Reg date
        cycleStart: _registrationDate,
        adminUid: user.id,
        monthYear: _billingType == 'monthly' 
            ? '${_registrationDate.year}-${_registrationDate.month.toString().padLeft(2,'0')}' 
            : null,
      );

      // 5. Record Initial Payment
      if (initialPay > 0) {
        final bills = await db.getStudentBills(studentId);
        if (bills.isNotEmpty) {
          final billId = bills.first['id'] as String;
          await db.recordPayment(
            billId: billId,
            studentId: studentId,
            amount: initialPay,
            datePaid: DateTime.now(),
            method: 'Cash',
            adminUid: user.id,
          );
        }
      }

      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(content: Text('Student registered successfully!')),
        );
        Navigator.pop(context);
      }
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('Error: $e'), backgroundColor: Colors.red),
        );
      }
    } finally {
      if (mounted) setState(() => _isSaving = false);
    }
  }

  void _openSubjectPicker() {
    showModalBottomSheet(
      context: context,
      isScrollControlled: true,
      backgroundColor: Colors.transparent,
      builder: (context) => SubjectSelectionModal(
        selectedSubjects: _selectedSubjects,
        onConfirmed: (List<String> newSelection) {
          setState(() => _selectedSubjects = newSelection);
        },
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;
    
    final standardBoxDecoration = BoxDecoration(
      color: colorScheme.surface,
      borderRadius: BorderRadius.circular(12.0),
      border: Border.all(color: colorScheme.outlineVariant, width: 1.0),
    );

    return Scaffold(
      backgroundColor: colorScheme.surface,
      appBar: AppBar(
        title: const Text('Add Student'),
        centerTitle: true,
        backgroundColor: colorScheme.surface,
        elevation: 0,
      ),
      body: Center(
        child: ConstrainedBox(
          constraints: const BoxConstraints(maxWidth: 600),
          child: SingleChildScrollView(
            padding: const EdgeInsets.all(20.0),
            child: Form(
              key: _formKey,
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.stretch,
                children: [
                  _SectionHeader(title: "PERSONAL INFORMATION"),
                  
                  _buildTextField(
                    label: "Full Name",
                    controller: _nameController,
                    hint: "e.g. John Smith",
                    decoration: standardBoxDecoration,
                    validator: (v) => v!.isEmpty ? "Name required" : null,
                  ),
                  const SizedBox(height: 12),
                  _buildTextField(
                    label: "Parent Contact",
                    controller: _contactController,
                    hint: "+263 7...",
                    icon: Icons.phone_outlined,
                    decoration: standardBoxDecoration,
                    inputType: TextInputType.phone,
                  ),

                  const SizedBox(height: 24),
                  _SectionHeader(title: "ACADEMIC"),
                  
                  // Grade Dropdown
                  Container(
                    padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 4),
                    decoration: standardBoxDecoration,
                    child: DropdownButtonHideUnderline(
                      child: DropdownButton<String>(
                        value: _selectedGrade,
                        isExpanded: true,
                        dropdownColor: colorScheme.surfaceContainer,
                        icon: Icon(Icons.arrow_forward_ios, size: 14, color: colorScheme.onSurfaceVariant),
                        items: _grades.map((g) => DropdownMenuItem(value: g, child: Text(g))).toList(),
                        onChanged: (v) => setState(() => _selectedGrade = v!),
                      ),
                    ),
                  ),
                  const SizedBox(height: 12),

                  // Subject Selector
                  GestureDetector(
                    onTap: _openSubjectPicker,
                    child: Container(
                      padding: const EdgeInsets.all(16),
                      decoration: standardBoxDecoration,
                      child: Column(
                        crossAxisAlignment: CrossAxisAlignment.start,
                        children: [
                          Row(
                            mainAxisAlignment: MainAxisAlignment.spaceBetween,
                            children: [
                              Text("Enrolled Subjects", style: TextStyle(color: colorScheme.onSurfaceVariant)),
                              Icon(Icons.add, color: colorScheme.primary),
                            ],
                          ),
                          if (_selectedSubjects.isNotEmpty) ...[
                            const SizedBox(height: 10),
                            Wrap(
                              spacing: 8,
                              runSpacing: 8,
                              children: _selectedSubjects.map((s) => Chip(
                                label: Text(s, style: const TextStyle(fontSize: 11)),
                                backgroundColor: colorScheme.primaryContainer,
                                labelPadding: const EdgeInsets.symmetric(horizontal: 4),
                                visualDensity: VisualDensity.compact,
                                side: BorderSide.none,
                                onDeleted: () => setState(() => _selectedSubjects.remove(s)),
                              )).toList(),
                            )
                          ]
                        ],
                      ),
                    ),
                  ),
                  const SizedBox(height: 12),

                  // Registration Date Picker
                  GestureDetector(
                    onTap: _pickRegistrationDate,
                    child: Container(
                      padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 16),
                      decoration: standardBoxDecoration,
                      child: Row(
                        mainAxisAlignment: MainAxisAlignment.spaceBetween,
                        children: [
                          Text("Registration Date", style: TextStyle(color: colorScheme.onSurfaceVariant)),
                          Row(
                            children: [
                              Text(
                                DateFormat('MMM dd, yyyy').format(_registrationDate),
                                style: TextStyle(color: colorScheme.primary, fontWeight: FontWeight.bold),
                              ),
                              const SizedBox(width: 8),
                              Icon(Icons.calendar_today, size: 16, color: colorScheme.primary),
                            ],
                          ),
                        ],
                      ),
                    ),
                  ),

                  const SizedBox(height: 24),
                  _SectionHeader(title: "FINANCIALS"),

                  // Billing Frequency
                  Container(
                    decoration: standardBoxDecoration,
                    child: Row(
                      children: ['termly', 'monthly', 'yearly'].map((type) {
                        final isSelected = _billingType == type;
                        return Expanded(
                          child: GestureDetector(
                            onTap: () => setState(() => _billingType = type),
                            child: Container(
                              padding: const EdgeInsets.symmetric(vertical: 14),
                              decoration: BoxDecoration(
                                color: isSelected ? colorScheme.primary : Colors.transparent,
                                borderRadius: BorderRadius.circular(11),
                              ),
                              alignment: Alignment.center,
                              child: Text(
                                type.toUpperCase(),
                                style: TextStyle(
                                  fontWeight: FontWeight.bold,
                                  fontSize: 12,
                                  color: isSelected ? Colors.white : colorScheme.onSurfaceVariant,
                                ),
                              ),
                            ),
                          ),
                        );
                      }).toList(),
                    ),
                  ),
                  const SizedBox(height: 12),

                  // Fee Amount
                  _buildTextField(
                    label: "Recurring Fee Amount",
                    controller: _feeController,
                    prefix: "\$ ",
                    inputType: const TextInputType.numberWithOptions(decimal: true),
                    decoration: standardBoxDecoration,
                    validator: (v) => v!.isEmpty ? "Fee required" : null,
                  ),
                  const SizedBox(height: 12),

                  // Initial Pay & Next Billing Row
                  Row(
                    children: [
                      // Initial Payment
                      Expanded(
                        flex: 4,
                        child: _buildTextField(
                          label: "Initial Payment",
                          controller: _initialPayController,
                          prefix: "\$ ",
                          hint: "0.00",
                          inputType: const TextInputType.numberWithOptions(decimal: true),
                          decoration: standardBoxDecoration,
                        ),
                      ),
                      const SizedBox(width: 12),
                      
                      // Next Billing Date
                      Expanded(
                        flex: 5,
                        child: GestureDetector(
                          onTap: _pickBillingDate,
                          child: Container(
                            height: 60, // Match typical text field height
                            padding: const EdgeInsets.symmetric(horizontal: 12),
                            decoration: standardBoxDecoration,
                            child: Column(
                              mainAxisAlignment: MainAxisAlignment.center,
                              crossAxisAlignment: CrossAxisAlignment.start,
                              children: [
                                Text(
                                  "Next Bill Date",
                                  style: TextStyle(fontSize: 11, color: colorScheme.onSurfaceVariant),
                                ),
                                const SizedBox(height: 2),
                                Row(
                                  children: [
                                    Expanded(
                                      child: Text(
                                        DateFormat('MMM dd, yyyy').format(_nextBillingDate),
                                        style: TextStyle(
                                          fontWeight: FontWeight.bold, 
                                          color: colorScheme.onSurface,
                                          fontSize: 13
                                        ),
                                        overflow: TextOverflow.ellipsis,
                                      ),
                                    ),
                                    Icon(Icons.event_repeat, size: 16, color: colorScheme.primary),
                                  ],
                                ),
                              ],
                            ),
                          ),
                        ),
                      ),
                    ],
                  ),
                  
                  const SizedBox(height: 8),
                  Padding(
                    padding: const EdgeInsets.only(left: 4),
                    child: Text(
                      "* Billing dates restricted to days 1-28 to prevent cycle errors.",
                      style: TextStyle(fontSize: 11, color: colorScheme.onSurfaceVariant.withAlpha(128)),
                    ),
                  ),

                  const SizedBox(height: 32),
                  
                  // Save Button
                  SizedBox(
                    height: 56,
                    child: ElevatedButton(
                      onPressed: _isSaving ? null : _registerStudent,
                      style: ElevatedButton.styleFrom(
                        backgroundColor: colorScheme.primary,
                        foregroundColor: Colors.white,
                        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
                        elevation: 0,
                      ),
                      child: _isSaving 
                        ? const CircularProgressIndicator(color: Colors.white)
                        : const Text("SAVE STUDENT", style: TextStyle(fontSize: 16, fontWeight: FontWeight.bold, letterSpacing: 1)),
                    ),
                  ),
                  const SizedBox(height: 30),
                ],
              ),
            ),
          ),
        ),
      ),
    );
  }

  Widget _buildTextField({
    required String label,
    required TextEditingController controller,
    required BoxDecoration decoration,
    String? hint,
    String? prefix,
    IconData? icon,
    TextInputType inputType = TextInputType.text,
    String? Function(String?)? validator,
  }) {
    return Container(
      decoration: decoration,
      child: TextFormField(
        controller: controller,
        keyboardType: inputType,
        validator: validator,
        style: TextStyle(color: Theme.of(context).colorScheme.onSurface),
        decoration: InputDecoration(
          labelText: label,
          hintText: hint,
          prefixText: prefix,
          suffixIcon: icon != null ? Icon(icon, color: Colors.grey, size: 20) : null,
          border: InputBorder.none,
          contentPadding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
          labelStyle: const TextStyle(color: Colors.grey),
          prefixStyle: TextStyle(color: Theme.of(context).colorScheme.onSurface),
        ),
      ),
    );
  }
}

class _SectionHeader extends StatelessWidget {
  final String title;
  const _SectionHeader({required this.title});

  @override
  Widget build(BuildContext context) {
    return Padding(
      padding: const EdgeInsets.only(bottom: 12.0, left: 4),
      child: Text(
        title,
        style: TextStyle(
          color: Theme.of(context).colorScheme.primary,
          fontWeight: FontWeight.bold,
          letterSpacing: 1.2,
          fontSize: 12,
        ),
      ),
    );
  }
}// lib/pages/expenses_dashboard_page.dart

import 'package:fl_chart/fl_chart.dart';
import 'package:flutter/material.dart';
import 'package:intl/intl.dart';
import 'package:uuid/uuid.dart'; // Ensure you have uuid in pubspec
import '../services/database_service.dart';

class ExpensesDashboardPage extends StatefulWidget {
  const ExpensesDashboardPage({super.key});

  @override
  State<ExpensesDashboardPage> createState() => _ExpensesDashboardPageState();
}

class _ExpensesDashboardPageState extends State<ExpensesDashboardPage> {
  // Filter State
  String _selectedFilter = 'Monthly'; // Default
  final List<String> _filters = ['Today', 'Weekly', 'Monthly', 'Yearly'];

  // Data State
  // ignore: unused_field
  List<Map<String, dynamic>> _expenses = [];
  bool _isLoading = true;
  double _totalAmount = 0.0;
  double _avgAmount = 0.0;

  // Chart Data
  List<double> _chartValues = List.filled(7, 0.0);
  Map<String, double> _categoryData = {};

  @override
  void initState() {
    super.initState();
    _fetchExpenses();
  }

  /// Fetch expenses based on the selected filter
  Future<void> _fetchExpenses() async {
    setState(() => _isLoading = true);
    final db = await DatabaseService.instance.database;
    
    // Determine date range
    DateTime now = DateTime.now();
    DateTime startDate;
    
    switch (_selectedFilter) {
      case 'Today':
        startDate = DateTime(now.year, now.month, now.day);
        break;
      case 'Weekly':
        // Last 7 days
        startDate = now.subtract(const Duration(days: 6));
        startDate = DateTime(startDate.year, startDate.month, startDate.day);
        break;
      case 'Monthly':
        // Start of current month
        startDate = DateTime(now.year, now.month, 1);
        break;
      case 'Yearly':
        // Start of current year
        startDate = DateTime(now.year, 1, 1);
        break;
      default:
        startDate = DateTime(now.year, now.month, 1);
    }

    final startDateStr = DateFormat('yyyy-MM-dd').format(startDate);

    // Query DB
    final result = await db.query(
      'expenses',
      where: 'date_incurred >= ?',
      whereArgs: [startDateStr],
      orderBy: 'date_incurred DESC',
    );

    // Process Data
    double total = 0.0;
    Map<String, double> cats = {};
    List<double> chartBuckets = List.filled(7, 0.0); // Simple 7-bucket distribution for now

    for (var row in result) {
      final amt = (row['amount'] as num).toDouble();
      final cat = (row['category'] as String?) ?? 'Other';
      final dateStr = row['date_incurred'] as String;
      final date = DateTime.parse(dateStr);
      
      total += amt;
      cats[cat] = (cats[cat] ?? 0) + amt;

      // Simple Chart Logic: Distribute based on day of week (0-6)
      // This works best for "Weekly", for others it just aggregates by weekday
      // A more complex logic would vary buckets based on filter (e.g. 12 buckets for Year)
      if (_selectedFilter == 'Weekly' || _selectedFilter == 'Today') {
        int dayIndex = date.weekday - 1; // Mon=0, Sun=6
        chartBuckets[dayIndex] += amt;
      } else {
        // For Month/Year, maybe just arbitrary buckets for visual flow or first 7 chunks
        // keeping simple weekday aggregation for visual demo
        int dayIndex = date.weekday - 1; 
        chartBuckets[dayIndex] += amt;
      }
    }

    // Sort categories by value desc
    final sortedCats = Map.fromEntries(
      cats.entries.toList()..sort((e1, e2) => e2.value.compareTo(e1.value))
    );

    if (mounted) {
      setState(() {
        _expenses = result;
        _totalAmount = total;
        _categoryData = sortedCats;
        _chartValues = chartBuckets;
        
        // Avg calc
        int daysDivisor = 1;
        if (_selectedFilter == 'Weekly') daysDivisor = 7;
        if (_selectedFilter == 'Monthly') daysDivisor = now.day; // Avg per day so far
        if (_selectedFilter == 'Yearly') daysDivisor = 365;
        if (_totalAmount > 0) {
           _avgAmount = _totalAmount / daysDivisor;
        } else {
          _avgAmount = 0.0;
        }
        
        _isLoading = false;
      });
    }
  }

  void _openAddExpenseSheet() async {
    final result = await showModalBottomSheet(
      context: context,
      isScrollControlled: true,
      backgroundColor: const Color(0xff1c2a35),
      shape: const RoundedRectangleBorder(
        borderRadius: BorderRadius.vertical(top: Radius.circular(24)),
      ),
      builder: (context) => const _AddExpenseSheetContent(),
    );

    // If returned true, refresh data
    if (result == true) {
      _fetchExpenses();
    }
  }

  @override
  Widget build(BuildContext context) {
    const bgColor = Color(0xff121b22);
    const cardColor = Color(0xff1c2a35);
    const primaryColor = Color(0xff3498db);

    return Scaffold(
      backgroundColor: bgColor,
      floatingActionButton: FloatingActionButton(
        backgroundColor: primaryColor,
        onPressed: _openAddExpenseSheet,
        child: const Icon(Icons.add, color: Colors.white),
      ),
      appBar: AppBar(
        backgroundColor: bgColor,
        title: const Text("Expenses Dashboard", style: TextStyle(color: Colors.white, fontWeight: FontWeight.bold)),
        iconTheme: const IconThemeData(color: Colors.white),
        actions: [
          // Filter Dropdown
          Padding(
            padding: const EdgeInsets.only(right: 16.0),
            child: DropdownButtonHideUnderline(
              child: DropdownButton<String>(
                dropdownColor: cardColor,
                value: _selectedFilter,
                icon: const Icon(Icons.calendar_today, color: Colors.white54, size: 20),
                style: const TextStyle(color: Colors.white, fontWeight: FontWeight.bold),
                items: _filters.map((f) => DropdownMenuItem(value: f, child: Text(f))).toList(),
                onChanged: (val) {
                  if (val != null) {
                    setState(() => _selectedFilter = val);
                    _fetchExpenses();
                  }
                },
              ),
            ),
          )
        ],
      ),
      body: _isLoading 
        ? const Center(child: CircularProgressIndicator()) 
        : SingleChildScrollView(
          padding: const EdgeInsets.all(20),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              // 1. Overview Cards
              Row(
                children: [
                  Expanded(child: _ExpenseSummaryCard(title: "Total ($_selectedFilter)", amount: _totalAmount, color: const Color(0xffef5350))),
                  const SizedBox(width: 16),
                  Expanded(child: _ExpenseSummaryCard(title: "Avg/Day", amount: _avgAmount, color: const Color(0xffffa726))),
                ],
              ),
              const SizedBox(height: 24),

              // 2. Bar Chart
              Text("Spending Trend ($_selectedFilter)", style: const TextStyle(color: Colors.white, fontSize: 16, fontWeight: FontWeight.bold)),
              const SizedBox(height: 16),
              Container(
                height: 250,
                padding: const EdgeInsets.all(16),
                decoration: BoxDecoration(color: cardColor, borderRadius: BorderRadius.circular(20)),
                child: BarChart(
                  BarChartData(
                    gridData: const FlGridData(show: false),
                    titlesData: FlTitlesData(
                      leftTitles: const AxisTitles(sideTitles: SideTitles(showTitles: false)),
                      topTitles: const AxisTitles(sideTitles: SideTitles(showTitles: false)),
                      rightTitles: const AxisTitles(sideTitles: SideTitles(showTitles: false)),
                      bottomTitles: AxisTitles(
                        sideTitles: SideTitles(
                          showTitles: true,
                          getTitlesWidget: (val, meta) {
                            const days = ['M', 'T', 'W', 'T', 'F', 'S', 'S'];
                            if (val.toInt() < days.length) {
                              return Padding(
                                padding: const EdgeInsets.only(top: 8),
                                child: Text(days[val.toInt()], style: const TextStyle(color: Colors.grey, fontSize: 12)),
                              );
                            }
                            return const SizedBox();
                          },
                        ),
                      ),
                    ),
                    borderData: FlBorderData(show: false),
                    barGroups: _chartValues.asMap().entries.map((e) {
                      return BarChartGroupData(
                        x: e.key,
                        barRods: [
                          BarChartRodData(
                            toY: e.value,
                            color: e.value > (_totalAmount/7) * 1.5 ? const Color(0xffef5350) : primaryColor, // Highlight spikes
                            width: 16,
                            borderRadius: BorderRadius.circular(4),
                          )
                        ],
                      );
                    }).toList(),
                  ),
                ),
              ),

              const SizedBox(height: 24),

              // 3. Breakdown
              const Text("Category Breakdown", style: TextStyle(color: Colors.white, fontSize: 16, fontWeight: FontWeight.bold)),
              const SizedBox(height: 16),
              if (_categoryData.isEmpty)
                const Padding(
                  padding: EdgeInsets.all(20),
                  child: Center(child: Text("No expenses found for this period.", style: TextStyle(color: Colors.grey))),
                )
              else
                ..._categoryData.entries.map((e) => _CategoryRow(category: e.key, amount: e.value)),

              const SizedBox(height: 80),
            ],
          ),
        ),
    );
  }
}

// --- WIDGETS ---

class _ExpenseSummaryCard extends StatelessWidget {
  final String title;
  final double amount;
  final Color color;

  const _ExpenseSummaryCard({required this.title, required this.amount, required this.color});

  @override
  Widget build(BuildContext context) {
    return Container(
      padding: const EdgeInsets.all(20),
      decoration: BoxDecoration(
        color: const Color(0xff1c2a35),
        borderRadius: BorderRadius.circular(20),
        border: Border.all(color: Colors.white.withAlpha(10)),
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Text(title, style: TextStyle(color: Colors.grey.shade400, fontSize: 12)),
          const SizedBox(height: 8),
          Text(
            "\$${amount.toStringAsFixed(0)}",
            style: TextStyle(color: color, fontSize: 24, fontWeight: FontWeight.bold),
          ),
        ],
      ),
    );
  }
}

class _CategoryRow extends StatelessWidget {
  final String category;
  final double amount;

  const _CategoryRow({required this.category, required this.amount});

  @override
  Widget build(BuildContext context) {
    return Container(
      margin: const EdgeInsets.only(bottom: 12),
      padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
      decoration: BoxDecoration(
        color: const Color(0xff1c2a35),
        borderRadius: BorderRadius.circular(12),
      ),
      child: Row(
        mainAxisAlignment: MainAxisAlignment.spaceBetween,
        children: [
          Row(
            children: [
              Container(
                width: 10, height: 10,
                decoration: BoxDecoration(shape: BoxShape.circle, color: Colors.blue.withAlpha(150)),
              ),
              const SizedBox(width: 12),
              Text(category, style: const TextStyle(color: Colors.white, fontSize: 14)),
            ],
          ),
          Text("\$${amount.toStringAsFixed(2)}", style: const TextStyle(color: Colors.white70, fontWeight: FontWeight.bold)),
        ],
      ),
    );
  }
}

// --- ADD EXPENSE FORM (STATEFUL FOR LOGIC) ---

class _AddExpenseSheetContent extends StatefulWidget {
  const _AddExpenseSheetContent();

  @override
  State<_AddExpenseSheetContent> createState() => _AddExpenseSheetContentState();
}

class _AddExpenseSheetContentState extends State<_AddExpenseSheetContent> {
  final _amountCtrl = TextEditingController();
  final _descCtrl = TextEditingController();
  
  String _selectedCategory = 'Supplies';
  final List<String> _categories = [
    'Supplies', 'Maintenance', 'Utilities', 'Salaries', 'Events', 'Other'
  ];
  
  bool _isSaving = false;

  Future<void> _saveExpense() async {
    final amount = double.tryParse(_amountCtrl.text);
    if (amount == null || amount <= 0) {
      ScaffoldMessenger.of(context).showSnackBar(const SnackBar(content: Text("Invalid Amount")));
      return;
    }
    if (_descCtrl.text.isEmpty) {
      ScaffoldMessenger.of(context).showSnackBar(const SnackBar(content: Text("Description Required")));
      return;
    }

    setState(() => _isSaving = true);

    try {
      final db = await DatabaseService.instance.database;
      
      // Assuming you have a school_id or using a default. 
      // For single-user simplicity on mobile, we can generate one or query user profile.
      // Here we assume a simple insert into local DB first.
      
      await db.insert('expenses', {
        'id': const Uuid().v4(),
        'school_id': 'local_school_id', // Placeholder or fetch from prefs
        'title': _descCtrl.text.trim(),
        'category': _selectedCategory,
        'amount': amount,
        'date_incurred': DateFormat('yyyy-MM-dd').format(DateTime.now()),
        'description': _descCtrl.text.trim(),
        'created_at': DateTime.now().millisecondsSinceEpoch,
      });

      if (mounted) {
        Navigator.pop(context, true); // Return true to trigger refresh
        ScaffoldMessenger.of(context).showSnackBar(const SnackBar(content: Text("Expense Saved")));
      }
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(SnackBar(content: Text("Error: $e")));
      }
    } finally {
      if (mounted) setState(() => _isSaving = false);
    }
  }

  @override
  Widget build(BuildContext context) {
    return Padding(
      padding: EdgeInsets.only(
        left: 20, right: 20, top: 20, 
        bottom: MediaQuery.of(context).viewInsets.bottom + 20
      ),
      child: Column(
        mainAxisSize: MainAxisSize.min,
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          const Text("New Expense", style: TextStyle(color: Colors.white, fontSize: 20, fontWeight: FontWeight.bold)),
          const SizedBox(height: 20),
          
          // Amount
          TextField(
            controller: _amountCtrl,
            style: const TextStyle(color: Colors.white),
            decoration: InputDecoration(
              filled: true,
              fillColor: const Color(0xff121b22),
              hintText: "Amount (e.g. 50.00)",
              hintStyle: const TextStyle(color: Colors.grey),
              prefixIcon: const Icon(Icons.attach_money, color: Colors.grey),
              border: OutlineInputBorder(borderRadius: BorderRadius.circular(12), borderSide: BorderSide.none),
            ),
            keyboardType: const TextInputType.numberWithOptions(decimal: true),
          ),
          const SizedBox(height: 12),
          
          // Description
          TextField(
            controller: _descCtrl,
            style: const TextStyle(color: Colors.white),
            decoration: InputDecoration(
              filled: true,
              fillColor: const Color(0xff121b22),
              hintText: "Description (e.g. Printer Paper)",
              hintStyle: const TextStyle(color: Colors.grey),
              prefixIcon: const Icon(Icons.description, color: Colors.grey),
              border: OutlineInputBorder(borderRadius: BorderRadius.circular(12), borderSide: BorderSide.none),
            ),
          ),
          const SizedBox(height: 12),

          // Category Selector
          Container(
            padding: const EdgeInsets.symmetric(horizontal: 12),
            decoration: BoxDecoration(
              color: const Color(0xff121b22),
              borderRadius: BorderRadius.circular(12),
            ),
            child: DropdownButtonHideUnderline(
              child: DropdownButton<String>(
                value: _selectedCategory,
                isExpanded: true,
                dropdownColor: const Color(0xff121b22),
                icon: const Icon(Icons.category, color: Colors.grey),
                style: const TextStyle(color: Colors.white),
                items: _categories.map((c) => DropdownMenuItem(value: c, child: Text(c))).toList(),
                onChanged: (val) {
                  if (val != null) setState(() => _selectedCategory = val);
                },
              ),
            ),
          ),
          
          const SizedBox(height: 24),
          
          // Save Button
          SizedBox(
            width: double.infinity,
            height: 50,
            child: ElevatedButton(
              onPressed: _isSaving ? null : _saveExpense,
              style: ElevatedButton.styleFrom(
                backgroundColor: const Color(0xff3498db),
                disabledBackgroundColor: Colors.grey.withAlpha(50),
              ),
              child: _isSaving 
                ? const SizedBox(height: 20, width: 20, child: CircularProgressIndicator(color: Colors.white, strokeWidth: 2))
                : const Text("Save Record", style: TextStyle(color: Colors.white, fontWeight: FontWeight.bold)),
            ),
          ),
        ],
      ),
    );
  }
}// lib/pages/finances_page.dart

import 'package:fees_up/pages/billing_settings_page.dart';
import 'package:fees_up/pages/expenses_dashboard_page.dart';
import 'package:fees_up/pages/financial_lists_page.dart';
import 'package:fees_up/pages/record_income_sheet.dart';
import 'package:fees_up/pages/revenue_analytics_page.dart';
import 'package:fees_up/pages/student_ledger_page.dart';
import 'package:fees_up/providers/finances_provider.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:intl/intl.dart';

class FinancesPage extends ConsumerWidget {
  const FinancesPage({super.key});

  // --- HELPER: Generic Navigation to Placeholder ---
  void _navigateToPlaceholder(BuildContext context, String title) {
    Navigator.of(context).push(
      MaterialPageRoute(builder: (context) => _PlaceholderPage(title: title)),
    );
  }

  // --- ACTIONS ---

  void _handleDownloadReport(BuildContext context) {
    _navigateToPlaceholder(context, "Download Summary PDF");
  }

  void _handleRevenueClick(BuildContext context) {
  Navigator.of(context).push(
    MaterialPageRoute(builder: (context) => const RevenueAnalyticsPage()),
  );
}

  void _handleOutstandingClick(BuildContext context) {
    Navigator.of(context).push(
      MaterialPageRoute(
        // Open Tab 0 (Outstanding)
        builder: (context) => const FinancialListsPage(initialIndex: 0),
      ),
    );
  }

  void _handleOpenInvoicesClick(BuildContext context) {
    Navigator.of(context).push(
      MaterialPageRoute(
        // Open Tab 1 (Invoices)
        builder: (context) => const FinancialListsPage(initialIndex: 1),
      ),
    );
  }

  // -- Quick Actions --

  void _actionAddExpense(BuildContext context) {
    // Navigate to the new Expenses Dashboard which handles viewing and adding
    Navigator.of(context).push(
      MaterialPageRoute(builder: (context) => const ExpensesDashboardPage()),
    );
  }

  void _actionRecordPayment(BuildContext context) {
     Navigator.of(context).push(
      MaterialPageRoute(builder: (context) => const RecordIncomeSheet()),
    );
  }

  void _actionStartCampaigns(BuildContext context) {
    _navigateToPlaceholder(context, "Send Bulk Reminders");
  }

  void _actionBillingSettings(BuildContext context) {
    Navigator.of(context).push(
      MaterialPageRoute(builder: (context) => const BillingSettingsPage()),
    );
  }

  // -- View All Links --

  void _viewAllAttention(BuildContext context) {
    // In a real app, navigate to StudentList filtered by 'overdue'
    _navigateToPlaceholder(context, "Full Attention List");
  }

  void _viewAllTransactions(BuildContext context) {
    // In a real app, navigate to a dedicated TransactionsPage
    _navigateToPlaceholder(context, "Full Transaction History");
  }

  void _viewTransactionReceipt(BuildContext context, TransactionItem item) {
    showDialog(
      context: context,
      builder: (ctx) => AlertDialog(
        backgroundColor: const Color(0xff1c2a35),
        title: const Text(
          "Receipt Details",
          style: TextStyle(color: Colors.white),
        ),
        content: Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              "Amount: \$${item.amount.toStringAsFixed(2)}",
              style: const TextStyle(
                color: Colors.white,
                fontSize: 18,
                fontWeight: FontWeight.bold,
              ),
            ),
            const SizedBox(height: 8),
            Text(
              "Date: ${DateFormat('MMM dd, yyyy').format(item.date)}",
              style: const TextStyle(color: Colors.white70),
            ),
            const SizedBox(height: 4),
            Text(
              "Ref: ${item.title} - ${item.subtitle}",
              style: const TextStyle(color: Colors.white54, fontSize: 12),
            ),
            const SizedBox(height: 16),
            const Center(
              child: Icon(Icons.receipt_long, size: 64, color: Colors.white24),
            ),
          ],
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(ctx),
            child: const Text("Close"),
          ),
          TextButton(
            onPressed: () => Navigator.pop(ctx),
            child: const Text("Share Receipt"),
          ),
        ],
      ),
    );
  }

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final financesAsync = ref.watch(financesProvider);
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;
    final currencyFormat = NumberFormat.currency(
      symbol: '\$',
      decimalDigits: 2,
    );

    return Scaffold(
      backgroundColor: colorScheme.surface,
      body: CustomScrollView(
        slivers: [
          // 1. Header
          SliverToBoxAdapter(
            child: Padding(
              padding: const EdgeInsets.only(
                top: 60,
                left: 20,
                right: 20,
                bottom: 20,
              ),
              child: Row(
                mainAxisAlignment: MainAxisAlignment.spaceBetween,
                children: [
                  Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Text(
                        "Finances",
                        style: theme.textTheme.headlineMedium?.copyWith(
                          fontWeight: FontWeight.bold,
                          color: Colors.white,
                        ),
                      ),
                      const SizedBox(height: 4),
                      Text(
                        "Overview  Q${((DateTime.now().month - 1) / 3).floor() + 1} ${DateTime.now().year}",
                        style: TextStyle(color: Colors.white.withAlpha(150)),
                      ),
                    ],
                  ),
                  GestureDetector(
                    onTap: () => _handleDownloadReport(context),
                    child: Container(
                      padding: const EdgeInsets.all(10),
                      decoration: BoxDecoration(
                        color: colorScheme.surfaceContainerHighest.withAlpha(
                          100,
                        ),
                        shape: BoxShape.circle,
                        border: Border.all(color: Colors.white.withAlpha(30)),
                      ),
                      child: const Icon(Icons.download, color: Colors.white),
                    ),
                  ),
                ],
              ),
            ),
          ),

          // 2. Content
          financesAsync.when(
            loading: () => const SliverFillRemaining(
              child: Center(child: CircularProgressIndicator()),
            ),
            error: (e, s) => SliverFillRemaining(
              child: Center(
                child: Text(
                  "Error: $e",
                  style: const TextStyle(color: Colors.red),
                ),
              ),
            ),
            data: (data) {
              // LIMIT RECENT TRANSACTIONS TO 5
              final limitedTransactions = data.recentTransactions
                  .take(5)
                  .toList();

              return SliverList(
                delegate: SliverChildListDelegate([
                  Padding(
                    padding: const EdgeInsets.symmetric(horizontal: 20),
                    child: Column(
                      children: [
                        // Revenue Card
                        _RevenueCard(
                          totalRevenue: data.totalRevenueYtd,
                          currencyFormatter: currencyFormat,
                          onTap: () => _handleRevenueClick(context),
                        ),

                        const SizedBox(height: 16),

                        // Stats Row
                        Row(
                          children: [
                            Expanded(
                              child: _StatCard(
                                title: "Outstanding",
                                value: currencyFormat.format(
                                  data.totalOutstanding,
                                ),
                                icon: Icons.money_off_csred_outlined,
                                accentColor: const Color(0xffef5350),
                                showAction: true,
                                onTap: () => _handleOutstandingClick(context),
                              ),
                            ),
                            const SizedBox(width: 16),
                            Expanded(
                              child: _StatCard(
                                title: "Open Invoices",
                                value: data.openInvoicesCount.toString(),
                                icon: Icons.receipt_long_outlined,
                                accentColor: const Color(0xff42a5f5),
                                onTap: () => _handleOpenInvoicesClick(context),
                              ),
                            ),
                          ],
                        ),

                        const SizedBox(height: 24),

                        // Quick Actions
                        const Align(
                          alignment: Alignment.centerLeft,
                          child: Text(
                            "Quick Actions",
                            style: TextStyle(
                              fontSize: 16,
                              fontWeight: FontWeight.bold,
                              color: Colors.white,
                            ),
                          ),
                        ),
                        const SizedBox(height: 16),
                        Row(
                          mainAxisAlignment: MainAxisAlignment.spaceBetween,
                          children: [
                            _QuickActionButton(
                              icon: Icons.pie_chart_outline, // Changed Icon
                              label: "Expenses\nDashboard", // Changed Label
                              onTap: () => _actionAddExpense(context),
                            ),
                            _QuickActionButton(
                              icon: Icons.add_card,
                              label: "Record\nPayment",
                              onTap: () => _actionRecordPayment(context),
                            ),
                            _QuickActionButton(
                              icon: Icons.campaign_outlined,
                              label: "Fund\nRaisers",
                              onTap: () => _actionStartCampaigns(context),
                            ),
                            _QuickActionButton(
                              icon: Icons.settings_outlined,
                              label: "Billing\nSettings",
                              onTap: () => _actionBillingSettings(context),
                            ),
                          ],
                        ),

                        const SizedBox(height: 24),

                        // Attention Needed
                        _SectionHeader(
                          title: "Attention Needed",
                          onTap: () => _viewAllAttention(context),
                        ),
                        const SizedBox(height: 12),
                        if (data.attentionList.isEmpty)
                          const _EmptyState(text: "No overdue payments found.")
                        else
                          ...data.attentionList.map(
                            (item) => _AttentionTile(item: item),
                          ),

                        const SizedBox(height: 24),

                        // Recent Payments (Limited to 5)
                        _SectionHeader(
                          title: "Recent Transactions",
                          onTap: () => _viewAllTransactions(context),
                        ),
                        const SizedBox(height: 12),
                        if (limitedTransactions.isEmpty)
                          const _EmptyState(text: "No recent transactions.")
                        else
                          ...limitedTransactions.map(
                            (item) => GestureDetector(
                              onTap: () =>
                                  _viewTransactionReceipt(context, item),
                              child: _TransactionTile(item: item),
                            ),
                          ),

                        const SizedBox(height: 100),
                      ],
                    ),
                  ),
                ]),
              );
            },
          ),
        ],
      ),
    );
  }
}

// ... (Rest of your existing Widgets: _RevenueCard, _StatCard, etc., remain exactly the same) ...
// Ensure you include all the helper widgets (_RevenueCard, _StatCard, _QuickActionButton, _AttentionTile, _TransactionTile, _SectionHeader, _EmptyState, _PlaceholderPage) here from your previous code.

// -----------------------------------------------------------------------------
// HELPER: Revenue Card
// -----------------------------------------------------------------------------
class _RevenueCard extends StatelessWidget {
  final double totalRevenue;
  final NumberFormat currencyFormatter;
  final VoidCallback onTap;

  const _RevenueCard({
    required this.totalRevenue,
    required this.currencyFormatter,
    required this.onTap,
  });

  @override
  Widget build(BuildContext context) {
    return GestureDetector(
      onTap: onTap,
      child: Container(
        width: double.infinity,
        padding: const EdgeInsets.all(24),
        decoration: BoxDecoration(
          gradient: const LinearGradient(
            colors: [Color(0xff0d47a1), Color(0xff42a5f5)],
            begin: Alignment.bottomLeft,
            end: Alignment.topRight,
          ),
          borderRadius: BorderRadius.circular(24),
          boxShadow: [
            BoxShadow(
              color: const Color(0xff42a5f5).withAlpha(80),
              blurRadius: 20,
              offset: const Offset(0, 8),
            ),
          ],
        ),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                const Text(
                  "Total Revenue (YTD)",
                  style: TextStyle(
                    color: Colors.white,
                    fontSize: 14,
                    fontWeight: FontWeight.w500,
                  ),
                ),
                Container(
                  padding: const EdgeInsets.all(8),
                  decoration: BoxDecoration(
                    color: Colors.white.withAlpha(50),
                    borderRadius: BorderRadius.circular(10),
                  ),
                  child: const Icon(
                    Icons.account_balance_wallet,
                    color: Colors.white,
                    size: 20,
                  ),
                ),
              ],
            ),
            const SizedBox(height: 12),
            Text(
              currencyFormatter.format(totalRevenue),
              style: const TextStyle(
                fontSize: 32,
                fontWeight: FontWeight.bold,
                color: Colors.white,
                fontFamily: 'Poppins',
              ),
            ),
            const SizedBox(height: 12),
            Container(
              padding: const EdgeInsets.symmetric(horizontal: 10, vertical: 6),
              decoration: BoxDecoration(
                color: Colors.white.withAlpha(50),
                borderRadius: BorderRadius.circular(8),
              ),
              child: const Row(
                mainAxisSize: MainAxisSize.min,
                children: [
                  Icon(Icons.trending_up, color: Colors.white, size: 16),
                  SizedBox(width: 6),
                  Text(
                    "+12.5% vs last year", // Placeholder data
                    style: TextStyle(
                      color: Colors.white,
                      fontSize: 12,
                      fontWeight: FontWeight.bold,
                    ),
                  ),
                ],
              ),
            ),
          ],
        ),
      ),
    );
  }
}

// -----------------------------------------------------------------------------
// HELPER: Stat Card
// -----------------------------------------------------------------------------
class _StatCard extends StatelessWidget {
  final String title;
  final String value;
  final IconData icon;
  final Color accentColor;
  final bool showAction;
  final VoidCallback onTap;

  const _StatCard({
    required this.title,
    required this.value,
    required this.icon,
    required this.accentColor,
    this.showAction = false,
    required this.onTap,
  });

  @override
  Widget build(BuildContext context) {
    return GestureDetector(
      onTap: onTap,
      child: Container(
        padding: const EdgeInsets.all(16),
        decoration: BoxDecoration(
          color: const Color(0xff1c2a35), // Theme Surface
          borderRadius: BorderRadius.circular(20),
          border: Border.all(color: Colors.white.withAlpha(20)),
        ),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                Container(
                  padding: const EdgeInsets.all(8),
                  decoration: BoxDecoration(
                    color: accentColor.withAlpha(30),
                    borderRadius: BorderRadius.circular(10),
                  ),
                  child: Icon(icon, color: accentColor, size: 18),
                ),
                if (showAction)
                  Container(
                    padding: const EdgeInsets.symmetric(
                      horizontal: 8,
                      vertical: 4,
                    ),
                    decoration: BoxDecoration(
                      color: const Color(0xffef5350).withAlpha(50),
                      borderRadius: BorderRadius.circular(12),
                      border: Border.all(
                        color: const Color(0xffef5350).withAlpha(100),
                      ),
                    ),
                    child: const Text(
                      "Action",
                      style: TextStyle(
                        fontSize: 10,
                        color: Color(0xffff8a80),
                        fontWeight: FontWeight.bold,
                      ),
                    ),
                  ),
              ],
            ),
            const SizedBox(height: 16),
            Text(
              title,
              style: TextStyle(color: Colors.grey.shade400, fontSize: 12),
            ),
            const SizedBox(height: 4),
            Text(
              value,
              style: const TextStyle(
                color: Colors.white,
                fontSize: 20,
                fontWeight: FontWeight.bold,
              ),
            ),
          ],
        ),
      ),
    );
  }
}

// -----------------------------------------------------------------------------
// HELPER: Quick Action Button
// -----------------------------------------------------------------------------
class _QuickActionButton extends StatelessWidget {
  final IconData icon;
  final String label;
  final VoidCallback onTap;

  const _QuickActionButton({
    required this.icon,
    required this.label,
    required this.onTap,
  });

  @override
  Widget build(BuildContext context) {
    return GestureDetector(
      onTap: onTap,
      child: Column(
        children: [
          Container(
            height: 60,
            width: 60,
            decoration: BoxDecoration(
              color: const Color(0xff1c2a35),
              shape: BoxShape.circle,
              border: Border.all(color: Colors.white.withAlpha(20)),
              boxShadow: [
                BoxShadow(
                  color: Colors.black.withAlpha(50),
                  blurRadius: 10,
                  offset: const Offset(0, 4),
                ),
              ],
            ),
            child: Icon(icon, color: const Color(0xff3498db)),
          ),
          const SizedBox(height: 8),
          Text(
            label,
            textAlign: TextAlign.center,
            style: const TextStyle(color: Colors.white70, fontSize: 12),
          ),
        ],
      ),
    );
  }
}

// -----------------------------------------------------------------------------
// HELPER: Attention Tile
// -----------------------------------------------------------------------------
class _AttentionTile extends StatelessWidget {
  final AttentionItem item;

  const _AttentionTile({required this.item});

  @override
  Widget build(BuildContext context) {
    return GestureDetector(
      onTap: () {
        Navigator.of(context).push(
          MaterialPageRoute(
            builder: (context) => StudentLedgerPage(studentId: item.studentId),
          ),
        );
      },
      child: Container(
        margin: const EdgeInsets.only(bottom: 12),
        padding: const EdgeInsets.all(16),
        decoration: BoxDecoration(
          color: const Color(0xff1c2a35),
          borderRadius: BorderRadius.circular(16),
          border: Border.all(color: Colors.white.withAlpha(15)),
        ),
        child: Row(
          children: [
            CircleAvatar(
              radius: 22,
              backgroundColor: const Color(0xffef5350).withAlpha(50),
              child: Text(
                item.name.isNotEmpty ? item.name[0] : '?',
                style: const TextStyle(
                  color: Color(0xffff8a80),
                  fontWeight: FontWeight.bold,
                ),
              ),
            ),
            const SizedBox(width: 16),
            Expanded(
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(
                    item.name,
                    style: const TextStyle(
                      color: Colors.white,
                      fontWeight: FontWeight.bold,
                      fontSize: 15,
                    ),
                  ),
                  Text(
                    item.overdueText,
                    style: const TextStyle(
                      color: Color(0xffff8a80),
                      fontSize: 12,
                    ),
                  ),
                ],
              ),
            ),
            Column(
              crossAxisAlignment: CrossAxisAlignment.end,
              children: [
                Text(
                  "-\$${item.amountOwed.toStringAsFixed(2)}",
                  style: const TextStyle(
                    color: Colors.white,
                    fontWeight: FontWeight.bold,
                    fontSize: 15,
                  ),
                ),
                const SizedBox(height: 4),
                Container(
                  padding: const EdgeInsets.symmetric(
                    horizontal: 8,
                    vertical: 2,
                  ),
                  decoration: BoxDecoration(
                    color: const Color(0xffef5350).withAlpha(40),
                    borderRadius: BorderRadius.circular(4),
                  ),
                  child: Text(
                    item.status.toUpperCase(),
                    style: const TextStyle(
                      color: Color(0xffff8a80),
                      fontSize: 10,
                      fontWeight: FontWeight.bold,
                    ),
                  ),
                ),
              ],
            ),
          ],
        ),
      ),
    );
  }
}

// -----------------------------------------------------------------------------
// HELPER: Transaction Tile
// -----------------------------------------------------------------------------
class _TransactionTile extends StatelessWidget {
  final TransactionItem item;

  const _TransactionTile({required this.item});

  @override
  Widget build(BuildContext context) {
    return Container(
      margin: const EdgeInsets.only(bottom: 12),
      padding: const EdgeInsets.all(16),
      decoration: BoxDecoration(
        color: const Color(0xff1c2a35),
        borderRadius: BorderRadius.circular(16),
        border: Border.all(color: Colors.white.withAlpha(15)),
      ),
      child: Row(
        children: [
          Container(
            height: 44,
            width: 44,
            decoration: BoxDecoration(
              color: const Color(0xff2ecc71).withAlpha(30),
              shape: BoxShape.circle,
            ),
            child: const Icon(Icons.attach_money, color: Color(0xff2ecc71)),
          ),
          const SizedBox(width: 16),
          Expanded(
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  item.title,
                  style: const TextStyle(
                    color: Colors.white,
                    fontWeight: FontWeight.bold,
                    fontSize: 15,
                  ),
                ),
                Text(
                  item.subtitle,
                  style: TextStyle(color: Colors.grey.shade400, fontSize: 12),
                ),
              ],
            ),
          ),
          Text(
            "+\$${item.amount.toStringAsFixed(2)}",
            style: const TextStyle(
              color: Color(0xff2ecc71),
              fontWeight: FontWeight.bold,
              fontSize: 15,
            ),
          ),
        ],
      ),
    );
  }
}

// -----------------------------------------------------------------------------
// HELPER: Section Header
// -----------------------------------------------------------------------------
class _SectionHeader extends StatelessWidget {
  final String title;
  final VoidCallback onTap;

  const _SectionHeader({required this.title, required this.onTap});

  @override
  Widget build(BuildContext context) {
    return Row(
      mainAxisAlignment: MainAxisAlignment.spaceBetween,
      children: [
        Text(
          title,
          style: const TextStyle(
            color: Colors.white,
            fontSize: 16,
            fontWeight: FontWeight.bold,
          ),
        ),
        GestureDetector(
          onTap: onTap,
          child: const Text(
            "View All",
            style: TextStyle(
              color: Color(0xff3498db),
              fontSize: 12,
              fontWeight: FontWeight.bold,
            ),
          ),
        ),
      ],
    );
  }
}

// -----------------------------------------------------------------------------
// HELPER: Empty State
// -----------------------------------------------------------------------------
class _EmptyState extends StatelessWidget {
  final String text;
  const _EmptyState({required this.text});

  @override
  Widget build(BuildContext context) {
    return Container(
      width: double.infinity,
      padding: const EdgeInsets.all(24),
      decoration: BoxDecoration(
        color: Colors.white.withAlpha(5),
        borderRadius: BorderRadius.circular(12),
        border: Border.all(
          color: Colors.white.withAlpha(10),
          style: BorderStyle.solid,
        ),
      ),
      child: Center(
        child: Text(text, style: TextStyle(color: Colors.grey.shade500)),
      ),
    );
  }
}

class _PlaceholderPage extends StatelessWidget {
  final String title;
  const _PlaceholderPage({required this.title});

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      backgroundColor: const Color(0xff121b22),
      appBar: AppBar(
        title: Text(title, style: const TextStyle(color: Colors.white)),
        backgroundColor: const Color(0xff121b22),
        iconTheme: const IconThemeData(color: Colors.white),
      ),
      body: Center(
        child: Text(
          "Placeholder: $title",
          style: const TextStyle(color: Colors.white),
        ),
      ),
    );
  }
}
import 'package:flutter/material.dart';
import 'package:intl/intl.dart';
import 'package:uuid/uuid.dart';
import '../services/database_service.dart';

class RecordIncomeSheet extends StatefulWidget {
  const RecordIncomeSheet({super.key});

  @override
  State<RecordIncomeSheet> createState() => _RecordIncomeSheetState();
}

class _RecordIncomeSheetState extends State<RecordIncomeSheet>
    with SingleTickerProviderStateMixin {
  late TabController _tabController;

  // Controllers
  final _amountCtrl = TextEditingController();
  final _notesCtrl = TextEditingController();
  final _payerCtrl = TextEditingController(); // For external donors

  // State
  String _selectedCategory = 'tuition';
  DateTime _selectedDate = DateTime.now();
  String? _selectedStudentId;
  String? _selectedStudentName;
  bool _isSaving = false;

  // Search State
  final _searchCtrl = TextEditingController();
  List<Map<String, dynamic>> _searchResults = [];
  bool _isSearching = false;

  @override
  void initState() {
    super.initState();
    _tabController = TabController(length: 2, vsync: this);

    // Reset category when tab changes
    _tabController.addListener(() {
      if (_tabController.index == 0) {
        setState(() => _selectedCategory = 'tuition'); // Default for Student
      } else {
        setState(() => _selectedCategory = 'fundraiser'); // Default for Other
      }
    });
  }

  // --- Logic ---

  Future<void> _searchStudents(String query) async {
    if (query.isEmpty) {
      setState(() => _searchResults = []);
      return;
    }
    setState(() => _isSearching = true);

    final db = await DatabaseService.instance.database;
    final results = await db.query(
      'students',
      where: 'full_name LIKE ?',
      whereArgs: ['%$query%'],
      limit: 5,
    );

    if (mounted) {
      setState(() {
        _searchResults = results;
        _isSearching = false;
      });
    }
  }

  Future<void> _saveRecord() async {
    final amount = double.tryParse(_amountCtrl.text);
    if (amount == null || amount <= 0) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text("Please enter a valid amount")),
      );
      return;
    }

    // Validation based on Tab
    if (_tabController.index == 0 && _selectedStudentId == null) {
      ScaffoldMessenger.of(
        context,
      ).showSnackBar(const SnackBar(content: Text("Please select a student")));
      return;
    }
    if (_tabController.index == 1 && _payerCtrl.text.isEmpty) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text("Please enter Payer Name / Source")),
      );
      return;
    }

    setState(() => _isSaving = true);

    try {
      final db = await DatabaseService.instance.database;

      // Determine Payer Name (Student Name or Manual Input)
      final finalPayerName = _tabController.index == 0
          ? _selectedStudentName
          : _payerCtrl.text.trim();

      await db.insert('payments', {
        'id': const Uuid().v4(),
        'school_id': 'local_school_id', // Replace with real ID from provider
        'student_id': _selectedStudentId, // Null if "Other Revenue"
        'amount': amount,
        'category': _selectedCategory,
        'date_paid': DateFormat('yyyy-MM-dd').format(_selectedDate),
        'method': 'Cash', // You can add a dropdown for this later
        'payer_name': finalPayerName,
        'created_at': DateTime.now().millisecondsSinceEpoch,
        // Optionally link to bill_id if you want to auto-settle a bill here
      });

      // If it was a student payment, update their ledger totals locally
      if (_selectedStudentId != null) {
        // Logic to update paid_total += amount would go here
      }

      if (mounted) {
        Navigator.pop(context, true); // Return success
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(content: Text("Income Recorded Successfully")),
        );
      }
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(
          context,
        ).showSnackBar(SnackBar(content: Text("Error: $e")));
      }
    } finally {
      if (mounted) setState(() => _isSaving = false);
    }
  }

  @override
  Widget build(BuildContext context) {
    const bgColor = Color(0xff121b22);
    const cardColor = Color(0xff1c2a35);
    const blueColor = Color(0xff2962ff);

    // FIX: Wrap everything in a Material widget to satisfy TabBar requirements
    return Material(
      color: bgColor,
      borderRadius: const BorderRadius.vertical(top: Radius.circular(24)),
      child: Container(
        height: MediaQuery.of(context).size.height * 0.85,
        padding: const EdgeInsets.all(20),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            // Handle
            Center(
              child: Container(
                width: 40,
                height: 4,
                margin: const EdgeInsets.only(bottom: 20),
                decoration: BoxDecoration(
                  color: Colors.grey.withAlpha(100),
                  borderRadius: BorderRadius.circular(2),
                ),
              ),
            ),

            const Text(
              "Record Income",
              style: TextStyle(
                color: Colors.white,
                fontSize: 22,
                fontWeight: FontWeight.bold,
              ),
            ),
            const SizedBox(height: 16),

            // TABS
            Container(
              decoration: BoxDecoration(
                color: cardColor,
                borderRadius: BorderRadius.circular(12),
              ),
              child: TabBar(
                controller: _tabController,
                indicatorColor: blueColor,
                labelColor: blueColor,
                unselectedLabelColor: Colors.grey,
                indicatorSize: TabBarIndicatorSize.tab,
                dividerColor: Colors.transparent,
                tabs: const [
                  Tab(text: "Student Payment"),
                  Tab(text: "Other Revenue"),
                ],
              ),
            ),
            const SizedBox(height: 20),

            // AMOUNT INPUT (Big & Center)
            Center(
              child: SizedBox(
                width: 200,
                child: TextField(
                  controller: _amountCtrl,
                  keyboardType: const TextInputType.numberWithOptions(
                    decimal: true,
                  ),
                  textAlign: TextAlign.center,
                  style: const TextStyle(
                    color: Colors.white,
                    fontSize: 40,
                    fontWeight: FontWeight.bold,
                  ),
                  decoration: const InputDecoration(
                    prefixText: "\$",
                    prefixStyle: TextStyle(color: Colors.white54, fontSize: 40),
                    border: InputBorder.none,
                    hintText: "0.00",
                    hintStyle: TextStyle(color: Colors.white24),
                  ),
                ),
              ),
            ),
            const SizedBox(height: 20),

            // TAB VIEWS
            Expanded(
              child: TabBarView(
                controller: _tabController,
                children: [
                  // TAB 1: STUDENT PAYMENT
                  _buildStudentTab(cardColor),

                  // TAB 2: OTHER REVENUE
                  _buildOtherTab(cardColor),
                ],
              ),
            ),

            // DATE & SAVE
            const SizedBox(height: 10),
            // We wrap this row in a SafeArea or ensure padding to avoid keyboard overlap issues
            Padding(
              padding: EdgeInsets.only(
                bottom: MediaQuery.of(context).viewInsets.bottom,
              ),
              child: Row(
                children: [
                  // Date Picker Button
                  Container(
                    decoration: BoxDecoration(
                      color: cardColor,
                      borderRadius: BorderRadius.circular(12),
                    ),
                    child: IconButton(
                      icon: const Icon(
                        Icons.calendar_today,
                        color: Colors.white,
                      ),
                      onPressed: () async {
                        final d = await showDatePicker(
                          context: context,
                          initialDate: _selectedDate,
                          firstDate: DateTime(2020),
                          lastDate: DateTime.now(),
                        );
                        if (d != null) setState(() => _selectedDate = d);
                      },
                    ),
                  ),
                  const SizedBox(width: 12),
                  Expanded(
                    child: Text(
                      DateFormat('EEE, MMM d').format(_selectedDate),
                      style: const TextStyle(color: Colors.white70),
                    ),
                  ),
                  Expanded(
                    flex: 2,
                    child: SizedBox(
                      height: 50,
                      child: ElevatedButton(
                        onPressed: _isSaving ? null : _saveRecord,
                        style: ElevatedButton.styleFrom(
                          backgroundColor: blueColor,
                          shape: RoundedRectangleBorder(
                            borderRadius: BorderRadius.circular(12),
                          ),
                        ),
                        child: _isSaving
                            ? const SizedBox(
                                width: 20,
                                height: 20,
                                child: CircularProgressIndicator(
                                  color: Colors.white,
                                ),
                              )
                            : const Text(
                                "Confirm Payment",
                                style: TextStyle(
                                  color: Colors.white,
                                  fontWeight: FontWeight.bold,
                                ),
                              ),
                      ),
                    ),
                  ),
                ],
              ),
            ),
            const SizedBox(height: 20),
          ],
        ),
      ),
    );
  }

  Widget _buildStudentTab(Color cardColor) {
    return SingleChildScrollView(
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          // Student Search
          Container(
            padding: const EdgeInsets.symmetric(horizontal: 16),
            decoration: BoxDecoration(
              color: cardColor,
              borderRadius: BorderRadius.circular(12),
            ),
            child: TextField(
              controller: _searchCtrl,
              style: const TextStyle(color: Colors.white),
              decoration: const InputDecoration(
                hintText: "Search Student...",
                hintStyle: TextStyle(color: Colors.grey),
                border: InputBorder.none,
                icon: Icon(Icons.search, color: Colors.grey),
              ),
              onChanged: _searchStudents,
            ),
          ),

          if (_selectedStudentId != null) ...[
            const SizedBox(height: 12),
            Container(
              padding: const EdgeInsets.all(12),
              decoration: BoxDecoration(
                color: Colors.green.withAlpha(50),
                borderRadius: BorderRadius.circular(12),
                border: Border.all(color: Colors.green.withAlpha(100)),
              ),
              child: Row(
                children: [
                  const Icon(Icons.check_circle, color: Colors.green),
                  const SizedBox(width: 12),
                  Text(
                    _selectedStudentName!,
                    style: const TextStyle(
                      color: Colors.white,
                      fontWeight: FontWeight.bold,
                    ),
                  ),
                  const Spacer(),
                  IconButton(
                    icon: const Icon(
                      Icons.close,
                      color: Colors.white54,
                      size: 20,
                    ),
                    onPressed: () {
                      setState(() {
                        _selectedStudentId = null;
                        _selectedStudentName = null;
                      });
                    },
                  ),
                ],
              ),
            ),
          ],

          if (_isSearching)
            const Padding(
              padding: EdgeInsets.all(20),
              child: Center(child: CircularProgressIndicator()),
            )
          else if (_searchResults.isNotEmpty && _selectedStudentId == null)
            ..._searchResults.map(
              (s) => ListTile(
                title: Text(
                  s['full_name'],
                  style: const TextStyle(color: Colors.white),
                ),
                subtitle: Text(
                  s['grade'] ?? 'No Grade',
                  style: const TextStyle(color: Colors.grey),
                ),
                onTap: () {
                  setState(() {
                    _selectedStudentId = s['id'];
                    _selectedStudentName = s['full_name'];
                    _searchResults = [];
                    _searchCtrl.clear();
                  });
                },
              ),
            ),

          const SizedBox(height: 20),
          _Label("PAYMENT TYPE"),
          Wrap(
            spacing: 10,
            children: ['tuition', 'uniform', 'transport', 'exam_fee'].map((
              cat,
            ) {
              final isSelected = _selectedCategory == cat;
              return ChoiceChip(
                label: Text(cat.toUpperCase()),
                selected: isSelected,
                onSelected: (v) => setState(() => _selectedCategory = cat),
                selectedColor: const Color(0xff2962ff),
                backgroundColor: cardColor,
                labelStyle: TextStyle(
                  color: isSelected ? Colors.white : Colors.grey,
                ),
                side: BorderSide.none,
              );
            }).toList(),
          ),
        ],
      ),
    );
  }

  Widget _buildOtherTab(Color cardColor) {
    return SingleChildScrollView(
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          _Label("SOURCE / PAYER"),
          TextField(
            controller: _payerCtrl,
            style: const TextStyle(color: Colors.white),
            decoration: InputDecoration(
              filled: true,
              fillColor: cardColor,
              hintText: "e.g. Rotary Club, Bake Sale, Anonymous",
              hintStyle: const TextStyle(color: Colors.grey),
              border: OutlineInputBorder(
                borderRadius: BorderRadius.circular(12),
                borderSide: BorderSide.none,
              ),
            ),
          ),
          const SizedBox(height: 20),
          _Label("REVENUE CATEGORY"),
          Wrap(
            spacing: 10,
            children: ['fundraiser', 'donation', 'grant', 'other'].map((cat) {
              final isSelected = _selectedCategory == cat;
              return ChoiceChip(
                label: Text(cat.toUpperCase()),
                selected: isSelected,
                onSelected: (v) => setState(() => _selectedCategory = cat),
                selectedColor: Colors.orange,
                backgroundColor: cardColor,
                labelStyle: TextStyle(
                  color: isSelected ? Colors.white : Colors.grey,
                ),
                side: BorderSide.none,
              );
            }).toList(),
          ),
          const SizedBox(height: 20),
          _Label("DESCRIPTION / NOTES"),
          TextField(
            controller: _notesCtrl,
            maxLines: 2,
            style: const TextStyle(color: Colors.white),
            decoration: InputDecoration(
              filled: true,
              fillColor: cardColor,
              hintText: "Add details...",
              hintStyle: const TextStyle(color: Colors.grey),
              border: OutlineInputBorder(
                borderRadius: BorderRadius.circular(12),
                borderSide: BorderSide.none,
              ),
            ),
          ),
        ],
      ),
    );
  }
}

class _Label extends StatelessWidget {
  final String text;
  const _Label(this.text);
  @override
  Widget build(BuildContext context) {
    return Padding(
      padding: const EdgeInsets.only(bottom: 8, left: 4),
      child: Text(
        text,
        style: const TextStyle(
          color: Colors.grey,
          fontSize: 11,
          fontWeight: FontWeight.bold,
        ),
      ),
    );
  }
}
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:supabase_flutter/supabase_flutter.dart';
import '../providers/settings_provider.dart';
import '../providers/auth_provider.dart';

class SettingsPage extends ConsumerWidget {
  const SettingsPage({super.key});

  // --- Actions ---
  
  void _editProfile(BuildContext context) {
    ScaffoldMessenger.of(context).showSnackBar(
      const SnackBar(content: Text("TODO: Open Edit Profile Page")),
    );
  }

  void _changePassword(BuildContext context) {
    ScaffoldMessenger.of(context).showSnackBar(
      const SnackBar(content: Text("TODO: Open Change Password Flow")),
    );
  }

  void _openHelpCenter(BuildContext context) {
    ScaffoldMessenger.of(context).showSnackBar(
      const SnackBar(content: Text("TODO: Open Help Center / Webview")),
    );
  }

  Future<void> _handleSignOut(BuildContext context, WidgetRef ref) async {
    // Show confirmation dialog
    final confirm = await showDialog<bool>(
      context: context,
      builder: (ctx) => AlertDialog(
        backgroundColor: const Color(0xff1c2a35),
        title: const Text("Sign Out?", style: TextStyle(color: Colors.white)),
        content: const Text(
          "Are you sure you want to sign out? You will need to login again.",
          style: TextStyle(color: Colors.white70),
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(ctx, false),
            child: const Text("Cancel"),
          ),
          TextButton(
            onPressed: () => Navigator.pop(ctx, true),
            child: const Text("Sign Out", style: TextStyle(color: Colors.redAccent)),
          ),
        ],
      ),
    );

    if (confirm == true) {
      await ref.read(authControllerProvider.notifier).signOut();
    }
  }

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;
    
    // Watch settings state
    final settingsAsync = ref.watch(settingsProvider);
    
    // Get current user info from Supabase for the header
    final user = Supabase.instance.client.auth.currentUser;
    final email = user?.email ?? 'admin@school.edu';
    final name = user?.userMetadata?['full_name'] ?? 'School Admin';

    return Scaffold(
      backgroundColor: colorScheme.surface, // 0xff121b22
      appBar: AppBar(
        title: const Text("Settings"),
        centerTitle: true,
        backgroundColor: colorScheme.surface,
        elevation: 0,
        titleTextStyle: const TextStyle(
          color: Colors.white, 
          fontSize: 20, 
          fontWeight: FontWeight.bold
        ),
        iconTheme: const IconThemeData(color: Colors.white),
      ),
      body: settingsAsync.when(
        loading: () => const Center(child: CircularProgressIndicator()),
        error: (e, s) => Center(child: Text("Error: $e", style: const TextStyle(color: Colors.red))),
        data: (settings) {
          return SingleChildScrollView(
            padding: const EdgeInsets.all(20),
            child: Column(
              children: [
                // --- PROFILE HEADER ---
                Column(
                  children: [
                    Stack(
                      children: [
                        Container(
                          padding: const EdgeInsets.all(4),
                          decoration: BoxDecoration(
                            shape: BoxShape.circle,
                            border: Border.all(color: Colors.white.withAlpha(20), width: 2),
                          ),
                          child: const CircleAvatar(
                            radius: 45,
                            backgroundImage: AssetImage('assets/avatar_placeholder.png'), // Ensure you have this or use Icon
                            backgroundColor: Color(0xff1c2a35),
                            child: SizedBox(),
                          ),
                        ),
                        Positioned(
                          bottom: 0,
                          right: 0,
                          child: Container(
                            padding: const EdgeInsets.all(6),
                            decoration: const BoxDecoration(
                              color: Color(0xff3498db), // Brand Blue
                              shape: BoxShape.circle,
                            ),
                            child: const Icon(Icons.edit, size: 16, color: Colors.white),
                          ),
                        ),
                      ],
                    ),
                    const SizedBox(height: 12),
                    Text(
                      name,
                      style: const TextStyle(
                        fontSize: 20, 
                        fontWeight: FontWeight.bold, 
                        color: Colors.white
                      ),
                    ),
                    const SizedBox(height: 4),
                    Text(
                      email,
                      style: TextStyle(fontSize: 14, color: Colors.white.withAlpha(150)),
                    ),
                    const SizedBox(height: 16),
                    ElevatedButton(
                      onPressed: () => _editProfile(context),
                      style: ElevatedButton.styleFrom(
                        backgroundColor: const Color(0xff3498db).withAlpha(30),
                        foregroundColor: const Color(0xff3498db),
                        elevation: 0,
                        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(20)),
                        padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 10),
                      ),
                      child: const Text("Edit Profile", style: TextStyle(fontWeight: FontWeight.bold)),
                    ),
                  ],
                ),

                const SizedBox(height: 32),

                // --- ACCOUNT SECTION ---
                _SectionTitle(title: "ACCOUNT"),
                _SettingsGroup(
                  children: [
                    _SettingsTile(
                      icon: Icons.lock_outline,
                      iconColor: const Color(0xff64b5f6), // Light Blue
                      title: "Change Password",
                      trailing: const Icon(Icons.arrow_forward_ios, size: 16, color: Colors.grey),
                      onTap: () => _changePassword(context),
                    ),
                    _Divider(),
                    _SettingsTile(
                      icon: Icons.security_outlined,
                      iconColor: const Color(0xffba68c8), // Purple
                      title: "Two-Factor Authentication",
                      trailing: Row(
                        mainAxisSize: MainAxisSize.min,
                        children: [
                          Text("Enabled", style: TextStyle(color: const Color(0xff66bb6a), fontSize: 12, fontWeight: FontWeight.bold)),
                          const SizedBox(width: 8),
                          const Icon(Icons.arrow_forward_ios, size: 16, color: Colors.grey),
                        ],
                      ),
                      onTap: () {},
                    ),
                    _Divider(),
                    _SettingsTile(
                      icon: Icons.fingerprint,
                      iconColor: const Color(0xffffb74d), // Orange
                      title: "Biometric Login",
                      trailing: Switch(
                        value: settings.biometricEnabled,
                        onChanged: (val) => ref.read(settingsProvider.notifier).toggleBiometric(val),
                        activeThumbColor: const Color(0xff3498db),
                        activeTrackColor: const Color(0xff3498db).withAlpha(100),
                        inactiveTrackColor: Colors.grey.withAlpha(50),
                      ),
                    ),
                  ],
                ),

                const SizedBox(height: 24),

                // --- PREFERENCES SECTION ---
                _SectionTitle(title: "PREFERENCES"),
                _SettingsGroup(
                  children: [
                    _SettingsTile(
                      icon: Icons.notifications_none_outlined,
                      iconColor: const Color(0xff4db6ac), // Teal
                      title: "Notifications",
                      trailing: const Icon(Icons.arrow_forward_ios, size: 16, color: Colors.grey),
                      onTap: () {},
                    ),
                    _Divider(),
                    _SettingsTile(
                      icon: Icons.language,
                      iconColor: const Color(0xff7986cb), // Indigo
                      title: "Language",
                      trailing: Row(
                        mainAxisSize: MainAxisSize.min,
                        children: [
                          Text(settings.language, style: TextStyle(color: Colors.white.withAlpha(150), fontSize: 12)),
                          const SizedBox(width: 8),
                          const Icon(Icons.arrow_forward_ios, size: 16, color: Colors.grey),
                        ],
                      ),
                      onTap: () {},
                    ),
                    _Divider(),
                    _SettingsTile(
                      icon: Icons.dark_mode_outlined,
                      iconColor: const Color(0xff90a4ae), // Grey Blue
                      title: "Dark Mode",
                      // Locked to true for this app design, but switchable in logic
                      trailing: Switch(
                        value: settings.darkMode, 
                        onChanged: (val) => ref.read(settingsProvider.notifier).toggleDarkMode(val),
                        activeColor: const Color(0xff3498db),
                        activeTrackColor: const Color(0xff3498db).withAlpha(100),
                        inactiveTrackColor: Colors.grey.withAlpha(50),
                      ),
                    ),
                  ],
                ),

                const SizedBox(height: 24),

                // --- SUPPORT SECTION ---
                _SectionTitle(title: "SUPPORT"),
                _SettingsGroup(
                  children: [
                    _SettingsTile(
                      icon: Icons.help_outline,
                      iconColor: const Color(0xffe57373), // Red
                      title: "Help Center",
                      trailing: const Icon(Icons.arrow_forward_ios, size: 16, color: Colors.grey),
                      onTap: () => _openHelpCenter(context),
                    ),
                    _Divider(),
                    _SettingsTile(
                      icon: Icons.chat_bubble_outline,
                      iconColor: const Color(0xffffd54f), // Yellow
                      title: "Send Feedback",
                      trailing: const Icon(Icons.arrow_forward_ios, size: 16, color: Colors.grey),
                      onTap: () {},
                    ),
                    _Divider(),
                    _SettingsTile(
                      icon: Icons.info_outline,
                      iconColor: const Color(0xff4fc3f7), // Light Blue
                      title: "About App",
                      trailing: Text("v2.4.0", style: TextStyle(color: Colors.white.withAlpha(100), fontSize: 12)),
                      onTap: () {},
                    ),
                  ],
                ),

                const SizedBox(height: 40),

                // --- LOGOUT ---
                SizedBox(
                  width: double.infinity,
                  height: 56,
                  child: OutlinedButton.icon(
                    onPressed: () => _handleSignOut(context, ref),
                    style: OutlinedButton.styleFrom(
                      side: const BorderSide(color: Color(0xffef5350)), // Red border
                      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
                      foregroundColor: const Color(0xffef5350),
                    ),
                    icon: const Icon(Icons.logout),
                    label: const Text("Sign Out", style: TextStyle(fontSize: 16, fontWeight: FontWeight.bold)),
                  ),
                ),

                const SizedBox(height: 20),
                Text(
                  "Secure Student Data System  2025",
                  style: TextStyle(color: Colors.white.withAlpha(50), fontSize: 12),
                ),
                const SizedBox(height: 100), // Bottom padding for nav bar
              ],
            ),
          );
        },
      ),
    );
  }
}

// -----------------------------------------------------------------------------
// HELPER WIDGETS
// -----------------------------------------------------------------------------

class _SectionTitle extends StatelessWidget {
  final String title;
  const _SectionTitle({required this.title});

  @override
  Widget build(BuildContext context) {
    return Container(
      width: double.infinity,
      padding: const EdgeInsets.only(bottom: 8, left: 4),
      child: Text(
        title,
        style: TextStyle(
          color: Colors.white.withAlpha(100),
          fontSize: 12,
          fontWeight: FontWeight.bold,
          letterSpacing: 1.0,
        ),
      ),
    );
  }
}

class _SettingsGroup extends StatelessWidget {
  final List<Widget> children;
  const _SettingsGroup({required this.children});

  @override
  Widget build(BuildContext context) {
    return Container(
      decoration: BoxDecoration(
        color: const Color(0xff1c2a35), // Card Surface
        borderRadius: BorderRadius.circular(16),
        border: Border.all(color: Colors.white.withAlpha(10)),
      ),
      child: Column(children: children),
    );
  }
}

class _SettingsTile extends StatelessWidget {
  final IconData icon;
  final Color iconColor;
  final String title;
  final Widget trailing;
  final VoidCallback? onTap;

  const _SettingsTile({
    required this.icon,
    required this.iconColor,
    required this.title,
    required this.trailing,
    this.onTap,
  });

  @override
  Widget build(BuildContext context) {
    return ListTile(
      onTap: onTap,
      contentPadding: const EdgeInsets.symmetric(horizontal: 16, vertical: 4),
      leading: Container(
        padding: const EdgeInsets.all(8),
        decoration: BoxDecoration(
          color: iconColor.withAlpha(30),
          shape: BoxShape.circle,
        ),
        child: Icon(icon, color: iconColor, size: 20),
      ),
      title: Text(
        title,
        style: const TextStyle(color: Colors.white, fontSize: 15, fontWeight: FontWeight.w500),
      ),
      trailing: trailing,
    );
  }
}

class _Divider extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Divider(
      height: 1,
      thickness: 1,
      color: Colors.white.withAlpha(10),
      indent: 60, // Align with text, skipping icon
    );
  }
}// lib/pages/revenue_analytics_page.dart

import 'package:fl_chart/fl_chart.dart';
import 'package:flutter/material.dart';
import 'package:intl/intl.dart';
import '../services/database_service.dart';

class RevenueAnalyticsPage extends StatefulWidget {
  const RevenueAnalyticsPage({super.key});

  @override
  State<RevenueAnalyticsPage> createState() => _RevenueAnalyticsPageState();
}

class _RevenueAnalyticsPageState extends State<RevenueAnalyticsPage> {
  // Filter State
  String _selectedFilter = 'Monthly';
  final List<String> _filters = ['Weekly', 'Monthly', 'Yearly'];

  // Data State
  bool _isLoading = true;
  double _totalRevenue = 0.0;
  double _growthPercentage = 0.0; // Comparison logic
  double _outstandingTotal = 0.0;
  
  // Chart Data
  List<FlSpot> _trendSpots = [];
  double _maxY = 100.0;

  // Recent Transactions
  List<Map<String, dynamic>> _recentPayments = [];

  @override
  void initState() {
    super.initState();
    _fetchRevenueData();
  }

  Future<void> _fetchRevenueData() async {
    setState(() => _isLoading = true);
    final db = await DatabaseService.instance.database;

    DateTime now = DateTime.now();
    DateTime startDate;
    DateTime previousStartDate; // For growth calc

    // 1. Determine Date Range
    switch (_selectedFilter) {
      case 'Weekly':
        startDate = now.subtract(const Duration(days: 7));
        previousStartDate = now.subtract(const Duration(days: 14));
        break;
      case 'Monthly':
        startDate = DateTime(now.year, now.month, 1);
        previousStartDate = DateTime(now.year, now.month - 1, 1);
        break;
      case 'Yearly':
        startDate = DateTime(now.year, 1, 1);
        previousStartDate = DateTime(now.year - 1, 1, 1);
        break;
      default:
        startDate = DateTime(now.year, now.month, 1);
        previousStartDate = DateTime(now.year, now.month - 1, 1);
    }

    final startStr = DateFormat('yyyy-MM-dd').format(startDate);
    
    // 2. Query Payments (Current Period)
    final payments = await db.query(
      'payments',
      where: 'date_paid >= ?',
      whereArgs: [startStr],
      orderBy: 'date_paid ASC',
    );

    // 3. Query Outstanding (From Bills that are not fully paid)
    // Note: This is usually total outstanding of ALL time, but let's keep it simple
    final bills = await db.rawQuery(
      'SELECT SUM(total_amount - paid_amount) as owed FROM bills WHERE is_closed = 0'
    );
    final outstanding = (bills.first['owed'] as num?)?.toDouble() ?? 0.0;

    // 4. Process Data for Chart & Total
    double total = 0.0;
    Map<int, double> groupedData = {}; // Key = day (or month for yearly)
    
    for (var row in payments) {
      final amt = (row['amount'] as num).toDouble();
      final dateStr = row['date_paid'] as String;
      final date = DateTime.parse(dateStr);
      
      total += amt;

      // Grouping Logic
      int key;
      if (_selectedFilter == 'Yearly') {
        key = date.month; // 1-12
      } else {
        key = date.day; // 1-31
      }
      groupedData[key] = (groupedData[key] ?? 0) + amt;
    }

    // 5. Build Chart Spots
    List<FlSpot> spots = [];
    double maxVal = 0;
    
    // Sort keys to ensure line goes left-to-right
    final sortedKeys = groupedData.keys.toList()..sort();
    
    if (sortedKeys.isEmpty) {
      spots.add(const FlSpot(0, 0));
    } else {
      for (var key in sortedKeys) {
        final val = groupedData[key]!;
        if (val > maxVal) maxVal = val;
        spots.add(FlSpot(key.toDouble(), val));
      }
    }

    // 6. Refresh UI
    if (mounted) {
      setState(() {
        _totalRevenue = total;
        _outstandingTotal = outstanding;
        _trendSpots = spots;
        _maxY = maxVal * 1.2; // Add 20% headroom
        _recentPayments = payments.reversed.take(10).toList(); // Show last 10
        _isLoading = false;
        // _growthPercentage would require a second query for 'previousStartDate' range
        // For now, hardcoding a dummy calculation or leaving as 0
        _growthPercentage = 5.2; 
      });
    }
  }

  @override
  Widget build(BuildContext context) {
    const bgColor = Color(0xff121b22);
    const cardColor = Color(0xff1c2a35);
    const primaryColor = Color(0xff3498db);
    const accentGreen = Color(0xff00c853);

    return Scaffold(
      backgroundColor: bgColor,
      appBar: AppBar(
        backgroundColor: bgColor,
        title: const Text("Revenue Analytics", style: TextStyle(color: Colors.white, fontWeight: FontWeight.bold)),
        iconTheme: const IconThemeData(color: Colors.white),
        actions: [
          Padding(
            padding: const EdgeInsets.only(right: 16.0),
            child: DropdownButtonHideUnderline(
              child: DropdownButton<String>(
                dropdownColor: cardColor,
                value: _selectedFilter,
                icon: const Icon(Icons.filter_list, color: Colors.white54),
                style: const TextStyle(color: Colors.white, fontWeight: FontWeight.bold),
                items: _filters.map((f) => DropdownMenuItem(value: f, child: Text(f))).toList(),
                onChanged: (val) {
                  if (val != null) {
                    setState(() => _selectedFilter = val);
                    _fetchRevenueData();
                  }
                },
              ),
            ),
          )
        ],
      ),
      body: _isLoading 
        ? const Center(child: CircularProgressIndicator())
        : SingleChildScrollView(
          padding: const EdgeInsets.all(20),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              // 1. Hero Card
              Container(
                width: double.infinity,
                padding: const EdgeInsets.all(24),
                decoration: BoxDecoration(
                  gradient: const LinearGradient(
                    colors: [Color(0xff1565c0), Color(0xff42a5f5)],
                    begin: Alignment.topLeft,
                    end: Alignment.bottomRight,
                  ),
                  borderRadius: BorderRadius.circular(24),
                  boxShadow: [
                    BoxShadow(color: Colors.blue.withAlpha(50), blurRadius: 20, offset: const Offset(0, 10))
                  ],
                ),
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text("Total Revenue ($_selectedFilter)", style: const TextStyle(color: Colors.white70)),
                    const SizedBox(height: 8),
                    Text(
                      "\$${NumberFormat('#,##0.00').format(_totalRevenue)}",
                      style: const TextStyle(color: Colors.white, fontSize: 32, fontWeight: FontWeight.bold),
                    ),
                    const SizedBox(height: 16),
                    Row(
                      children: [
                        Container(
                          padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
                          decoration: BoxDecoration(color: Colors.white24, borderRadius: BorderRadius.circular(8)),
                          child: Row(
                            children: [
                              const Icon(Icons.trending_up, color: Colors.white, size: 16),
                              const SizedBox(width: 4),
                              Text("+$_growthPercentage%", style: const TextStyle(color: Colors.white, fontWeight: FontWeight.bold)),
                            ],
                          ),
                        ),
                        const SizedBox(width: 12),
                        const Text("vs last period", style: TextStyle(color: Colors.white54, fontSize: 12)),
                      ],
                    )
                  ],
                ),
              ),

              const SizedBox(height: 24),

              // 2. Secondary Metrics Row
              Row(
                children: [
                  Expanded(
                    child: _MetricCard(
                      label: "Outstanding",
                      value: "\$${NumberFormat.compact().format(_outstandingTotal)}",
                      color: const Color(0xffef5350),
                      icon: Icons.access_time_filled,
                    ),
                  ),
                  const SizedBox(width: 16),
                  Expanded(
                    child: _MetricCard(
                      label: "Transactions",
                      value: "${_recentPayments.length}", // Just current count
                      color: accentGreen,
                      icon: Icons.check_circle,
                    ),
                  ),
                ],
              ),

              const SizedBox(height: 30),

              // 3. Line Chart
              const Text("Income Trend", style: TextStyle(color: Colors.white, fontSize: 18, fontWeight: FontWeight.bold)),
              const SizedBox(height: 16),
              Container(
                height: 300,
                padding: const EdgeInsets.only(right: 20, left: 10, top: 20, bottom: 10),
                decoration: BoxDecoration(
                  color: cardColor,
                  borderRadius: BorderRadius.circular(24),
                  border: Border.all(color: Colors.white10),
                ),
                child: LineChart(
                  LineChartData(
                    gridData: FlGridData(
                      show: true,
                      drawVerticalLine: false,
                      getDrawingHorizontalLine: (val) => FlLine(color: Colors.white10, strokeWidth: 1),
                    ),
                    titlesData: FlTitlesData(
                      leftTitles: const AxisTitles(sideTitles: SideTitles(showTitles: false)),
                      topTitles: const AxisTitles(sideTitles: SideTitles(showTitles: false)),
                      rightTitles: const AxisTitles(sideTitles: SideTitles(showTitles: false)),
                      bottomTitles: AxisTitles(
                        sideTitles: SideTitles(
                          showTitles: true,
                          interval: _selectedFilter == 'Monthly' ? 5 : 1, // Skip labels if crowded
                          getTitlesWidget: (val, meta) {
                            return Padding(
                              padding: const EdgeInsets.only(top: 8),
                              child: Text(
                                val.toInt().toString(), 
                                style: const TextStyle(color: Colors.grey, fontSize: 12),
                              ),
                            );
                          },
                        ),
                      ),
                    ),
                    borderData: FlBorderData(show: false),
                    minX: _trendSpots.isNotEmpty ? _trendSpots.first.x : 0,
                    maxX: _trendSpots.isNotEmpty ? _trendSpots.last.x : 10,
                    minY: 0,
                    maxY: _maxY,
                    lineBarsData: [
                      LineChartBarData(
                        spots: _trendSpots,
                        isCurved: true,
                        gradient: const LinearGradient(colors: [Color(0xff42a5f5), Color(0xff1565c0)]),
                        barWidth: 4,
                        isStrokeCapRound: true,
                        dotData: const FlDotData(show: false),
                        belowBarData: BarAreaData(
                          show: true,
                          gradient: LinearGradient(
                            colors: [const Color(0xff42a5f5).withAlpha(50), const Color(0xff42a5f5).withAlpha(0)],
                            begin: Alignment.topCenter,
                            end: Alignment.bottomCenter,
                          ),
                        ),
                      ),
                    ],
                  ),
                ),
              ),

              const SizedBox(height: 30),

              // 4. Recent Transactions List
              const Text("Recent Payments", style: TextStyle(color: Colors.white, fontSize: 18, fontWeight: FontWeight.bold)),
              const SizedBox(height: 16),
              if (_recentPayments.isEmpty)
                 const Center(child: Padding(padding: EdgeInsets.all(20), child: Text("No data available", style: TextStyle(color: Colors.grey))))
              else
                ..._recentPayments.map((p) => _PaymentListTile(payment: p)),
                
              const SizedBox(height: 50),
            ],
          ),
        ),
    );
  }
}

// --- WIDGETS ---

class _MetricCard extends StatelessWidget {
  final String label;
  final String value;
  final Color color;
  final IconData icon;

  const _MetricCard({required this.label, required this.value, required this.color, required this.icon});

  @override
  Widget build(BuildContext context) {
    return Container(
      padding: const EdgeInsets.all(16),
      decoration: BoxDecoration(
        color: const Color(0xff1c2a35),
        borderRadius: BorderRadius.circular(20),
        border: Border.all(color: Colors.white10),
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Row(
            mainAxisAlignment: MainAxisAlignment.spaceBetween,
            children: [
              Text(label, style: const TextStyle(color: Colors.grey, fontSize: 12)),
              Icon(icon, color: color, size: 18),
            ],
          ),
          const SizedBox(height: 8),
          Text(value, style: const TextStyle(color: Colors.white, fontSize: 20, fontWeight: FontWeight.bold)),
        ],
      ),
    );
  }
}

class _PaymentListTile extends StatelessWidget {
  final Map<String, dynamic> payment;

  const _PaymentListTile({required this.payment});

  @override
  Widget build(BuildContext context) {
    final amount = payment['amount'] as double;
    final date = DateTime.parse(payment['date_paid']);
    final method = payment['method'] ?? 'Cash';
    
    return Container(
      margin: const EdgeInsets.only(bottom: 12),
      padding: const EdgeInsets.all(16),
      decoration: BoxDecoration(
        color: const Color(0xff1c2a35),
        borderRadius: BorderRadius.circular(16),
      ),
      child: Row(
        children: [
          Container(
            padding: const EdgeInsets.all(10),
            decoration: BoxDecoration(
              color: const Color(0xff00c853).withAlpha(30),
              shape: BoxShape.circle,
            ),
            child: const Icon(Icons.attach_money, color: Color(0xff00c853), size: 20),
          ),
          const SizedBox(width: 16),
          Expanded(
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                const Text("Tuition Payment", style: TextStyle(color: Colors.white, fontWeight: FontWeight.bold)),
                Text(
                  DateFormat('MMM dd, hh:mm a').format(date), 
                  style: const TextStyle(color: Colors.grey, fontSize: 12),
                ),
              ],
            ),
          ),
          Column(
            crossAxisAlignment: CrossAxisAlignment.end,
            children: [
              Text("+\$${amount.toStringAsFixed(2)}", style: const TextStyle(color: Color(0xff00c853), fontWeight: FontWeight.bold)),
              Text(method, style: const TextStyle(color: Colors.grey, fontSize: 10)),
            ],
          )
        ],
      ),
    );
  }
}import 'package:flutter/material.dart';
import 'package:intl/intl.dart';
import '../services/database_service.dart';

class TermManagementSheet extends StatefulWidget {
  final Map<String, dynamic>? existingTerm; // If null, we are in "Add Mode"

  const TermManagementSheet({super.key, this.existingTerm});

  @override
  State<TermManagementSheet> createState() => _TermManagementSheetState();
}

class _TermManagementSheetState extends State<TermManagementSheet> {
  final _formKey = GlobalKey<FormState>();
  
  // Controllers
  final _nameCtrl = TextEditingController();
  final _yearCtrl = TextEditingController(); // e.g. "2025"
  final _numberCtrl = TextEditingController(); // e.g. "1", "2", "3"

  // Dates
  DateTime _startDate = DateTime.now();
  DateTime _endDate = DateTime.now().add(const Duration(days: 90)); // Default ~3 months

  bool _isSaving = false;

  @override
  void initState() {
    super.initState();
    _loadInitialData();
  }

  void _loadInitialData() {
    if (widget.existingTerm != null) {
      final t = widget.existingTerm!;
      _nameCtrl.text = t['name'] ?? '';
      _yearCtrl.text = (t['academic_year'] ?? DateTime.now().year).toString();
      _numberCtrl.text = (t['term_number'] ?? 1).toString();
      
      // Note: Dates would ideally be parsed from t['term_dates'] here if needed
    } else {
      // Defaults for new term
      _nameCtrl.text = "Term ${((DateTime.now().month / 4).ceil())}";
      _yearCtrl.text = DateTime.now().year.toString();
      _numberCtrl.text = "1";
    }
  }

  // --- Logic ---

  Future<void> _pickDate({required bool isStart}) async {
    final initial = isStart ? _startDate : _endDate;
    final picked = await showDatePicker(
      context: context,
      initialDate: initial,
      firstDate: DateTime(2020),
      lastDate: DateTime(2030),
      builder: (context, child) {
        return Theme(
          data: Theme.of(context).copyWith(
            colorScheme: const ColorScheme.dark(
              primary: Color(0xff3498db),
              surface: Color(0xff1c2a35),
            ),
          ),
          child: child!,
        );
      },
    );

    if (picked != null) {
      setState(() {
        if (isStart) {
          _startDate = picked;
          // Auto-adjust end date if it becomes before start
          if (_endDate.isBefore(_startDate)) {
            _endDate = _startDate.add(const Duration(days: 90));
          }
        } else {
          _endDate = picked;
        }
      });
    }
  }

  Future<void> _saveTerm() async {
    if (!_formKey.currentState!.validate()) return;
    setState(() => _isSaving = true);

    try {
      final db = DatabaseService.instance;
      
      // Prepare map for 'term_dates' JSON column
      final termNum = int.tryParse(_numberCtrl.text) ?? 1;
      
      await db.createTerm(
        id: widget.existingTerm?['id'], // If ID exists, it replaces (updates)
        name: _nameCtrl.text.trim(),
        academicYear: int.tryParse(_yearCtrl.text) ?? DateTime.now().year,
        termNumber: termNum,
        termDates: {
          termNum: {
            'start': _startDate,
            'end': _endDate
          }
        },
        // REMOVED: academic_year: null (This was causing the error)
      );

      if (mounted) {
        Navigator.pop(context, true); // Return true to trigger refresh
      }
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(SnackBar(content: Text("Error: $e")));
      }
    } finally {
      if (mounted) setState(() => _isSaving = false);
    }
  }

  @override
  Widget build(BuildContext context) {
    final isEditing = widget.existingTerm != null;
    
    // Custom Styles from your design
    const bgColor = Color(0xff121b22);
    const cardColor = Color(0xff1c2a35);
    const blueColor = Color(0xff2962ff); 
    
    final inputDecoration = BoxDecoration(
      color: const Color(0xff121b22), 
      borderRadius: BorderRadius.circular(12),
      border: Border.all(color: Colors.white.withAlpha(20)),
    );

    return Container(
      color: bgColor,
      height: MediaQuery.of(context).size.height * 0.85, 
      padding: const EdgeInsets.all(20),
      child: Column(
        children: [
          // Handle
          Center(
            child: Container(
              width: 40, height: 4,
              margin: const EdgeInsets.only(bottom: 20),
              decoration: BoxDecoration(color: Colors.grey.withAlpha(100), borderRadius: BorderRadius.circular(2)),
            ),
          ),
          
          // Header
          Row(
            children: [
              IconButton(
                icon: const Icon(Icons.close, color: Colors.white),
                onPressed: () => Navigator.pop(context),
              ),
              const SizedBox(width: 8),
              Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(
                    isEditing ? "Edit Academic Term" : "New Academic Term",
                    style: const TextStyle(color: Colors.white, fontSize: 20, fontWeight: FontWeight.bold),
                  ),
                  const Text(
                    "Billing Configuration",
                    style: TextStyle(color: Colors.grey, fontSize: 12),
                  ),
                ],
              )
            ],
          ),
          const SizedBox(height: 30),

          // --- FORM CARD ---
          Expanded(
            child: SingleChildScrollView(
              child: Container(
                padding: const EdgeInsets.all(20),
                decoration: BoxDecoration(
                  color: cardColor,
                  borderRadius: BorderRadius.circular(20),
                  border: Border.all(color: Colors.white.withAlpha(10)),
                ),
                child: Form(
                  key: _formKey,
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      // Term Name
                      _Label("Term Name"),
                      Container(
                        decoration: inputDecoration,
                        child: TextFormField(
                          controller: _nameCtrl,
                          style: const TextStyle(color: Colors.white, fontWeight: FontWeight.bold),
                          decoration: const InputDecoration(
                            hintText: "e.g. Autumn Term",
                            hintStyle: TextStyle(color: Colors.white24),
                            border: InputBorder.none,
                            contentPadding: EdgeInsets.all(16),
                          ),
                          validator: (v) => v!.isEmpty ? "Required" : null,
                        ),
                      ),
                      const SizedBox(height: 20),

                      // Row: Year & Number
                      Row(
                        children: [
                          Expanded(
                            flex: 2,
                            child: Column(
                              crossAxisAlignment: CrossAxisAlignment.start,
                              children: [
                                _Label("Academic Year"),
                                Container(
                                  decoration: inputDecoration,
                                  child: TextFormField(
                                    controller: _yearCtrl,
                                    keyboardType: TextInputType.number,
                                    style: const TextStyle(color: Colors.white, fontWeight: FontWeight.bold),
                                    decoration: const InputDecoration(
                                      hintText: "2025",
                                      border: InputBorder.none,
                                      contentPadding: EdgeInsets.all(16),
                                      suffixIcon: Icon(Icons.calendar_today, size: 16, color: Colors.white24),
                                    ),
                                  ),
                                ),
                              ],
                            ),
                          ),
                          const SizedBox(width: 16),
                          Expanded(
                            flex: 1,
                            child: Column(
                              crossAxisAlignment: CrossAxisAlignment.start,
                              children: [
                                _Label("Number"),
                                Container(
                                  decoration: inputDecoration,
                                  child: TextFormField(
                                    controller: _numberCtrl,
                                    keyboardType: TextInputType.number,
                                    textAlign: TextAlign.center,
                                    style: const TextStyle(color: Colors.white, fontWeight: FontWeight.bold),
                                    decoration: const InputDecoration(
                                      hintText: "1",
                                      border: InputBorder.none,
                                      contentPadding: EdgeInsets.all(16),
                                    ),
                                  ),
                                ),
                              ],
                            ),
                          ),
                        ],
                      ),
                      
                      const SizedBox(height: 24),
                      const Divider(color: Colors.white10),
                      const SizedBox(height: 24),

                      // Dates Header
                      const Row(
                        children: [
                          Icon(Icons.date_range, color: Colors.white54, size: 18),
                          SizedBox(width: 8),
                          Text(
                            "TERM DATES",
                            style: TextStyle(color: Colors.white54, fontWeight: FontWeight.bold, letterSpacing: 1.2, fontSize: 12),
                          ),
                        ],
                      ),
                      const SizedBox(height: 16),

                      Row(
                        children: [
                          // Start Date
                          Expanded(
                            child: Column(
                              crossAxisAlignment: CrossAxisAlignment.start,
                              children: [
                                _Label("START DATE"),
                                GestureDetector(
                                  onTap: () => _pickDate(isStart: true),
                                  child: Container(
                                    padding: const EdgeInsets.symmetric(vertical: 16, horizontal: 16),
                                    decoration: inputDecoration,
                                    child: Row(
                                      mainAxisAlignment: MainAxisAlignment.spaceBetween,
                                      children: [
                                        Text(
                                          DateFormat('dd/MM/yyyy').format(_startDate),
                                          style: const TextStyle(color: Colors.white, fontWeight: FontWeight.bold),
                                        ),
                                        const Icon(Icons.event, color: Colors.white54, size: 18),
                                      ],
                                    ),
                                  ),
                                ),
                              ],
                            ),
                          ),
                          const SizedBox(width: 16),
                          // End Date
                          Expanded(
                            child: Column(
                              crossAxisAlignment: CrossAxisAlignment.start,
                              children: [
                                _Label("END DATE"),
                                GestureDetector(
                                  onTap: () => _pickDate(isStart: false),
                                  child: Container(
                                    padding: const EdgeInsets.symmetric(vertical: 16, horizontal: 16),
                                    decoration: inputDecoration,
                                    child: Row(
                                      mainAxisAlignment: MainAxisAlignment.spaceBetween,
                                      children: [
                                        Text(
                                          DateFormat('dd/MM/yyyy').format(_endDate),
                                          style: const TextStyle(color: Colors.white, fontWeight: FontWeight.bold),
                                        ),
                                        const Icon(Icons.event_busy, color: Colors.white54, size: 18),
                                      ],
                                    ),
                                  ),
                                ),
                              ],
                            ),
                          ),
                        ],
                      ),
                    ],
                  ),
                ),
              ),
            ),
          ),

          // --- SAVE BUTTON ---
          const SizedBox(height: 20),
          SizedBox(
            width: double.infinity,
            height: 56,
            child: ElevatedButton.icon(
              onPressed: _isSaving ? null : _saveTerm,
              style: ElevatedButton.styleFrom(
                backgroundColor: blueColor,
                foregroundColor: Colors.white,
                shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
                elevation: 4,
                shadowColor: blueColor.withAlpha(100),
              ),
              icon: _isSaving 
                ? const SizedBox(width: 20, height: 20, child: CircularProgressIndicator(color: Colors.white, strokeWidth: 2)) 
                : const Icon(Icons.save),
              label: Text(
                _isSaving ? "SAVING..." : (isEditing ? "UPDATE TERM" : "CREATE TERM"),
                style: const TextStyle(fontSize: 16, fontWeight: FontWeight.bold, letterSpacing: 1.0),
              ),
            ),
          ),
          
          if (isEditing) ...[
            const SizedBox(height: 16),
            TextButton(
              onPressed: () => Navigator.pop(context),
              child: const Text("Cancel", style: TextStyle(color: Colors.grey)),
            )
          ] else 
            const SizedBox(height: 40), 
        ],
      ),
    );
  }
}

class _Label extends StatelessWidget {
  final String text;
  const _Label(this.text);

  @override
  Widget build(BuildContext context) {
    return Padding(
      padding: const EdgeInsets.only(bottom: 8, left: 2),
      child: Text(
        text,
        style: TextStyle(color: Colors.white.withAlpha(150), fontSize: 12, fontWeight: FontWeight.w600),
      ),
    );
  }
}// lib/providers/student_provider.dart
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../services/database_service.dart';
import '../models/student_full.dart';

// This provider streams the real list of students from your local database
final studentListStreamProvider = StreamProvider.autoDispose<List<StudentFull>>((ref) {
  final db = DatabaseService.instance;
  
  // 1. Force a refresh so the stream emits the latest data immediately
  db.refreshStudentFullCache(includeInactive: true);
  
  // 2. Return the stream of hydrated student data
  return db.studentFullStream;
});// lib/providers/dashboard_provider.dart
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../services/database_service.dart';
import '../models/dashboard_summary.dart';

// 1. Expose the DatabaseService instance
final databaseServiceProvider = Provider((ref) => DatabaseService.instance);

// 2. Dashboard Summary Provider
final dashboardSummaryProvider = FutureProvider.autoDispose<DashboardSummary>((ref) async {
  final dbService = ref.watch(databaseServiceProvider);
  
  // Force a refresh to get the latest data before calculation
  await dbService.refreshStudentFullCache(includeInactive: true); 

  // Fetch all hydrated student data
  final allStudents = await dbService.getAllStudentsWithFinancials(includeInactive: true);

  if (allStudents.isEmpty) {
    return DashboardSummary.initial();
  }

  // Aggregate metrics
  final activeStudents = allStudents.where((s) => s.student.isActive).length;
  final inactiveStudents = allStudents.length - activeStudents;
  
  // Calculate Financials
  // accurate summing using the getters in StudentFull
  final totalBilled = allStudents.fold(0.0, (sum, s) => sum + s.totalBilled);
  final totalPaid = allStudents.fold(0.0, (sum, s) => sum + s.totalPaid);
  final totalOwed = allStudents.fold(0.0, (sum, s) => sum + s.owed); 

  return DashboardSummary(
    activeStudents: activeStudents,
    inactiveStudents: inactiveStudents,
    totalFeesBilled: totalBilled,
    totalFeesPaid: totalPaid,
    totalFeesOwed: totalOwed,
  );
});// lib/providers/auth_provider.dart
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:flutter_riverpod/legacy.dart';
import 'package:supabase_flutter/supabase_flutter.dart';
import '../services/auth_service.dart';

// 1. Expose the AuthService instance
final authServiceProvider = Provider((ref) => AuthService());

// 2. StreamProvider to listen to Supabase's real-time auth changes
final authStateChangesProvider = StreamProvider.autoDispose<AuthState>((ref) {
  return Supabase.instance.client.auth.onAuthStateChange;
});

// 3. StateNotifierProvider to manage the User session (tracks bool)
class AuthController extends StateNotifier<AsyncValue<bool>> { 
  final AuthService _authService;
  
  // The state is AsyncValue<bool> where bool is isAuthenticated
  // The state starts as loading.
  AuthController(this._authService) : super(const AsyncValue.loading()) {
    _initializeAuth();
  }

  Future<void> _initializeAuth() async {
    try {
      // FIX 2: Corrected method name to match AuthService
      final isAuthenticated = await _authService.getInitialAuthStatus(); 
      state = AsyncValue.data(isAuthenticated);
    } catch (e, stack) {
      state = AsyncValue.error(e, stack);
    }
  }

  // Expose methods for UI to interact with
  Future<void> signIn({required String email, required String password}) async {
    state = const AsyncValue.loading();
    try {
      await _authService.signIn(email: email, password: password);
    } catch (e, stack) {
      state = AsyncValue.error(e, stack);
      rethrow;
    }
  }

  /// Handles user registration and triggers RLS profile creation.
  // FIX 3: Ensures 'fullName' is required and arguments match the AuthService signature.
  Future<void> signUp({required String email, required String password, required String fullName, String schoolName = 'My School'}) async {
    state = const AsyncValue.loading();
    try {
      await _authService.signUp(email: email, password: password, fullName: fullName, schoolName: schoolName);
    } catch (e, stack) {
      state = AsyncValue.error(e, stack);
      rethrow;
    }
  }
  
  Future<void> signOut() async {
    await _authService.signOutAndShutdown();
  }
}

// Update the provider definition to match the new state type (bool)
final authControllerProvider = StateNotifierProvider<AuthController, AsyncValue<bool>>((ref) {
  return AuthController(ref.watch(authServiceProvider));
});import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:intl/intl.dart';
import '../services/database_service.dart';

// -----------------------------------------------------------------------------
// UI DATA MODELS
// -----------------------------------------------------------------------------

/// Holds the aggregated data for the Finances Page
class FinancesPageData {
  final double totalRevenueYtd;
  final double totalOutstanding;
  final int openInvoicesCount;
  final List<AttentionItem> attentionList;
  final List<TransactionItem> recentTransactions;

  FinancesPageData({
    required this.totalRevenueYtd,
    required this.totalOutstanding,
    required this.openInvoicesCount,
    required this.attentionList,
    required this.recentTransactions,
  });

  factory FinancesPageData.initial() {
    return FinancesPageData(
      totalRevenueYtd: 0.0,
      totalOutstanding: 0.0,
      openInvoicesCount: 0,
      attentionList: [],
      recentTransactions: [],
    );
  }
}

/// Represents a student in the "Attention Needed" section
class AttentionItem {
  final String studentId;
  final String name;
  final double amountOwed;
  final String overdueText; // e.g., "Overdue 30+ Days"
  final String status; // e.g., "Unpaid" or "Partial"

  AttentionItem({
    required this.studentId,
    required this.name,
    required this.amountOwed,
    required this.overdueText,
    required this.status,
  });
}

/// Represents an item in "Recent Payments"
class TransactionItem {
  final String title;
  final String subtitle;
  final double amount;
  final DateTime date;
  final bool isIncome;

  TransactionItem({
    required this.title,
    required this.subtitle,
    required this.amount,
    required this.date,
    this.isIncome = true,
  });
}

// -----------------------------------------------------------------------------
// PROVIDER LOGIC
// -----------------------------------------------------------------------------

final financesProvider = FutureProvider.autoDispose<FinancesPageData>((ref) async {
  final db = DatabaseService.instance;
  
  // 1. Fetch Hydrated Data
  // We utilize the existing hydration logic to get all students, bills, and payments.
  final students = await db.getAllStudentsWithFinancials(includeInactive: true);

  double revenueSum = 0.0;
  double outstandingSum = 0.0;
  int openInvoiceCount = 0;
  
  List<AttentionItem> attentionItems = [];
  List<TransactionItem> transactions = [];

  final now = DateTime.now();
  final currentYear = now.year;

  // 2. Aggregate Data
  for (final student in students) {
    // A. Revenue (YTD)
    // Filter payments made in the current year
    final ytdPayments = student.payments.where((p) {
      if (p.datePaid == null) return false;
      return p.datePaid!.year == currentYear;
    });
    
    for (final p in ytdPayments) {
      revenueSum += p.amount;
    }

    // B. Outstanding & Open Invoices
    outstandingSum += student.owed;
    
    // Count bills that are not closed (paid_amount < total_amount)
    final openBills = student.bills.where((b) => !b.isClosed).toList();
    openInvoiceCount += openBills.length;

    // C. Build Attention List (Logic: If they owe money, find oldest open bill)
    if (student.owed > 1.0) { // Threshold to ignore tiny floating point errors
      String timeText = "Overdue";
      
      // Find oldest open bill date
      DateTime? oldestDate;
      if (openBills.isNotEmpty) {
        // Sort bills by creation date
        openBills.sort((a, b) => (a.createdAt ?? now).compareTo(b.createdAt ?? now));
        oldestDate = openBills.first.createdAt;
      }

      if (oldestDate != null) {
        final days = now.difference(oldestDate).inDays;
        if (days > 30) {
          timeText = "Overdue 30+ Days";
        } else if (days > 7) {
          timeText = "Overdue 7+ Days";
        } else {
          timeText = "Due Recently";
        }
      }

      attentionItems.add(AttentionItem(
        studentId: student.student.id,
        name: student.student.fullName ?? 'Unknown',
        amountOwed: student.owed,
        overdueText: timeText,
        status: student.owed >= (openBills.fold(0.0, (p,b) => p + b.totalAmount)) 
            ? 'Unpaid' 
            : 'Partial',
      ));
    }

    // D. Collect Transactions for "Recent List"
    for (final p in student.payments) {
      transactions.add(TransactionItem(
        title: "Payment Received",
        subtitle: "${student.student.fullName}  ${DateFormat('MMM d').format(p.datePaid ?? now)}",
        amount: p.amount,
        date: p.datePaid ?? now,
      ));
    }
  }

  // 3. Finalize Lists

  // Sort Attention list by amount owed (descending)
  attentionItems.sort((a, b) => b.amountOwed.compareTo(a.amountOwed));
  // Limit to top 5 for the view
  if (attentionItems.length > 5) attentionItems = attentionItems.sublist(0, 5);

  // Sort Transactions by date (descending)
  transactions.sort((a, b) => b.date.compareTo(a.date));
  // Limit to top 10
  if (transactions.length > 10) transactions = transactions.sublist(0, 10);

  return FinancesPageData(
    totalRevenueYtd: revenueSum,
    totalOutstanding: outstandingSum,
    openInvoicesCount: openInvoiceCount,
    attentionList: attentionItems,
    recentTransactions: transactions,
  );
});import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:flutter_riverpod/legacy.dart';
import '../services/settings_db_service.dart';

// --- State Model ---
class AppSettingsState {
  final bool biometricEnabled;
  final bool notificationsEnabled;
  final bool darkMode;
  final String language;

  AppSettingsState({
    this.biometricEnabled = false,
    this.notificationsEnabled = true,
    this.darkMode = true,
    this.language = 'English (US)',
  });

  AppSettingsState copyWith({
    bool? biometricEnabled,
    bool? notificationsEnabled,
    bool? darkMode,
    String? language,
  }) {
    return AppSettingsState(
      biometricEnabled: biometricEnabled ?? this.biometricEnabled,
      notificationsEnabled: notificationsEnabled ?? this.notificationsEnabled,
      darkMode: darkMode ?? this.darkMode,
      language: language ?? this.language,
    );
  }
}

// --- Notifier ---
class SettingsController extends StateNotifier<AsyncValue<AppSettingsState>> {
  final SettingsDatabaseService _db;

  SettingsController(this._db) : super(const AsyncValue.loading()) {
    _loadSettings();
  }

  Future<void> _loadSettings() async {
    try {
      final bio = await _db.getSetting('biometric_enabled', defaultValue: false);
      final notif = await _db.getSetting('notifications_enabled', defaultValue: true);
      final dark = await _db.getSetting('dark_mode', defaultValue: true);
      final lang = await _db.getSetting('language', defaultValue: 'English (US)');

      state = AsyncValue.data(AppSettingsState(
        biometricEnabled: bio,
        notificationsEnabled: notif,
        darkMode: dark,
        language: lang,
      ));
    } catch (e, st) {
      state = AsyncValue.error(e, st);
    }
  }

  Future<void> toggleBiometric(bool value) async {
    await _db.setSetting('biometric_enabled', value);
    // Optimistic update
    state = state.whenData((s) => s.copyWith(biometricEnabled: value));
  }

  Future<void> toggleNotifications(bool value) async {
    await _db.setSetting('notifications_enabled', value);
    state = state.whenData((s) => s.copyWith(notificationsEnabled: value));
  }

  Future<void> toggleDarkMode(bool value) async {
    await _db.setSetting('dark_mode', value);
    state = state.whenData((s) => s.copyWith(darkMode: value));
  }
}

// --- Provider Definition ---
final settingsProvider = StateNotifierProvider<SettingsController, AsyncValue<AppSettingsState>>((ref) {
  return SettingsController(SettingsDatabaseService.instance);
});

// ==========================================
// FILE: ./core_models.dart
// ==========================================

class School {
  final String id;
  final String name;
  final String subscriptionTier; // 'free', 'basic', 'pro'
  final int maxStudents;
  final bool isSuspended;
  final DateTime createdAt;

  School({
    required this.id,
    required this.name,
    this.subscriptionTier = 'free',
    this.maxStudents = 50,
    this.isSuspended = false,
    required this.createdAt,
  });

  factory School.fromRow(Map<String, dynamic> row) {
    return School(
      id: row['id'] as String,
      name: row['name'] as String,
      subscriptionTier: row['subscription_tier'] ?? 'free',
      maxStudents: (row['max_students'] as num?)?.toInt() ?? 50,
      isSuspended: (row['is_suspended'] == 1),
      createdAt: DateTime.parse(row['created_at']),
    );
  }
}

class UserProfile {
  final String id;
  final String email;
  final String fullName;
  final String role; // 'super_admin', 'school_admin', 'teacher', 'student'
  final String? schoolId;
  final bool isBanned;
  final String? avatarUrl;

  UserProfile({
    required this.id,
    required this.email,
    required this.fullName,
    this.role = 'teacher',
    this.schoolId,
    this.isBanned = false,
    this.avatarUrl,
  });

  factory UserProfile.fromRow(Map<String, dynamic> row) {
    return UserProfile(
      id: row['id'] as String,
      email: row['email'] as String,
      fullName: row['full_name'] as String,
      role: row['role'] ?? 'teacher',
      schoolId: row['school_id'] as String?,
      isBanned: (row['is_banned'] == 1),
      avatarUrl: row['avatar_url'] as String?,
    );
  }
}

class BillingConfig {
  final String id;
  final String? schoolId;
  final String currencyCode;
  final double lateFeePercentage;
  final String? invoiceFooterNote;
  final bool allowPartialPayments;
  final double defaultFee;

  BillingConfig({
    required this.id,
    this.schoolId,
    this.currencyCode = 'USD',
    this.lateFeePercentage = 0.0,
    this.invoiceFooterNote,
    this.allowPartialPayments = true,
    this.defaultFee = 100.00,
  });

  factory BillingConfig.fromRow(Map<String, dynamic> row) {
    return BillingConfig(
      id: row['id'] as String,
      schoolId: row['school_id'] as String?,
      currencyCode: row['currency_code'] ?? 'USD',
      lateFeePercentage: (row['late_fee_percentage'] as num?)?.toDouble() ?? 0.0,
      invoiceFooterNote: row['invoice_footer_note'] as String?,
      allowPartialPayments: (row['allow_partial_payments'] == 1),
      defaultFee: (row['default_fee'] as num?)?.toDouble() ?? 100.00,
    );
  }
}

class NotificationModel {
  final String id;
  final String userId;
  final String? schoolId;
  final String title;
  final String body;
  final String type; // 'info', 'warning', etc.
  final bool isRead;
  final DateTime createdAt;

  NotificationModel({
    required this.id,
    required this.userId,
    this.schoolId,
    required this.title,
    required this.body,
    this.type = 'info',
    this.isRead = false,
    required this.createdAt,
  });

  factory NotificationModel.fromRow(Map<String, dynamic> row) {
    return NotificationModel(
      id: row['id'] as String,
      userId: row['user_id'] as String,
      schoolId: row['school_id'] as String?,
      title: row['title'] as String,
      body: row['body'] as String,
      type: row['type'] ?? 'info',
      isRead: (row['is_read'] == 1),
      createdAt: DateTime.parse(row['created_at']),
    );
  }
}
// ==========================================
// FILE: ./academic_models.dart
// ==========================================

class ClassModel {
  final String id;
  final String schoolId;
  final String name;
  final String? teacherId;
  final String? roomNumber;
  final String? subjectCode;

  ClassModel({
    required this.id,
    required this.schoolId,
    required this.name,
    this.teacherId,
    this.roomNumber,
    this.subjectCode,
  });

  factory ClassModel.fromRow(Map<String, dynamic> row) {
    return ClassModel(
      id: row['id'] as String,
      schoolId: row['school_id'] as String,
      name: row['name'] as String,
      teacherId: row['teacher_id'] as String?,
      roomNumber: row['room_number'] as String?,
      subjectCode: row['subject_code'] as String?,
    );
  }
}

class Enrollment {
  final String id;
  final String schoolId;
  final String studentId;
  final String classId;
  final DateTime enrolledAt;

  Enrollment({
    required this.id,
    required this.schoolId,
    required this.studentId,
    required this.classId,
    required this.enrolledAt,
  });

  factory Enrollment.fromRow(Map<String, dynamic> row) {
    return Enrollment(
      id: row['id'] as String,
      schoolId: row['school_id'] as String,
      studentId: row['student_id'] as String,
      classId: row['class_id'] as String,
      enrolledAt: DateTime.tryParse(row['enrolled_at'] ?? '') ?? DateTime.now(),
    );
  }
}

class SchoolYear {
  final String id;
  final String schoolId;
  final String yearLabel; // e.g., "2025"
  final DateTime startDate;
  final DateTime endDate;
  final bool active;

  SchoolYear({
    required this.id,
    required this.schoolId,
    required this.yearLabel,
    required this.startDate,
    required this.endDate,
    this.active = false,
  });

  factory SchoolYear.fromRow(Map<String, dynamic> row) {
    return SchoolYear(
      id: row['id'] as String,
      schoolId: row['school_id'] as String,
      yearLabel: row['year_label'] as String,
      startDate: DateTime.parse(row['start_date']),
      endDate: DateTime.parse(row['end_date']),
      active: (row['active'] == 1),
    );
  }
}

class SchoolYearMonth {
  final String id;
  final String schoolYearId;
  final String name; // "January"
  final int monthIndex; // 1
  final DateTime startDate;
  final DateTime endDate;
  final bool isBillable;

  SchoolYearMonth({
    required this.id,
    required this.schoolYearId,
    required this.name,
    required this.monthIndex,
    required this.startDate,
    required this.endDate,
    this.isBillable = true,
  });

  factory SchoolYearMonth.fromRow(Map<String, dynamic> row) {
    return SchoolYearMonth(
      id: row['id'] as String,
      schoolYearId: row['school_year_id'] as String,
      name: row['name'] as String,
      monthIndex: (row['month_index'] as num).toInt(),
      startDate: DateTime.parse(row['start_date']),
      endDate: DateTime.parse(row['end_date']),
      isBillable: (row['is_billable'] == 1),
    );
  }
}

class SchoolTerm {
  final String id;
  final String schoolId;
  final String name; // "Term 1"
  final DateTime startDate;
  final DateTime endDate;
  final int academicYear;

  SchoolTerm({
    required this.id,
    required this.schoolId,
    required this.name,
    required this.startDate,
    required this.endDate,
    required this.academicYear,
  });

  factory SchoolTerm.fromRow(Map<String, dynamic> row) {
    return SchoolTerm(
      id: row['id'] as String,
      schoolId: row['school_id'] as String,
      name: row['name'] as String,
      startDate: DateTime.parse(row['start_date']),
      endDate: DateTime.parse(row['end_date']),
      academicYear: (row['academic_year'] as num).toInt(),
    );
  }
}
// ==========================================
// FILE: ./all_models.dart
// ==========================================

/// Greyway.Co - Batch Tech 
/// Master Models Export - "The Fortress Architecture"
library;

export 'academic_models.dart';
export 'announcement_model.dart';
export 'attendance_models.dart';
export 'broadcast_model.dart';
export 'core_models.dart';
export 'finance_details_model.dart';
export 'finance_models.dart';
export 'fundraiser_models.dart';
export 'staff_model.dart';
export 'student_model.dart';
export 'subjects.dart';
export 'system_models.dart' hide Expense;
// ==========================================
// FILE: ./announcement_model.dart
// ==========================================

import 'package:flutter/material.dart';
import '../../core/constants/app_colors.dart';

enum AnnouncementCategory {
  // Original
  financial,
  academic,
  urgent,
  system,
  
  // The "Rainbow" Types
  success,        // Green
  failure,        // Red
  warning,        // Amber
  info,           // Blue
  security,       // Purple
}

class Announcement {
  final String id;
  final String schoolId;
  final String title;
  final String body;
  final DateTime time;
  final AnnouncementCategory category;
  final bool isRead;
  final String? userId; // For personal notifications

  Announcement({
    required this.id,
    required this.schoolId,
    required this.title,
    required this.body,
    required this.time,
    required this.category,
    required this.isRead,
    this.userId,
  });

  // --- FACTORY: THE CRASH FIX ---
  factory Announcement.fromRow(Map<String, dynamic> row) {
    // 1. Safe Boolean Parsing (Handles 1, 0, true, false, and null)
    final rawRead = row['is_read'];
    bool isReadSafe = false;
    if (rawRead is bool) {
      isReadSafe = rawRead;
    } else if (rawRead is int) {
      isReadSafe = rawRead == 1;
    }

    // 2. Safe Date Parsing
    DateTime parsedTime = DateTime.now();
    if (row['created_at'] != null) {
      parsedTime = DateTime.tryParse(row['created_at'].toString())?.toLocal() ?? DateTime.now();
    }

    return Announcement(
      id: row['id']?.toString() ?? '',
      schoolId: row['school_id']?.toString() ?? '',
      userId: row['user_id']?.toString(),
      title: row['title']?.toString() ?? 'No Title',
      body: row['body']?.toString() ?? '',
      time: parsedTime,
      isRead: isReadSafe,
      category: _parseCategory(row['type']?.toString() ?? 'info'),
    );
  }

  static AnnouncementCategory _parseCategory(String type) {
    switch (type.toLowerCase()) {
      case 'financial': return AnnouncementCategory.financial;
      case 'academic': return AnnouncementCategory.academic;
      case 'urgent': return AnnouncementCategory.urgent;
      case 'system': return AnnouncementCategory.system;
      case 'success': return AnnouncementCategory.success;
      case 'failure': 
      case 'error': return AnnouncementCategory.failure;
      case 'warning': return AnnouncementCategory.warning;
      case 'security': return AnnouncementCategory.security;
      default: return AnnouncementCategory.info;
    }
  }

  Map<String, dynamic> toMap() {
    return {
      'id': id,
      'school_id': schoolId,
      'user_id': userId,
      'title': title,
      'body': body,
      'type': category.name, 
      'is_read': isRead ? 1 : 0, // Store as Int for SQLite compatibility
      'created_at': time.toIso8601String(),
    };
  }

  // --- VISUAL GETTERS ---

  Color get color {
    switch (category) {
      case AnnouncementCategory.urgent:
      case AnnouncementCategory.failure:
        return AppColors.errorRed;
      
      case AnnouncementCategory.warning:
        return Colors.amber;
      
      case AnnouncementCategory.success:
        return AppColors.successGreen;
      
      case AnnouncementCategory.financial:
        return const Color(0xFF00BFA5); // Teal
      
      case AnnouncementCategory.security:
        return const Color(0xFF9333EA); // Purple
        
      case AnnouncementCategory.system:
      case AnnouncementCategory.info:
      default:
        return AppColors.primaryBlue;
    }
  }

  IconData get icon {
    switch (category) {
      case AnnouncementCategory.urgent: return Icons.notification_important_rounded;
      case AnnouncementCategory.failure: return Icons.error_outline_rounded;
      case AnnouncementCategory.warning: return Icons.warning_amber_rounded;
      case AnnouncementCategory.success: return Icons.check_circle_outline_rounded;
      case AnnouncementCategory.financial: return Icons.attach_money_rounded;
      case AnnouncementCategory.security: return Icons.security_rounded;
      case AnnouncementCategory.academic: return Icons.school_outlined;
      case AnnouncementCategory.system: return Icons.dns_outlined;
      default: return Icons.info_outline_rounded;
    }
  }

  String get badgeLabel {
    return category.name.toUpperCase();
  }
}
// ==========================================
// FILE: ./attendance_models.dart
// ==========================================

class Attendance {
  final String id;
  final String schoolId;
  final String studentId;
  final String? classId;
  final DateTime date;
  final String status; // 'present', 'absent', 'late', 'excused'
  final String? remarks;
  final String? recordedBy;

  Attendance({
    required this.id,
    required this.schoolId,
    required this.studentId,
    this.classId,
    required this.date,
    this.status = 'present',
    this.remarks,
    this.recordedBy,
  });

  factory Attendance.fromRow(Map<String, dynamic> row) {
    return Attendance(
      id: row['id'] as String,
      schoolId: row['school_id'] as String,
      studentId: row['student_id'] as String,
      classId: row['class_id'] as String?,
      date: DateTime.parse(row['date']),
      status: row['status'] ?? 'present',
      remarks: row['remarks'] as String?,
      recordedBy: row['recorded_by'] as String?,
    );
  }
}

class AttendanceSession {
  final String id;
  final String schoolId;
  final String classId;
  final String teacherId;
  final DateTime sessionDate;
  final bool isConfirmedByTeacher;
  final DateTime? confirmedAt;

  AttendanceSession({
    required this.id,
    required this.schoolId,
    required this.classId,
    required this.teacherId,
    required this.sessionDate,
    this.isConfirmedByTeacher = false,
    this.confirmedAt,
  });

  factory AttendanceSession.fromRow(Map<String, dynamic> row) {
    return AttendanceSession(
      id: row['id'] as String,
      schoolId: row['school_id'] as String,
      classId: row['class_id'] as String,
      teacherId: row['teacher_id'] as String,
      sessionDate: DateTime.parse(row['session_date']),
      isConfirmedByTeacher: (row['is_confirmed_by_teacher'] == 1),
      confirmedAt: row['confirmed_at'] != null 
          ? DateTime.tryParse(row['confirmed_at']) 
          : null,
    );
  }
}
// ==========================================
// FILE: ./finance_models.dart
// ==========================================

// ==========================================
// BILL MODEL
// ==========================================
class Bill {
  final String id;
  final String schoolId;
  final String studentId;
  final String title;
  final double totalAmount;
  final double paidAmount;
  final bool isPaid;
  final DateTime? dueDate;
  final String billType; // 'monthly', 'adhoc'
  final bool isClosed;
  final String? termId;

  Bill({
    required this.id,
    required this.schoolId,
    required this.studentId,
    required this.title,
    required this.totalAmount,
    this.paidAmount = 0.0,
    this.isPaid = false,
    this.dueDate,
    this.billType = 'monthly',
    this.isClosed = false,
    this.termId,
  });

  factory Bill.fromRow(Map<String, dynamic> row) {
    return Bill(
      id: row['id'] as String,
      schoolId: row['school_id'] as String,
      studentId: row['student_id'] as String,
      title: row['title'] as String,
      totalAmount: (row['total_amount'] as num?)?.toDouble() ?? 0.0,
      paidAmount: (row['paid_amount'] as num?)?.toDouble() ?? 0.0,
      isPaid: (row['is_paid'] == 1),
      dueDate: row['due_date'] != null ? DateTime.tryParse(row['due_date']) : null,
      billType: row['bill_type'] ?? 'monthly',
      isClosed: (row['is_closed'] == 1),
      termId: row['term_id'] as String?,
    );
  }

  Map<String, dynamic> toMap() {
    return {
      'id': id,
      'school_id': schoolId,
      'student_id': studentId,
      'title': title,
      'total_amount': totalAmount,
      'paid_amount': paidAmount,
      'is_paid': isPaid ? 1 : 0,
      'due_date': dueDate?.toIso8601String(),
      'bill_type': billType,
      'is_closed': isClosed ? 1 : 0,
      'term_id': termId,
    };
  }
}

// ==========================================
// PAYMENT MODEL
// ==========================================
class Payment {
  final String id;
  final String schoolId;
  final String studentId;
  final double amount;
  final DateTime datePaid;
  final String method; // 'cash', 'ecocash', etc.
  final String? payerName;
  final String? billId;

  Payment({
    required this.id,
    required this.schoolId,
    required this.studentId,
    required this.amount,
    required this.datePaid,
    this.method = 'cash',
    this.payerName,
    this.billId,
  });

  factory Payment.fromRow(Map<String, dynamic> row) {
    return Payment(
      id: row['id'] as String,
      schoolId: row['school_id'] as String,
      studentId: row['student_id'] as String,
      amount: (row['amount'] as num?)?.toDouble() ?? 0.0,
      datePaid: row['date_paid'] != null 
          ? DateTime.tryParse(row['date_paid']) ?? DateTime.now()
          : DateTime.now(),
      method: row['method'] ?? 'cash',
      payerName: row['payer_name'] as String?,
      billId: row['bill_id'] as String?,
    );
  }

  Map<String, dynamic> toMap() {
    return {
      'id': id,
      'school_id': schoolId,
      'student_id': studentId,
      'amount': amount,
      'date_paid': datePaid.toIso8601String(),
      'method': method,
      'payer_name': payerName,
      'bill_id': billId,
    };
  }
}

class Expense {
  final String id;
  final String schoolId;
  final String title;
  final double amount;
  final String? category;
  final DateTime incurredAt;
  final String? description; // Maps to 'description' column
  final String? recipient;

  Expense({
    required this.id,
    required this.schoolId,
    required this.title,
    required this.amount,
    this.category,
    required this.incurredAt,
    this.description,
    this.recipient,
  });

  factory Expense.fromRow(Map<String, dynamic> row) {
    return Expense(
      id: row['id'] as String,
      schoolId: row['school_id'] as String,
      title: row['title'] as String,
      amount: (row['amount'] as num).toDouble(),
      category: row['category'] as String?,
      incurredAt: DateTime.tryParse(row['incurred_at'] ?? '') ?? DateTime.now(),
      description: row['description'] as String?,
      recipient: row['recipient'] as String?,
    );
  }

  Map<String, dynamic> toMap() {
    return {
      'id': id,
      'school_id': schoolId,
      'title': title,
      'amount': amount,
      'category': category,
      'incurred_at': incurredAt.toIso8601String(),
      'description': description,
      'recipient': recipient,
      // 'created_at' is usually handled by Supabase defaults, 
      // but for PowerSync offline-first, we often include it.
      'created_at': DateTime.now().toIso8601String(), 
    };
  }
}
// ==========================================
// FILE: ./subjects.dart
// ==========================================

// File: lib/models/subjects.dart

class ZimsecSubject {
  static const Map<int, String> _codeMap = {
    // --- FORM 1 - 4 (O-LEVEL) CORE ---
    // These are the "Must-Haves" for almost every student.
    4005: 'English Language',
    4004: 'Mathematics',
    4003: 'Combined Science', // Replaces Integrated Science
    4006: 'Heritage Studies',
    4007: 'Shona',
    4068: 'Ndebele',
    4001: 'Agriculture',

    // --- FORM 1 - 4 (O-LEVEL) POPULAR ELECTIVES ---
    // Commercials & Arts
    4049: 'Commerce',
    4037: 'Geography',
    4044: 'History',
    4047: 'Family & Religious Studies', // F.R.S (formerly Divinity/R.E)
    4048: 'Business Enterprise Skills',
    4051: 'Principles of Accounting',

    // Sciences & Tech
    4029: 'Computer Science',
    4025: 'Biology',
    4023: 'Physics',
    4024:
        'Chemistry', // Often listed as 5070/5071 in older systems, but 4024 in new curriculum maps
    4059: 'Wood Technology and Design',

    // --- FORM 5 - 6 (A-LEVEL) ---
    // Commercials
    6001: 'Accounting (A-Level)',
    6025: 'Business Studies',
    6073: 'Economics',

    // Arts / Humanities
    6022: 'Geography (A-Level)',
    6006: 'History (A-Level)',
    6003: 'Divinity',
    6009: 'Literature in English',
    6081: 'Heritage Studies (A-Level)',

    // Sciences
    6042: 'Pure Mathematics',
    6030: 'Biology (A-Level)',
    6031: 'Chemistry (A-Level)',
    6032: 'Physics (A-Level)',
    6046: 'Statistics',
    6008: 'Computer Science (A-Level)',
  };

  // This is the getter your Registration Page is looking for:
  static List<String> get allNames => _codeMap.values.toList();

  static String nameFromCode(int code) => _codeMap[code] ?? 'Unknown';
}

class EnrolledSubject {
  final String subjectName;
  final String studentId;

  EnrolledSubject({required this.subjectName, required this.studentId});

  Map<String, dynamic> toJson() => {
    'subjectName': subjectName,
    'studentId': studentId,
  };

  factory EnrolledSubject.fromJson(Map<String, dynamic> json) {
    return EnrolledSubject(
      subjectName: json['subjectName'],
      studentId: json['studentId'],
    );
  }
}
// ==========================================
// FILE: ./student_model.dart
// ==========================================

class Student {
  final String id;
  final String schoolId;
  final String fullName;
  final String? studentId; // Manual ID (e.g., "STD-001")
  final String? grade;
  final String? parentContact;
  final DateTime? registrationDate;
  final String billingType; // 'monthly', 'termly'
  final double defaultFee;
  final bool isActive;
  final double owedTotal;
  final double paidTotal;
  final String? termId;
  final DateTime? dateOfBirth;
  final String? gender;
  final String? address;
  final String? emergencyContactName;
  final String? medicalNotes;
  final bool photoConsent;

  Student({
    required this.id,
    required this.schoolId,
    required this.fullName,
    this.studentId,
    this.grade,
    this.parentContact,
    this.registrationDate,
    this.billingType = 'monthly',
    this.defaultFee = 0.0,
    this.isActive = true,
    this.owedTotal = 0.0,
    this.paidTotal = 0.0,
    this.termId,
    this.dateOfBirth,
    this.gender,
    this.address,
    this.emergencyContactName,
    this.medicalNotes,
    this.photoConsent = false,
  });

  // Factory to create a Student from a PowerSync/SQLite Row
  factory Student.fromRow(Map<String, dynamic> row) {
    return Student(
      id: row['id'] as String,
      schoolId: row['school_id'] as String,
      fullName: row['full_name'] as String,
      studentId: row['student_id'] as String?,
      grade: row['grade'] as String?,
      parentContact: row['parent_contact'] as String?,
      registrationDate: row['registration_date'] != null 
          ? DateTime.tryParse(row['registration_date']) 
          : null,
      billingType: row['billing_type'] ?? 'monthly',
      defaultFee: (row['default_fee'] as num?)?.toDouble() ?? 0.0,
      isActive: (row['is_active'] == 1), // SQLite stores bools as 0/1
      owedTotal: (row['owed_total'] as num?)?.toDouble() ?? 0.0,
      paidTotal: (row['paid_total'] as num?)?.toDouble() ?? 0.0,
      termId: row['term_id'] as String?,
      dateOfBirth: row['date_of_birth'] != null 
          ? DateTime.tryParse(row['date_of_birth']) 
          : null,
      gender: row['gender'] as String?,
      address: row['address'] as String?,
      emergencyContactName: row['emergency_contact_name'] as String?,
      medicalNotes: row['medical_notes'] as String?,
      photoConsent: (row['photo_consent'] == 1),
    );
  }

  // Convert to Map for saving to Database
  Map<String, dynamic> toMap() {
    return {
      'id': id,
      'school_id': schoolId,
      'full_name': fullName,
      'student_id': studentId,
      'grade': grade,
      'parent_contact': parentContact,
      'registration_date': registrationDate?.toIso8601String(),
      'billing_type': billingType,
      'default_fee': defaultFee,
      'is_active': isActive ? 1 : 0,
      'owed_total': owedTotal,
      'paid_total': paidTotal,
      'term_id': termId,
      'date_of_birth': dateOfBirth?.toIso8601String(),
      'gender': gender,
      'address': address,
      'emergency_contact_name': emergencyContactName,
      'medical_notes': medicalNotes,
      'photo_consent': photoConsent ? 1 : 0,
    };
  }
}
// ==========================================
// FILE: ./fundraiser_models.dart
// ==========================================

class Campaign {
  final String id;
  final String schoolId;
  final String createdById;
  final String name;
  final String? description;
  final String type; // Added to match Schema 'campaign_type'
  final String status; 
  final double goalAmount;
  final DateTime createdAt; // Useful for sorting

  Campaign({
    required this.id,
    required this.schoolId,
    required this.createdById,
    required this.name,
    this.description,
    this.type = 'General',
    this.status = 'active',
    this.goalAmount = 0.0,
    required this.createdAt,
  });

  factory Campaign.fromRow(Map<String, dynamic> row) {
    return Campaign(
      id: row['id'] as String,
      schoolId: row['school_id'] as String,
      createdById: row['created_by_id'] ?? '',
      name: row['name'] as String,
      description: row['description'] as String?,
      type: row['campaign_type'] ?? 'General',
      status: row['status'] ?? 'active',
      goalAmount: (row['goal_amount'] as num?)?.toDouble() ?? 0.0,
      createdAt: DateTime.tryParse(row['created_at'] ?? '') ?? DateTime.now(),
    );
  }

  Map<String, dynamic> toMap() {
    return {
      'id': id,
      'school_id': schoolId,
      'created_by_id': createdById,
      'name': name,
      'description': description,
      'campaign_type': type,
      'status': status,
      'goal_amount': goalAmount,
      'created_at': createdAt.toIso8601String(),
    };
  }
}

class CampaignDonation {
  final String id;
  final String campaignId;
  final String? donorName;
  final double amount;
  final String? paymentMethod;
  final DateTime dateReceived;
  final double expectedCash;
  final double actualCash;
  final double variance;

  CampaignDonation({
    required this.id,
    required this.campaignId,
    this.donorName,
    this.amount = 0.0,
    this.paymentMethod,
    required this.dateReceived,
    this.expectedCash = 0.0,
    this.actualCash = 0.0,
    this.variance = 0.0,
  });

  factory CampaignDonation.fromRow(Map<String, dynamic> row) {
    return CampaignDonation(
      id: row['id'] as String,
      campaignId: row['campaign_id'] as String,
      donorName: row['donor_name'] as String?,
      amount: (row['amount'] as num?)?.toDouble() ?? 0.0,
      paymentMethod: row['payment_method'] as String?,
      dateReceived: DateTime.tryParse(row['date_received'] ?? '') ?? DateTime.now(),
      expectedCash: (row['expected_cash'] as num?)?.toDouble() ?? 0.0,
      actualCash: (row['actual_cash'] as num?)?.toDouble() ?? 0.0,
      variance: (row['variance'] as num?)?.toDouble() ?? 0.0,
    );
  }
}

class CampaignExpense {
  final String id;
  final String campaignId;
  final String? category;
  final double amount;
  final String? incurredBy;

  CampaignExpense({
    required this.id,
    required this.campaignId,
    this.category,
    required this.amount,
    this.incurredBy,
  });

  factory CampaignExpense.fromRow(Map<String, dynamic> row) {
    return CampaignExpense(
      id: row['id'] as String,
      campaignId: row['campaign_id'] as String,
      category: row['category'] as String?,
      amount: (row['amount'] as num?)?.toDouble() ?? 0.0,
      incurredBy: row['incurred_by'] as String?,
    );
  }
}

class BankingRegister {
  final String id;
  final String? campaignId;
  final double amount;
  final String direction; // 'in' or 'out'
  final String? reference;
  final String schoolId;

  BankingRegister({
    required this.id,
    this.campaignId,
    required this.amount,
    required this.direction,
    this.reference,
    required this.schoolId,
  });

  factory BankingRegister.fromRow(Map<String, dynamic> row) {
    return BankingRegister(
      id: row['id'] as String,
      campaignId: row['campaign_id'] as String?,
      amount: (row['amount'] as num?)?.toDouble() ?? 0.0,
      direction: row['direction'] as String,
      reference: row['reference'] as String?,
      schoolId: row['school_id'] as String,
    );
  }
}
// ==========================================
// FILE: ./staff_model.dart
// ==========================================

// ==========================================
// TEACHER MODEL
// ==========================================
class Teacher {
  final String id;
  final String schoolId;
  final String fullName;
  final String? adminUid; // Links to user_profiles if they have logged in
  final DateTime createdAt;

  Teacher({
    required this.id,
    required this.schoolId,
    required this.fullName,
    this.adminUid,
    required this.createdAt,
  });

  factory Teacher.fromRow(Map<String, dynamic> row) {
    return Teacher(
      id: row['id'] as String,
      schoolId: row['school_id'] as String,
      fullName: row['full_name'] as String,
      adminUid: row['admin_uid'] as String?,
      createdAt: row['created_at'] != null 
          ? DateTime.tryParse(row['created_at']) ?? DateTime.now() 
          : DateTime.now(),
    );
  }

  Map<String, dynamic> toMap() {
    return {
      'id': id,
      'school_id': schoolId,
      'full_name': fullName,
      'admin_uid': adminUid,
      'created_at': createdAt.toIso8601String(),
    };
  }
}

// ==========================================
// TEACHER ACCESS TOKEN MODEL
// ==========================================
class TeacherAccessToken {
  final String id;
  final String schoolId;
  final String teacherId;
  final String grantedByTeacherId;
  final String accessCode;
  final String permissionType; // 'attendance', 'campaigns', 'both'
  final bool isUsed;
  final DateTime? usedAt;
  final DateTime expiresAt;

  TeacherAccessToken({
    required this.id,
    required this.schoolId,
    required this.teacherId,
    required this.grantedByTeacherId,
    required this.accessCode,
    required this.permissionType,
    this.isUsed = false,
    this.usedAt,
    required this.expiresAt,
  });

  bool get isExpired => DateTime.now().isAfter(expiresAt);

  factory TeacherAccessToken.fromRow(Map<String, dynamic> row) {
    return TeacherAccessToken(
      id: row['id'] as String,
      schoolId: row['school_id'] as String,
      teacherId: row['teacher_id'] as String,
      grantedByTeacherId: row['granted_by_teacher_id'] as String,
      accessCode: row['access_code'] as String,
      permissionType: row['permission_type'] ?? 'attendance',
      isUsed: (row['is_used'] == 1), // SQLite boolean handling
      usedAt: row['used_at'] != null 
          ? DateTime.tryParse(row['used_at']) 
          : null,
      expiresAt: row['expires_at'] != null 
          ? DateTime.tryParse(row['expires_at']) ?? DateTime.now()
          : DateTime.now(),
    );
  }

  Map<String, dynamic> toMap() {
    return {
      'id': id,
      'school_id': schoolId,
      'teacher_id': teacherId,
      'granted_by_teacher_id': grantedByTeacherId,
      'access_code': accessCode,
      'permission_type': permissionType,
      'is_used': isUsed ? 1 : 0,
      'used_at': usedAt?.toIso8601String(),
      'expires_at': expiresAt.toIso8601String(),
    };
  }
}
// ==========================================
// FILE: ./broadcast_model.dart
// ==========================================

import 'package:fees_up/core/constants/app_colors.dart';
import 'package:flutter/material.dart';

class Broadcast {
  final String id;
  final String? schoolId; // Null = Global Greyway.Co Broadcast
  final String authorId;
  final bool isSystemMessage;
  final String targetRole; // 'all', 'teacher', 'hq_internal'
  final String title;
  final String body;
  final String priority;
  final DateTime createdAt;

  Broadcast({
    required this.id,
    this.schoolId,
    required this.authorId,
    this.isSystemMessage = false,
    required this.targetRole,
    required this.title,
    required this.body,
    required this.priority,
    required this.createdAt,
  });

  factory Broadcast.fromRow(Map<String, dynamic> row) {
    return Broadcast(
      id: row['id'] as String,
      schoolId: row['school_id'] as String?,
      authorId: row['author_id'] as String,
      isSystemMessage: (row['is_system_message'] == 1),
      targetRole: row['target_role'] ?? 'all',
      title: row['title'] as String,
      body: row['body'] as String,
      priority: row['priority'] ?? 'normal',
      createdAt: DateTime.tryParse(row['created_at'] ?? '') ?? DateTime.now(),
    );
  }

  Map<String, dynamic> toMap() {
    return {
      'id': id,
      'school_id': schoolId,
      'author_id': authorId,
      'is_system_message': isSystemMessage ? 1 : 0,
      'target_role': targetRole,
      'title': title,
      'body': body,
      'priority': priority,
      'created_at': createdAt.toIso8601String(),
    };
  }

  // --- CE0 UI HELPERS ---
  
  bool get isInternalHQ => targetRole == 'hq_internal';

  Color get badgeColor {
    if (isInternalHQ) return AppColors.accentPurpleDark; // Security Purple
    if (isSystemMessage) return  AppColors.primaryBlue; // System Blue
    if (priority == 'critical') return AppColors.errorRed; // Failure Red
    return AppColors.successGreen; // General Green
  }

  String get authorLabel {
    if (isInternalHQ) return "Greyway HQ";
    if (isSystemMessage) return "Fees Up System";
    return "School Admin";
  }

  IconData get icon {
    if (isInternalHQ) return Icons.security;
    if (isSystemMessage) return Icons.settings_suggest;
    if (priority == 'critical') return Icons.report_problem;
    return Icons.campaign;
  }
}
// ==========================================
// FILE: ./finance_details_model.dart
// ==========================================

// ==========================================
// BILL ITEM MODEL (Line items inside a bill)
// ==========================================
class BillItem {
  final String id;
  final String billId;
  final String schoolId;
  final String description;
  final double amount;
  final int quantity;

  BillItem({
    required this.id,
    required this.billId,
    required this.schoolId,
    required this.description,
    required this.amount,
    this.quantity = 1,
  });

  // Calculate total for this line item
  double get total => amount * quantity;

  factory BillItem.fromRow(Map<String, dynamic> row) {
    return BillItem(
      id: row['id'] as String,
      billId: row['bill_id'] as String,
      schoolId: row['school_id'] as String,
      description: row['description'] as String,
      amount: (row['amount'] as num?)?.toDouble() ?? 0.0,
      quantity: (row['quantity'] as num?)?.toInt() ?? 1,
    );
  }

  Map<String, dynamic> toMap() {
    return {
      'id': id,
      'bill_id': billId,
      'school_id': schoolId,
      'description': description,
      'amount': amount,
      'quantity': quantity,
    };
  }
}

// ==========================================
// PAYMENT ALLOCATION MODEL (Splitting one payment across bills)
// ==========================================
class PaymentAllocation {
  final String id;
  final String paymentId;
  final String billId;
  final String schoolId;
  final double amount;

  PaymentAllocation({
    required this.id,
    required this.paymentId,
    required this.billId,
    required this.schoolId,
    required this.amount,
  });

  factory PaymentAllocation.fromRow(Map<String, dynamic> row) {
    return PaymentAllocation(
      id: row['id'] as String,
      paymentId: row['payment_id'] as String,
      billId: row['bill_id'] as String,
      schoolId: row['school_id'] as String,
      amount: (row['amount'] as num?)?.toDouble() ?? 0.0,
    );
  }

  Map<String, dynamic> toMap() {
    return {
      'id': id,
      'payment_id': paymentId,
      'bill_id': billId,
      'school_id': schoolId,
      'amount': amount,
    };
  }
}

// ==========================================
// CREDIT MODEL (Discounts or overpayments)
// ==========================================
class Credit {
  final String id;
  final String schoolId;
  final String studentId;
  final String? billId; // If applied to a specific bill
  final double amount;
  final String? reason;
  final String? creditId; // Manual reference ID

  Credit({
    required this.id,
    required this.schoolId,
    required this.studentId,
    required this.amount,
    this.billId,
    this.reason,
    this.creditId,
  });

  factory Credit.fromRow(Map<String, dynamic> row) {
    return Credit(
      id: row['id'] as String,
      schoolId: row['school_id'] as String,
      studentId: row['student_id'] as String,
      amount: (row['amount'] as num?)?.toDouble() ?? 0.0,
      billId: row['bill_id'] as String?,
      reason: row['reason'] as String?,
      creditId: row['credit_id'] as String?,
    );
  }

  Map<String, dynamic> toMap() {
    return {
      'id': id,
      'school_id': schoolId,
      'student_id': studentId,
      'amount': amount,
      'bill_id': billId,
      'reason': reason,
      'credit_id': creditId,
    };
  }
}
// ==========================================
// FILE: ./system_models.dart
// ==========================================

import 'dart:convert'; // Required for JSON decoding

class StudentArchive {
  final String id;
  final String schoolId;
  final String? fullName;
  final String? reason;
  final DateTime archivedAt;
  final Map<String, dynamic>? originalData; // Stored as JSONB in SQL

  StudentArchive({
    required this.id,
    required this.schoolId,
    this.fullName,
    this.reason,
    required this.archivedAt,
    this.originalData,
  });

  factory StudentArchive.fromRow(Map<String, dynamic> row) {
    return StudentArchive(
      id: row['id'] as String,
      schoolId: row['school_id'] as String,
      fullName: row['full_name'] as String?,
      reason: row['reason'] as String?,
      archivedAt: DateTime.tryParse(row['archived_at'] ?? '') ?? DateTime.now(),
      // Handle potential JSON string from SQLite
      originalData: row['original_data'] != null
          ? (row['original_data'] is String 
              ? jsonDecode(row['original_data']) 
              : row['original_data'])
          : null,
    );
  }
}

class Expense {
  final String id;
  final String schoolId;
  final String title;
  final double amount;
  final String? category;
  final DateTime incurredAt;
  final String? description;
  final String? recipient;
  final String? paymentMethod;

  Expense({
    required this.id,
    required this.schoolId,
    required this.title,
    required this.amount,
    this.category,
    required this.incurredAt,
    this.description,
    this.recipient,
    this.paymentMethod,
  });

  factory Expense.fromRow(Map<String, dynamic> row) {
    return Expense(
      id: row['id'] as String,
      schoolId: row['school_id'] as String,
      title: row['title'] as String,
      amount: (row['amount'] as num).toDouble(),
      category: row['category'] as String?,
      incurredAt: DateTime.tryParse(row['incurred_at'] ?? '') ?? DateTime.now(),
      description: row['description'] as String?,
      recipient: row['recipient'] as String?,
      paymentMethod: row['payment_method'] as String?,
    );
  }

  Map<String, dynamic> toMap() {
    return {
      'id': id,
      'school_id': schoolId,
      'title': title,
      'amount': amount,
      'category': category,
      'incurred_at': incurredAt.toIso8601String(),
      'description': description,
      'recipient': recipient,
      'payment_method': paymentMethod,
    };
  }
}